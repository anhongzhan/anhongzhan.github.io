<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>cppsocket01 -- 一个最简单的socket</title>
    <link href="/2023/08/24/cppsocket01/"/>
    <url>/2023/08/24/cppsocket01/</url>
    
    <content type="html"><![CDATA[<h2 id="0、写在前面"><a href="#0、写在前面" class="headerlink" title="0、写在前面"></a>0、写在前面</h2><p>本系列主要负责记录学习cpp socket编程的经验，初次学习，难免有不全面的地方！！！</p><p>参考内容：<a href="https://csblog.cc/30dayMakeCppServer/">30天自制C++服务器</a></p><h2 id="1、最基本的socket"><a href="#1、最基本的socket" class="headerlink" title="1、最基本的socket"></a>1、最基本的socket</h2><p>socket，中文名称为套接字，是计算机之间进行通信的一种约定，通过socket这种约定，我们就能实现计算机之间的通信。</p><p>socket编程属于网络编程的一部分，既然涉及到网络，就必须包含客户端和服务端</p><p><img src="/2023/08/24/cppsocket01/socket%E7%A4%BA%E4%BE%8B.png" alt="socket示例"></p><h2 id="2、服务端"><a href="#2、服务端" class="headerlink" title="2、服务端"></a>2、服务端</h2><h3 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h3><p>我们按照上图的流程来，首先是创建socket</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-type">int</span> sockfd = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><ul><li>第一个参数表示IP地址类型，AF_INET表示IPv4，AF_INET6表示IPv6</li><li>第二个参数表示数据传输方式，SOCK_STREAM表示流格式、面向连接，多用于TCP。SOCK_DGRAM表示数据报格式、无连接，多用于UDP</li><li>第三个参数表示协议，0表示根据前面两个参数自动推导协议类型，IPPROTO_TCP和IPPTOTO_UDP分别表示TCP和UDP</li></ul><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p>计算机网络中，主机之间通信需要通过IP地址，主机中的进程通信则需要额外知道端口号</p><p>sockaddr_in负责存储主机和端口号，其数据结构如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> &#123;<br>        <span class="hljs-type">short</span>   sin_family;         <span class="hljs-comment">//address family</span><br>        u_short sin_port;           <span class="hljs-comment">//16 bit TCP/UDP port number</span><br>        <span class="hljs-keyword">struct</span>  <span class="hljs-title class_">in_addr</span> sin_addr;   <span class="hljs-comment">//32 bit IP address</span><br>        <span class="hljs-type">char</span>    sin_zero[<span class="hljs-number">8</span>];        <span class="hljs-comment">//not use, for align</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>我们使用bzero函数初始化这个数据结构,bzero会将内存区域前n个字节全部设为0</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> serv_addr;<br><span class="hljs-built_in">bzero</span>(&amp;serv_addr, <span class="hljs-built_in">sizeof</span>(serv_addr));<br><br><span class="hljs-comment">//初始化serv_addr</span><br>serv_addr.sin_family = AF_INET;<br>serv_addr.sin_addr.s_addr = <span class="hljs-built_in">inet_addr</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>);<br>serv_addr.sin_port = <span class="hljs-built_in">htons</span>(<span class="hljs-number">8888</span>);<br><br><span class="hljs-comment">//将socket地址与文件描述符绑定</span><br><span class="hljs-built_in">bind</span>(sockfd, (sockaddr*)&amp;serv_addr, <span class="hljs-built_in">sizeof</span>(serv_addr));<br></code></pre></td></tr></table></figure><h3 id="listen"><a href="#listen" class="headerlink" title="listen"></a>listen</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">listen</span>(sockfd, SOMAXCONN);<br></code></pre></td></tr></table></figure><p>listen的第二个参数是Listen函数的最大监听队列长度，SOMAXCONN表示128</p><h3 id="accept"><a href="#accept" class="headerlink" title="accept"></a>accept</h3><p>一旦监听到客户端的连接，我们就需要使用accept函数接收该连接</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> clnt_addr;<br><span class="hljs-type">socklen_t</span> clnt_addr_len = <span class="hljs-built_in">sizeof</span>(clnt_addr);<br><span class="hljs-built_in">bzero</span>(&amp;clnt_addr, <span class="hljs-built_in">sizeof</span>(clnt_addr));<br><span class="hljs-type">int</span> clnt_sockfd = <span class="hljs-built_in">accept</span>(sockfd, (sockaddr*)&amp;clnt_addr, &amp;clnt_addr_len);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;new client fd %d! IP: %s Port: %d\n&quot;</span>, clnt_sockfd, <span class="hljs-built_in">inet_ntoa</span>(clnt_addr.sin_addr), <span class="hljs-built_in">ntohs</span>(clnt_addr.sin_port));<br></code></pre></td></tr></table></figure><h2 id="3、客户端"><a href="#3、客户端" class="headerlink" title="3、客户端"></a>3、客户端</h2><h3 id="socket-1"><a href="#socket-1" class="headerlink" title="socket"></a>socket</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> sockfd = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> serv_addr;<br><span class="hljs-built_in">bzero</span>(&amp;serv_addr, <span class="hljs-built_in">sizeof</span>(serv_addr));<br></code></pre></td></tr></table></figure><h3 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">serv_addr.sin_family = AF_INET;<br>serv_addr.sin_addr.s_addr = <span class="hljs-built_in">inet_addr</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>);<br>serv_addr.sin_port = <span class="hljs-built_in">htons</span>(<span class="hljs-number">8888</span>);<br><span class="hljs-built_in">connect</span>(sockfd, (sockaddr*)&amp;serv_addr, <span class="hljs-built_in">sizeof</span>(serv_addr));  <br></code></pre></td></tr></table></figure><p>最简单的服务器已经完成！！！</p>]]></content>
    
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>socket</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从C开始的CPP学习生活07-模板</title>
    <link href="/2022/10/26/cppnote07/"/>
    <url>/2022/10/26/cppnote07/</url>
    
    <content type="html"><![CDATA[<h2 id="1、函数模板"><a href="#1、函数模板" class="headerlink" title="1、函数模板"></a>1、函数模板</h2><h3 id="1-1、定义"><a href="#1-1、定义" class="headerlink" title="1.1、定义"></a>1.1、定义</h3><p>通过函数重载，实现同名函数，根据不同的参数类型，进行智能调用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; a &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">double</span> d)</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; d &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过上面的方法，我们在main函数中调用fun函数，传入不同的参数就会调用不同的函数</p><p>但这带来的问题是如果参数类型变得更多，会使得fun函数的数量变得过多</p><p>C++采用函数模板的方式解决这样的问题，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T a)</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; a &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们只需要实现一个函数就可以实现前面多个函数重载实现的功能</p><p>这就是函数模板的好处：模板是泛型编程的一种重要思想，stl就是利用模板实现的一个具体实例</p><h3 id="1-2、注意事项"><a href="#1-2、注意事项" class="headerlink" title="1.2、注意事项"></a>1.2、注意事项</h3><h4 id="1-2-1、函数模板也可以这样编写："><a href="#1-2-1、函数模板也可以这样编写：" class="headerlink" title="1.2.1、函数模板也可以这样编写："></a>1.2.1、函数模板也可以这样编写：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br></code></pre></td></tr></table></figure><h4 id="1-2-2、函数模板可以有多个参数"><a href="#1-2-2、函数模板可以有多个参数" class="headerlink" title="1.2.2、函数模板可以有多个参数"></a>1.2.2、函数模板可以有多个参数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Y&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T a)</span> <span class="hljs-comment">//ERROR</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; a &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是要注意，定义了模板之后一定要为其指定类型，上面的代码就是错误的，编译阶段会报错<code>error C2783: &#39;void fun(T)&#39;: could not deduce template argument for &#39;Y&#39;</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Y&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T a, Y y)</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; a &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">fun</span>(<span class="hljs-number">12</span>, <span class="hljs-number">16.35f</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-2-3、class和typename可以交叉使用"><a href="#1-2-3、class和typename可以交叉使用" class="headerlink" title="1.2.3、class和typename可以交叉使用"></a>1.2.3、class和typename可以交叉使用</h4><h4 id="1-2-4、template作用域"><a href="#1-2-4、template作用域" class="headerlink" title="1.2.4、template作用域"></a>1.2.4、template作用域</h4><p>template仅对挨着的代码段有效</p><h2 id="2、模板的具体化"><a href="#2、模板的具体化" class="headerlink" title="2、模板的具体化"></a>2、模板的具体化</h2><p>函数模板的具体化的意思是针对某些特殊类型的数据进行处理，比如类和结构体，也可以对基本数据类型进行处理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span><br>&#123;<br><span class="hljs-type">int</span> a;<br><span class="hljs-type">double</span> b;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T a)</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; a &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-type">void</span> <span class="hljs-built_in">fun</span>&lt;Node&gt;(Node no)<br>&#123;<br>std::cout &lt;&lt; no.a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; no.b &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Node no = &#123; <span class="hljs-number">12</span>, <span class="hljs-number">5.6</span> &#125;;<br><span class="hljs-built_in">fun</span>(no);<br><span class="hljs-built_in">fun</span>(<span class="hljs-number">12</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-1、普通函数、函数模板以及模板具体化的优先级"><a href="#2-1、普通函数、函数模板以及模板具体化的优先级" class="headerlink" title="2.1、普通函数、函数模板以及模板具体化的优先级"></a>2.1、普通函数、函数模板以及模板具体化的优先级</h3><p>优先级方面：普通函数  &gt; 函数模板的具体化 &gt; 函数模板</p><p>即当三种类型的函数都存在时，系统会优先调用普通函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T a)</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; a &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-type">void</span> <span class="hljs-built_in">fun</span>&lt;Node&gt;(Node no)<br>&#123;<br>std::cout &lt;&lt; no.a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; no.b &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(Node no)</span> </span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>系统会有限调用最下面的fun函数</p><h2 id="3、函数模板的实例化"><a href="#3、函数模板的实例化" class="headerlink" title="3、函数模板的实例化"></a>3、函数模板的实例化</h2><p>模板函数会根据我们传入的不同的参数类型在底层生成不同的函数，我们也可以强制编译器生成某种参数的函数，这就是函数模板的实例化</p><p>同时，我们将根据传入参数的类型生成的函数称为隐式实例化，使用强制手法生成的函数叫做显示实例化。如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T a)</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; a &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>当我们调用fun(1.5f)时，编译器会生成float类型的函数</p><p>我们使用显示实例化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T a)</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; a &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-keyword">template</span> <span class="hljs-type">void</span> <span class="hljs-built_in">fun</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-type">int</span> a);<br></code></pre></td></tr></table></figure><p>我们调用fun(1.5f)时，编译器会生成float和int类型的实例化，因为int类型是显示的实例化</p><h2 id="4、类模板"><a href="#4、类模板" class="headerlink" title="4、类模板"></a>4、类模板</h2><p>类模板在定义时与函数模板大致相同，调用时则需要指定类名</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CFather</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>T a;<br><span class="hljs-built_in">CFather</span>(T t) : <span class="hljs-built_in">a</span>(t) &#123;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; a &lt;&lt; std::endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">CFather&lt;<span class="hljs-type">char</span>&gt; <span class="hljs-title">pf</span><span class="hljs-params">(<span class="hljs-string">&#x27;k&#x27;</span>)</span></span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>类模板可以指定默认参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> K = <span class="hljs-type">int</span>&gt;<br><span class="hljs-keyword">class</span> CFather<br>&#123;<br><span class="hljs-keyword">public</span>:<br>T a;<br><span class="hljs-built_in">CFather</span>(T t) : <span class="hljs-built_in">a</span>(t) &#123;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; a &lt;&lt; std::endl;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>但是，同函数的默认参数一样，类模板的默认参数只能从右向左指定，下面的写法就是错误的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T = <span class="hljs-type">char</span>, <span class="hljs-keyword">typename</span> K&gt; <span class="hljs-comment">//ERROR</span><br></code></pre></td></tr></table></figure><h3 id="4-1、只有类模板可以指定默认值，函数模板不可以"><a href="#4-1、只有类模板可以指定默认值，函数模板不可以" class="headerlink" title="4.1、只有类模板可以指定默认值，函数模板不可以"></a>4.1、只有类模板可以指定默认值，函数模板不可以</h3><h3 id="4-2、类模板的类，有默认值时-lt-gt-里面可以不传参数类型，但是必须有-lt-gt"><a href="#4-2、类模板的类，有默认值时-lt-gt-里面可以不传参数类型，但是必须有-lt-gt" class="headerlink" title="4.2、类模板的类，有默认值时&lt;&gt;里面可以不传参数类型，但是必须有&lt;&gt;"></a>4.2、类模板的类，有默认值时&lt;&gt;里面可以不传参数类型，但是必须有&lt;&gt;</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">CFather&lt;<span class="hljs-type">int</span>, <span class="hljs-type">char</span>&gt; *k = <span class="hljs-keyword">new</span> <span class="hljs-built_in">CFather</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">char</span>&gt;(<span class="hljs-string">&#x27;1&#x27;</span>);<span class="hljs-comment">//指针定义</span><br></code></pre></td></tr></table></figure><h3 id="4-3、类内函数类外定义"><a href="#4-3、类内函数类外定义" class="headerlink" title="4.3、类内函数类外定义"></a>4.3、类内函数类外定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> K&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CFather</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>T a;<br><span class="hljs-built_in">CFather</span>(T t) : <span class="hljs-built_in">a</span>(t) &#123;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-type">void</span> CFather&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt;::<span class="hljs-built_in">show</span>() &#123;<br>std::cout &lt;&lt; a &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们也可以对show函数使用函数模板，但是注意，<strong>函数模板不能设置默认参数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> K&gt;<br><span class="hljs-type">void</span> CFather&lt;T, K&gt;::<span class="hljs-built_in">show</span>() &#123;<br>std::cout &lt;&lt; a &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5、继承的模板"><a href="#5、继承的模板" class="headerlink" title="5、继承的模板"></a>5、继承的模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> K&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CFather</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>T a;<br><span class="hljs-built_in">CFather</span>(T t) : <span class="hljs-built_in">a</span>(t) &#123;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; a &lt;&lt; std::endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> X, <span class="hljs-keyword">typename</span> Z&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CSon</span> : <span class="hljs-keyword">public</span> CFather&lt;X, Z&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">CSon</span>() : <span class="hljs-built_in">CFather</span>&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-string">&#x27;1&#x27;</span>) &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="6、多态的模板"><a href="#6、多态的模板" class="headerlink" title="6、多态的模板"></a>6、多态的模板</h2><p>子类和父类都有模板列表时：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> K&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CFather</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;CFather&quot;</span> &lt;&lt; std::endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> X, <span class="hljs-keyword">typename</span> Z&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CSon</span> : <span class="hljs-keyword">public</span> CFather&lt;X, Z&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;CSon&quot;</span> &lt;&lt; std::endl;<br>&#125;<br>&#125;;<br><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>CFather&lt;<span class="hljs-type">int</span>, <span class="hljs-type">char</span>&gt;* pf = <span class="hljs-keyword">new</span> CSon&lt;<span class="hljs-type">int</span>, <span class="hljs-type">char</span>&gt;;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当子类没有模板时</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> K&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CFather</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;CFather&quot;</span> &lt;&lt; std::endl;<br>&#125;<br>&#125;;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CSon</span> : <span class="hljs-keyword">public</span> CFather&lt;<span class="hljs-type">int</span>, <span class="hljs-type">char</span>&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;CSon&quot;</span> &lt;&lt; std::endl;<br>&#125;<br>&#125;;<br><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>CFather&lt;<span class="hljs-type">int</span>, <span class="hljs-type">char</span>&gt;* pf = <span class="hljs-keyword">new</span> CSon;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>第二种方式使用的范围太小，所以不推荐使用第二种方式</p><h2 id="7、类作为模板的参数"><a href="#7、类作为模板的参数" class="headerlink" title="7、类作为模板的参数"></a>7、类作为模板的参数</h2><p>最基本情况</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CAA</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> a;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Y&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CFather</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">CFather</span>(CAA&amp; ca) &#123;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;CFather&quot;</span> &lt;&lt; std::endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>CAA ca;<br><span class="hljs-function">CFather&lt;<span class="hljs-type">int</span>, CAA&gt; <span class="hljs-title">pf</span><span class="hljs-params">(ca)</span></span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当我们的类也是一个模板类时</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> K&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CAA</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> a;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Y&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CFather</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">CFather</span>(CAA&lt;<span class="hljs-type">char</span>&gt;&amp; ca) &#123;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;CFather&quot;</span> &lt;&lt; std::endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>CAA&lt;<span class="hljs-type">char</span>&gt; ca;<br>CFather&lt;<span class="hljs-type">int</span>, CAA&lt;<span class="hljs-type">char</span>&gt;&gt; <span class="hljs-built_in">pf</span>(ca);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从C开始的CPP学习生活06-类型转换</title>
    <link href="/2022/10/26/cppnote06/"/>
    <url>/2022/10/26/cppnote06/</url>
    
    <content type="html"><![CDATA[<h2 id="1、旧式类型转换"><a href="#1、旧式类型转换" class="headerlink" title="1、旧式类型转换"></a>1、旧式类型转换</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(type)value;<br><span class="hljs-built_in">type</span>(value); <span class="hljs-comment">//C++特有</span><br></code></pre></td></tr></table></figure><h2 id="2、新式类型转换"><a href="#2、新式类型转换" class="headerlink" title="2、新式类型转换"></a>2、新式类型转换</h2><p>新式类型转换针对不同的场景使用不同的转换方式，相较于就是转换的有点是安全</p><ul><li>static_cast</li><li>const_cast</li><li>dynamic_cast</li><li>reinterpret_cast</li></ul><h3 id="2-1、static-cast"><a href="#2-1、static-cast" class="headerlink" title="2.1、static_cast"></a>2.1、static_cast</h3><p>static_cast明确告知编译器我们要进行类型转化，</p><p>可以使用static_cast进行转化的类型主要有三种</p><ul><li>浮点型转换成整型</li><li>枚举型转换成整型</li><li>父类转换成子类</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">double</span> a = <span class="hljs-number">1.1</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(a);<br><span class="hljs-comment">//这里可以直接写</span><br><span class="hljs-type">int</span> b = a;<span class="hljs-comment">//但是这种写法编译器会报出warning，使用static_cast就是告知编译器我知道可能会出现精度缺失，你不用担心</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">Color</span> &#123;red = <span class="hljs-number">0</span>, blue&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> r = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(Color::blue);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CFather</span> &#123;&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CSon</span> : <span class="hljs-keyword">public</span> CFather<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> b;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>CFather* p = <span class="hljs-keyword">new</span> CFather;<br>CSon* s = <span class="hljs-built_in">static_cast</span>&lt;CSon*&gt;(p);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然使用static_cast将父类指针转换成子类指针是可以实现的，但是这种方法并不安全，如我们可以访问s-&gt;b;但实际的情况是s-&gt;b是一块不属于该指针的内存，这属于非法访问，所以不推荐使用这种类型转换，而是推荐使用dynamic_cast</p><h4 id="2-1-1、static-cast不能转换两个没有关系的类"><a href="#2-1-1、static-cast不能转换两个没有关系的类" class="headerlink" title="2.1.1、static_cast不能转换两个没有关系的类"></a>2.1.1、static_cast不能转换两个没有关系的类</h4><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">class C &#123;&#125;<span class="hljs-comment">;</span><br><br>C* c <span class="hljs-operator">=</span> static_cast&lt;C*&gt;(p)<span class="hljs-comment">;//ERROR</span><br></code></pre></td></tr></table></figure><h4 id="2-1-2、static-cast不能将const类型的值转换成非const类型的，但是C风格的旧式转换可以"><a href="#2-1-2、static-cast不能将const类型的值转换成非const类型的，但是C风格的旧式转换可以" class="headerlink" title="2.1.2、static_cast不能将const类型的值转换成非const类型的，但是C风格的旧式转换可以"></a>2.1.2、static_cast不能将const类型的值转换成非const类型的，但是C风格的旧式转换可以</h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>* a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">int</span> *r = static_cast&lt;<span class="hljs-keyword">int</span>*&gt;(a);<span class="hljs-comment">//ERROR</span><br><span class="hljs-keyword">int</span> *r = (<span class="hljs-keyword">int</span>*)a;<br></code></pre></td></tr></table></figure><h3 id="2-2、dynamic-cast"><a href="#2-2、dynamic-cast" class="headerlink" title="2.2、dynamic_cast"></a>2.2、dynamic_cast</h3><p>dynamic_cast多用于有继承关系的多态类（基类里面含有虚函数）的指针或引用之间的转换。</p><p>dynamic_cast运算符能够将基类的指针或引用安全的转换为派生类的指针或者引用。转换失败，返回空地址。</p><p>RTTI(Runtime Type Identification)，程序在运行阶段确定对象的类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">A</span>() &#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span> : A &#123;&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">C</span> &#123;&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>A* a = <span class="hljs-keyword">new</span> B;<br>B* b = <span class="hljs-built_in">dynamic_cast</span>&lt;B*&gt;(a);<br>    <span class="hljs-keyword">delete</span> a;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述的转换是安全的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">A* a = <span class="hljs-keyword">new</span> A;<br>B* b = <span class="hljs-built_in">dynamic_cast</span>&lt;B*&gt;(a);<span class="hljs-comment">//b -&gt; null</span><br></code></pre></td></tr></table></figure><p>这种转换dynamic_cast并不支持，因为仍有可能访问到非法内存，所以会返回一个null</p><h3 id="2-3、const-cast"><a href="#2-3、const-cast" class="headerlink" title="2.3、const_cast"></a>2.3、const_cast</h3><p>const_cast主要用来去除符合类型中的const和volatile属性</p><p>由于变量本身的const属性是不能去除的，要想修改变量的值，只能先去除变量的const属性，然后再进行修改</p><p>const_cast就是负责将对象的类型由const type变为type</p><p>注意：源类型和目标类型除了const不同外，其他地方完全相同</p><h3 id="2-4、reinterpret-cast"><a href="#2-4、reinterpret-cast" class="headerlink" title="2.4、reinterpret_cast"></a>2.4、reinterpret_cast</h3><p>reinterpret_cast用于各种类型的转换，即reinterpret_cast允许将任意指针转换到其他指针类型，也允许做任意整数类型和任意指针类型之间的转换。</p><p>reinterpret_cast转换是不安全的，程序的安全性需要程序员自己来保证。</p>]]></content>
    
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从C开始的CPP学习生活05-内部类</title>
    <link href="/2022/10/26/cppnote05/"/>
    <url>/2022/10/26/cppnote05/</url>
    
    <content type="html"><![CDATA[<h2 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h2><p>如果一个类定义在另一个类的内部，这个类就叫做内部类；</p><p>内部类虽然定义在外部类中，但并不属于外部类，外部类对内部类没有任何优越的访问权限；</p><p>内部类相当于外部类的友元类+内部类可以直接访问外部类中的static、枚举成员</p><p>注意：友元类的定义是内部类可以通过外部类的<strong>对象</strong>来访问外部类的所有成员</p><h2 id="2、使用"><a href="#2、使用" class="headerlink" title="2、使用"></a>2、使用</h2><p>所以观察以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">OUT</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> a;<br><span class="hljs-built_in">OUT</span>() : <span class="hljs-built_in">a</span>(<span class="hljs-number">12</span>) &#123;&#125;;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">IN</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> b;<br><span class="hljs-built_in">IN</span>() : <span class="hljs-built_in">b</span>(<span class="hljs-number">13</span>) &#123;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">funIN</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; a &lt;&lt; std::endl; <span class="hljs-comment">//ERROR</span><br>&#125;<br>&#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们用OUT表示外部类，IN 表示内部类，此时内部类的funIN函数想要访问外部类的成员a，显然是错误的</p><p>此时要么将a定义成static类型，要么采用下面的方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">OUT</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> a;<br><span class="hljs-built_in">OUT</span>() : <span class="hljs-built_in">a</span>(<span class="hljs-number">12</span>) &#123;&#125;;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">IN</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> b;<br><span class="hljs-built_in">IN</span>() : <span class="hljs-built_in">b</span>(<span class="hljs-number">13</span>) &#123;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">funIN</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>OUT out1;<br>std::cout &lt;&lt; out1.a &lt;&lt; std::endl;<br>&#125;<br>&#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="3、注意事项"><a href="#3、注意事项" class="headerlink" title="3、注意事项"></a>3、注意事项</h2><ul><li>由于内部类不属于外部类，所以sizeof(外部类)&#x3D;外部类的大小</li><li>内部类定义在外部类的public，protected和private中都可以</li><li>可以通过 外部类::内部类的方法定义内部类的对象</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">OUT::IN in;<br>in.<span class="hljs-built_in">funIN</span>();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从C开始的CPP学习生活04-多态与虚函数</title>
    <link href="/2022/10/26/cppnote04/"/>
    <url>/2022/10/26/cppnote04/</url>
    
    <content type="html"><![CDATA[<p>多态是一种泛型编程思想，虚函数是实现这个思想的语法基础，即父类的指针调用子类的函数</p><h2 id="1、虚函数"><a href="#1、虚函数" class="headerlink" title="1、虚函数"></a>1、虚函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CFather</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;class Father&quot;</span> &lt;&lt; std::endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CSon</span> : <span class="hljs-keyword">public</span> CFather<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> aa;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;class CSon&quot;</span> &lt;&lt; std::endl;<br>&#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>CFather* fa = <span class="hljs-keyword">new</span> CSon;<br>fa-&gt;<span class="hljs-built_in">show</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码运行结果是打印<code>class CSon</code></p><p>这就是虚函数的作用，可以让父类指针调用子类的函数，原因就是父类函数声明是virtual，而子类对这一函数实现了重写</p><ul><li>形式： virtual void fun()</li><li>子类的函数要和父类函数名称相同</li><li>多个子类，换子类就调用相应子类的函数 CFather* fa &#x3D; new <strong>CSon</strong>;如果把CSon更换为另一个子类，另一个子类也重写了show函数，则会调用另一个子类的show函数</li><li>多态指针对指针对象</li><li>重写针对虚函数，覆盖针对普通函数</li></ul><h2 id="2、虚函数的特点"><a href="#2、虚函数的特点" class="headerlink" title="2、虚函数的特点"></a>2、虚函数的特点</h2><ul><li>子类重写的函数，默认是虚函数，可以显示的加virtual，也可以不加</li><li>返回值和函数体的内容必须完全相同才能构成重载</li><li>但是存在一种特殊情况，即子类的函数是父类函数的<strong>协变</strong>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CFather</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> CFather&amp; <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;class Father&quot;</span> &lt;&lt; std::endl;<br><span class="hljs-keyword">return</span> (*<span class="hljs-keyword">this</span>);<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CSon</span> : <span class="hljs-keyword">public</span> CFather<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> aa;<br><span class="hljs-function">CSon&amp; <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;class CSon&quot;</span> &lt;&lt; std::endl;<br><span class="hljs-keyword">return</span> (*<span class="hljs-keyword">this</span>);<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>虚函数不能是内联函数，但并不是编译出错，而是编译过后内联无效<ul><li>虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联</li><li>内联是在编译期建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时不可以内联</li><li>只有在编译器知道所调用的对象时哪个类的时候才能进行内联</li></ul></li><li>构造函数不能是虚函数，内联是构造函数唯一的合法存储类</li></ul><h2 id="3、虚表"><a href="#3、虚表" class="headerlink" title="3、虚表"></a>3、虚表</h2><p>多态与虚函数的实现原理</p><p>每个包含了虚函数的类都包含一个虚表</p><p>当一个类A继承另一个类B时，A同样会继承类B的虚表，但不是使用类B的虚表，而是复制了一份；</p><p>若A未重写B的虚函数，则A类的对象调用该函数时访问的是继承自B的虚表，所以调用的是B的函数，而当A重写了B的虚函数之后，A的虚表内容被替换成A所重写的函数地址，所以A类对象调用该函数的时候自然使用的是A类的函数；</p><h3 id="3-1、虚表指针"><a href="#3-1、虚表指针" class="headerlink" title="3.1、虚表指针"></a>3.1、虚表指针</h3><p>虚表是一个指针数组，其元素是虚函数的函数指针，也就是存储着虚函数的地址；</p><p>普通的函数不是虚函数，调用的时候不需要经过虚表；</p><p>虚表在程序编译阶段就可以构造出来；</p><p>当然，虚表不是只能有一个，一个类如果继承了多个存在虚函数的类，则会存在多个虚表，每个虚表对应一个父类；</p><p>为了指定虚表的对象，编译器会给类添加一个<code>*__vptr</code>指针，用来指向虚表；</p><h3 id="3-2、虚表存放位置"><a href="#3-2、虚表存放位置" class="headerlink" title="3.2、虚表存放位置"></a>3.2、虚表存放位置</h3><p>c&#x2F;c++程序所占用内存一共分为五种</p><p>栈区、堆区、程序代码区、全局数据区、文字常量区</p><p>虚表存储在全局数据区</p><h3 id="3-3、upcasting"><a href="#3-3、upcasting" class="headerlink" title="3.3、upcasting"></a>3.3、upcasting</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">CFather* fa = <span class="hljs-keyword">new</span> CSon;<br></code></pre></td></tr></table></figure><p>CSon类继承自CFather，上面这段代码地址空间是CSon类型的，我们使用父类指针指向这段地址，则父类指针会用父类指针的解释方式看待这段内存。但同时，父类指针获得的<code>v__ptr</code>是指向子类CSon的虚表的，所以我们在调用虚函数的时候，会调用子类的虚函数</p><p>这里面涉及upcasting的问题，即把子类对象当作父类来看待</p><h3 id="3-4、找到虚表的地址"><a href="#3-4、找到虚表的地址" class="headerlink" title="3.4、找到虚表的地址"></a>3.4、找到虚表的地址</h3><p>虚表指针在对象内存的首4个字节，虚表里面每4个字节存储一个函数指针，最后4字节存储0x0</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CFather</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span> </span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;fun&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;class Father&quot;</span> &lt;&lt; std::endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CSon</span> : <span class="hljs-keyword">public</span> CFather<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> aa;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;class CSon&quot;</span> &lt;&lt; std::endl;<br>&#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>CFather* fa = <span class="hljs-keyword">new</span> CSon;<br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span><span class="hljs-params">(*p)</span><span class="hljs-params">()</span></span>;<br>((p)(*((<span class="hljs-type">int</span>*)(*(<span class="hljs-type">int</span>*)fa) + <span class="hljs-number">0</span>)))();<br>((p)(*((<span class="hljs-type">int</span>*)(*(<span class="hljs-type">int</span>*)fa) + <span class="hljs-number">1</span>)))();<br>std::cout &lt;&lt; *((<span class="hljs-type">int</span>*)(*(<span class="hljs-type">int</span>*)fa) + <span class="hljs-number">2</span>) &lt;&lt; std::endl;<br>    <span class="hljs-keyword">delete</span> fa;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码分别打印 fun  class CSon 以及 0</p><h2 id="4、虚析构"><a href="#4、虚析构" class="headerlink" title="4、虚析构"></a>4、虚析构</h2><p>正常情况下，使用父类的指针指向子类的对象，在进行析构时调用的是父类的析构函数</p><p>如果父类的析构函数的虚析构，则子类的函数默认也是虚析构</p><p>在进行析构时会先调用子类的析构函数，然后调用父类的析构函数</p><p>delete指向哪种类型的指针，就调用哪种类型的析构函数。</p><h2 id="5、纯虚函数"><a href="#5、纯虚函数" class="headerlink" title="5、纯虚函数"></a>5、纯虚函数</h2><p>形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>特点：</p><ul><li>没有函数实现</li><li>无法进行对象声明，即有纯虚函数的类不能实例化对象</li><li>相实现对象需要使用子类继承该类，并且子类要实现纯虚函数</li></ul><p>抽象类：有纯虚函数的类</p><p>接口类：只有纯虚函数的类，可以有成员，可以有构造函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CFather</span><br>&#123;<br><span class="hljs-type">int</span> a;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">gnu</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">CFather</span>() = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">CFather</span>();<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="6、虚继承"><a href="#6、虚继承" class="headerlink" title="6、虚继承"></a>6、虚继承</h2><p>有这样一个问题 类B继承类A，类C继承类A，然后类D继承类A和类B，这会发生什么问题？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A&#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> : <span class="hljs-keyword">public</span> A&#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span> : <span class="hljs-keyword">public</span> B, <span class="hljs-keyword">public</span> C&#123;&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>D d;<br>d.a;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时编译会出现问题：<code>&quot;D::a&quot; is ambiguous</code>  <code>ambiguous access of &#39;a&#39;</code></p><p>注意，使用命名空间的访问方法时，只能使用d.B::a以及d.C::a，无法使用d.A::a</p><p>解决此类问题的方法是使用虚继承</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> A&#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> A&#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span> : <span class="hljs-keyword">public</span> B, <span class="hljs-keyword">public</span> C&#123;&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>D d;<br>d.a;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>解决了多继承中访问不明确的问题</p><p>不建议用，结构复杂，内存开销比较大</p><h2 id="7、联编"><a href="#7、联编" class="headerlink" title="7、联编"></a>7、联编</h2><p>将模块或者函数合并在一起生成可执行代码的处理过程</p><p>按照联编所进行的阶段不同，可分为两种不同的联编方法：静态联编和动态联编</p><p>对于非虚的方法，编译器使用静态联编</p><p>对于含有虚函数的类，由于需要到运行阶段才能知道具体要调用哪个函数，所以编译器要使用动态联编</p><h2 id="8、单例模式"><a href="#8、单例模式" class="headerlink" title="8、单例模式"></a>8、单例模式</h2><p>思想：一个类只能创造一个对象</p><ul><li>构造函数：private&#x2F;protected</li><li>通过静态成员函数申请对象空间，并返回地址</li><li>定义一个静态标记，记录对象个数，并控制</li><li>析构函数，将标记清空，以达到重复申请对象的目的</li><li>该类可以被继承，但是继承后的类无法实例化对象（因为实例化对象需要调用父类的构造函数）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CFather</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-built_in">CFather</span>()<br>&#123;<br><br>&#125;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> flag;<br><span class="hljs-function"><span class="hljs-type">static</span> CFather* <span class="hljs-title">CreateOJ</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (flag == <span class="hljs-number">0</span>) &#123;<br>flag = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> (<span class="hljs-keyword">new</span> CFather);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br>&#125;<br>    <br>    ~<span class="hljs-built_in">CFather</span>() &#123;<br>flag = <span class="hljs-number">0</span>;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从C开始的CPP学习生活03-继承</title>
    <link href="/2022/10/26/cppnote03/"/>
    <url>/2022/10/26/cppnote03/</url>
    
    <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CPeople</span> <span class="hljs-comment">//基类（父类）</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Study</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Study&quot;</span> &lt;&lt; std::endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CChild</span> : <span class="hljs-keyword">public</span> CPeople <span class="hljs-comment">//派生类（子类）</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GoToSchool</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;GoToSchool&quot;</span> &lt;&lt; std::endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CMan</span> : <span class="hljs-keyword">public</span> CPeople<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GoToWork</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;GoToWork&quot;</span> &lt;&lt; std::endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">COld</span> : <span class="hljs-keyword">public</span> CPeople<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GOToPlay</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;GOToPlay&quot;</span> &lt;&lt; std::endl;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="1、继承限定词"><a href="#1、继承限定词" class="headerlink" title="1、继承限定词"></a>1、继承限定词</h2><p>父类成员是哪种修饰符，子类成员就是哪种修饰符</p><p>我们以下面的<code>CPeople</code>类为例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CPeople</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;father public&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-keyword">protected</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;father protected&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun3</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;father private&quot;</span> &lt;&lt; std::endl;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>首先，public修饰符:指子类继承父类时使用的<code>: public CPeople</code>中的public</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cxiaoming</span> : <span class="hljs-keyword">public</span> CPeople<br>&#123;<br><br>&#125;;<br></code></pre></td></tr></table></figure><p>使用public修饰符继承，父类的成员是什么修饰符，子类的成员就是什么修饰符，<strong>子类可以使用父类的public成员</strong></p><p>然后，protected修饰符，继承之后，父类的public降级称protected，父类中的protected和private不变，子类不可以使用父类的成员</p><p>最后，private修饰符，继承之后，父类成员的所有成员和变量变为private，子类不可用</p><p>注意：</p><ul><li>继承是指子类继承父类，不管继承的修饰符是什么，父类中的修饰符不会改变，而是父类中的方法被子类继承之后在子类中相对于父类而发生的改变</li><li>protected修饰符在子类内部可以使用，但是子类的对象无法直接调用prootected修饰符下面的方法</li></ul><h2 id="2、构造函数的继承"><a href="#2、构造函数的继承" class="headerlink" title="2、构造函数的继承"></a>2、构造函数的继承</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CPeople</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">CPeople</span>()<br>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;CPeople&quot;</span> &lt;&lt; std::endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cxiaoming</span> : <span class="hljs-keyword">public</span> CPeople<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Cxiaoming</span>()<br>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Cxiaoming&quot;</span> &lt;&lt; std::endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Cxiaoming xiaoming;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码执行之后，首先打印CPeople，然后打印Cxiaoming</p><p>构造函数的继承，首先调用父类的构造函数，然后调用子类的构造函数</p><h2 id="3、有参构造函数的继承"><a href="#3、有参构造函数的继承" class="headerlink" title="3、有参构造函数的继承"></a>3、有参构造函数的继承</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CFather</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">CFather</span>(<span class="hljs-type">int</span> a)<br>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;father class&quot;</span> &lt;&lt; std::endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CSon</span> : <span class="hljs-keyword">public</span> CFather<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">CSon</span>() : <span class="hljs-built_in">CFather</span>(<span class="hljs-number">1</span>)<br>&#123;<br><br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>前面提到过，创建子类的对象之前需要先调用父类的构造函数</p><p>父类的构造函数如果有参数，则需要子类在构造函数的初始化列表中对父类进行初始化</p><h2 id="4、析构函数的继承"><a href="#4、析构函数的继承" class="headerlink" title="4、析构函数的继承"></a>4、析构函数的继承</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CFather</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>~<span class="hljs-built_in">CFather</span>()<br>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;father class&quot;</span> &lt;&lt; std::endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CSon</span> : <span class="hljs-keyword">public</span> CFather<br>&#123;<br><span class="hljs-keyword">public</span>:<br>~<span class="hljs-built_in">CSon</span>()<br>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;CSon class&quot;</span> &lt;&lt; std::endl;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>析构函数的调用过程是先调用子类的析构函数，然后调用父类的析构函数</p><p>一个对象的声明周期过程中，构造函数与析构函数调用过程为：</p><p>父类构造函数 -&gt; 子类构造函数 -&gt;子类析构函数 -&gt; 父类析构函数</p><h2 id="5、覆盖"><a href="#5、覆盖" class="headerlink" title="5、覆盖"></a>5、覆盖</h2><p>当父类和子类中出现同名的成员时，C++采用覆盖的处理方式</p><h4 id="5-1、数据成员同名"><a href="#5-1、数据成员同名" class="headerlink" title="5.1、数据成员同名"></a>5.1、数据成员同名</h4><p>类内：子类覆盖父类，使用时可以通过类名作用域区分</p><p>类外：使用类名作用域区分</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CFather</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> a;<br><span class="hljs-built_in">CFather</span>()<br>&#123;<br>a = <span class="hljs-number">12</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CSon</span> : <span class="hljs-keyword">public</span> CFather<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> a;<br><span class="hljs-built_in">CSon</span>()<br>&#123;<br>a = <span class="hljs-number">10</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; CFather::a &lt;&lt; <span class="hljs-string">&quot; &quot;</span>&lt;&lt; a &lt;&lt; std::endl;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>类外</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">CSon so;<br>so.a;<br>so.CFather::a;<br></code></pre></td></tr></table></figure><h4 id="5-2、父类子类函数名相同"><a href="#5-2、父类子类函数名相同" class="headerlink" title="5.2、父类子类函数名相同"></a>5.2、父类子类函数名相同</h4><p>子类覆盖父类，使用时可以通过类名作用域区分</p><p>父类子类的函数没有重载关系</p><p><strong>友元不能被继承</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从C开始的CPP学习生活02-operator</title>
    <link href="/2022/10/26/cppnote02/"/>
    <url>/2022/10/26/cppnote02/</url>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/qq_40660998/article/details/124325522">C++运算符</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CStu</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> nAge;<br><span class="hljs-type">double</span> dScore;<br><br><span class="hljs-built_in">CStu</span>()<br>&#123;<br>nAge = <span class="hljs-number">12</span>;<br>dScore = <span class="hljs-number">16.23</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>+(CStu&amp; st, <span class="hljs-type">int</span> a)<br>&#123;<br>std::cout &lt;&lt; (st.nAge + a) &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>CStu st1, st2;<br>st1 + <span class="hljs-number">12</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>通常情况下我们只能对一些基本数据类型，比如int,float.double等进行加减乘除，那么我们是否可以对对象进行加减乘除呢？</p><p>答案是不可以，我们在main中直接使用st1 + 12;编译器会报错</p><p>但并不是完全不可用，c++中存在一种叫做运算符重载的方式，可以让我们自己设定运算符的操作数的类型，这样我们就可以让类的对象进行加减乘除了</p><h2 id="1、有返回值的运算符重载"><a href="#1、有返回值的运算符重载" class="headerlink" title="1、有返回值的运算符重载"></a>1、有返回值的运算符重载</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> <span class="hljs-keyword">operator</span>+(CStu&amp; st, <span class="hljs-type">int</span> a) &#123;<br><span class="hljs-keyword">return</span> st.nAge + a;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时不可以使用<code>12+stu1;</code></p><p>原因是运算符找不到对应类型的操作数</p><p>此时我们可以再增加一个运算符重载函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> <span class="hljs-keyword">operator</span>+(<span class="hljs-type">int</span> a， CStu&amp; st) &#123;<br><span class="hljs-keyword">return</span> st.nAge + a;<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以两个类之间进行运算</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> <span class="hljs-keyword">operator</span>+(CStu&amp; st1, CStu&amp; st2) &#123;<br><span class="hljs-keyword">return</span> st1.nAge + st2.nAge;<br>&#125;<br></code></pre></td></tr></table></figure><p>返回值的类型也可以改变</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">CStu&amp; <span class="hljs-keyword">operator</span>+(CStu&amp; st1, CStu&amp; st2) &#123;<br>st1.nAge += st2.nAge;<br><span class="hljs-keyword">return</span> st1;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2、类内重载"><a href="#2、类内重载" class="headerlink" title="2、类内重载"></a>2、类内重载</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CStu</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> nAge;<br><br><span class="hljs-built_in">CStu</span>()<br>&#123;<br>nAge = <span class="hljs-number">12</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-keyword">operator</span>+(<span class="hljs-type">int</span> a)<br>&#123;<br><span class="hljs-keyword">return</span> (nAge + a);<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>CStu stu;<br>std::cout &lt;&lt; stu + <span class="hljs-number">12</span> &lt;&lt; std::endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，写在类内的重载在调用时和写在类外的重载是相同的。</p><p>由于类内的函数默认第一个参数是this指针，所以我们在实现运算符重载的时候可以少写入一个参数，并且，类内运算符重载只能写入一个参数，如果想要使用<code>12 + stu;</code>，我们需要类外实现</p><h2 id="3、运算符重载定义在类内还是类外"><a href="#3、运算符重载定义在类内还是类外" class="headerlink" title="3、运算符重载定义在类内还是类外"></a>3、运算符重载定义在类内还是类外</h2><ul><li>左操作数不是对象的，就选择类外重载运算符</li><li>&#x3D;，[]，()，-&gt;必须是类内重载</li><li>符合复制运算符通常是类内重载  +&#x3D;、&lt;&lt;&#x3D;</li><li>改变对象状态的运算符，如++ –等，通常是类内重载</li><li>算数，关系，位运算通常是类外重载</li></ul><h2 id="4、运算符重载的例子"><a href="#4、运算符重载的例子" class="headerlink" title="4、运算符重载的例子"></a>4、运算符重载的例子</h2><h3 id="4-1、二元运算符重载"><a href="#4-1、二元运算符重载" class="headerlink" title="4.1、二元运算符重载"></a>4.1、二元运算符重载</h3><p>二元运算符：</p><ul><li>算术运算符：+ - * &#x2F; %</li><li>关系运算符：&gt;&#x3D;   &lt;&#x3D;  &gt;  &lt;  !&#x3D;  &#x3D;&#x3D;</li><li>位运算符：^   &amp;  |</li><li>逻辑运算符： &amp;&amp;   ||</li></ul><p><strong>&gt;&#x3D;</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> <span class="hljs-keyword">operator</span> &gt;= (CStu&amp; st1, CStu&amp; st2) &#123;<br><span class="hljs-built_in">return</span> (st1.nAge &gt;= st2.nAge);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>&amp;&amp;</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> <span class="hljs-keyword">operator</span> &amp;&amp; (CStu&amp; st1, CStu&amp; st2) &#123;<br><span class="hljs-keyword">return</span> (st1.nAge &amp;&amp; st2.nAge);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2、一元运算符"><a href="#4-2、一元运算符" class="headerlink" title="4.2、一元运算符"></a>4.2、一元运算符</h3><p>一元运算符： -  + &amp; * ~ ! （正 负 取地址 内存操作 按位取反 非）</p><p><strong>-</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> <span class="hljs-keyword">operator</span>-(CStu&amp; st) &#123;<br><span class="hljs-keyword">return</span> -st.nAge;<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以写在类内</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CStu</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> nAge;<br><br><span class="hljs-built_in">CStu</span>(<span class="hljs-type">int</span> a)<br>&#123;<br>nAge = a;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-keyword">operator</span>-() &#123;<br><span class="hljs-keyword">return</span> (-<span class="hljs-keyword">this</span>-&gt;nAge);<br>&#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h3 id="4-3、输入输出"><a href="#4-3、输入输出" class="headerlink" title="4.3、输入输出"></a>4.3、输入输出</h3><p>cout是ostream的对象，cin是istream的对象</p><h4 id="4-3-1、ostream"><a href="#4-3-1、ostream" class="headerlink" title="4.3.1、ostream"></a>4.3.1、ostream</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CStu</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> nAge;<br><br><span class="hljs-built_in">CStu</span>()<br>&#123;<br>nAge = <span class="hljs-number">12</span>;<br>&#125;<br>&#125;;<br><br>std::ostream&amp; <span class="hljs-keyword">operator</span> &lt;&lt; (std::ostream&amp; os, <span class="hljs-type">const</span> CStu&amp; st) &#123;<br>os &lt;&lt; st.nAge;<br>    <span class="hljs-keyword">return</span> os;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>CStu st;<br>std::cout &lt;&lt; st &lt;&lt; st;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>参数一是ostream的引用，参数2是常引用</p><p>必须是类外重载</p><p>一般情况下要输出的变量是私有成员，此时可以使用友元</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CStu</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> nAge;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">CStu</span>()<br>&#123;<br>nAge = <span class="hljs-number">12</span>;<br>&#125;<br><br><span class="hljs-keyword">friend</span> std::ostream&amp; <span class="hljs-keyword">operator</span> &lt;&lt; (std::ostream&amp; os, <span class="hljs-type">const</span> CStu&amp; st);<br>&#125;;<br><br>std::ostream&amp; <span class="hljs-keyword">operator</span> &lt;&lt; (std::ostream&amp; os, <span class="hljs-type">const</span> CStu&amp; st) &#123;<br>os &lt;&lt; st.nAge;<br><span class="hljs-keyword">return</span> os;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>CStu st;<br>std::cout &lt;&lt; st &lt;&lt; st;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-3-2、istream"><a href="#4-3-2、istream" class="headerlink" title="4.3.2、istream"></a>4.3.2、istream</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CStu</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> nAge;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">CStu</span>()<br>&#123;<br>nAge = <span class="hljs-number">13</span>;<br>&#125;<br><br><span class="hljs-keyword">friend</span> std::istream&amp; <span class="hljs-keyword">operator</span> &gt;&gt; (std::istream&amp; is, CStu&amp; stu);<br><span class="hljs-keyword">friend</span> std::ostream&amp; <span class="hljs-keyword">operator</span> &lt;&lt; (std::ostream&amp; os, <span class="hljs-type">const</span> CStu&amp; st);<br>&#125;;<br><br>std::istream&amp; <span class="hljs-keyword">operator</span> &gt;&gt; (std::istream&amp; is, CStu&amp; stu)<br>&#123;<br>is &gt;&gt; stu.nAge;<br><span class="hljs-keyword">return</span> is;<br>&#125;<br><br>std::ostream&amp; <span class="hljs-keyword">operator</span> &lt;&lt; (std::ostream&amp; os, <span class="hljs-type">const</span> CStu&amp; st) &#123;<br>os &lt;&lt; st.nAge;<br><span class="hljs-keyword">return</span> os;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>CStu st;<br>std::cin &gt;&gt; st;<br>std::cout &lt;&lt; st;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-3-3、赋值运算符"><a href="#4-3-3、赋值运算符" class="headerlink" title="4.3.3、赋值运算符"></a>4.3.3、赋值运算符</h4><p>&#x3D;  -&#x3D;  +&#x3D;  *&#x3D;  &#x2F;&#x3D;</p><p>前面提到过，**&#x3D;**必须是类内重载</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CStu</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> nAge;<br><span class="hljs-built_in">CStu</span>() &#123;<br>nAge = <span class="hljs-number">16</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> = (<span class="hljs-type">int</span> a)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;nAge = a;<br>&#125;<br><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>CStu st;<br>st = <span class="hljs-number">113</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>+&#x3D;</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp">CStu&amp; <span class="hljs-keyword">operator</span> += (CStu&amp; st, <span class="hljs-type">int</span> a)<br>&#123;<br>st.nAge += a;<br><span class="hljs-keyword">return</span> st;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>CStu st;<br>st += <span class="hljs-number">113</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-3-4、下标运算"><a href="#4-3-4、下标运算" class="headerlink" title="4.3.4、下标运算"></a>4.3.4、下标运算</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CStu</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> a, b, c, d;<br><span class="hljs-built_in">CStu</span>()<br>&#123;<br>a = b = c = d = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">int</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> n)<br>&#123;<br><span class="hljs-keyword">switch</span> (n) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> a; <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> b; <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: <span class="hljs-keyword">return</span> c; <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>: <span class="hljs-keyword">return</span> d;<br>&#125;<br>&#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>CStu st;<br>std::cout &lt;&lt; st[<span class="hljs-number">1</span>] &lt;&lt; std::endl;<br>st[<span class="hljs-number">1</span>] = <span class="hljs-number">18</span>;<br>std::cout &lt;&lt; st[<span class="hljs-number">1</span>];<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-3-5、自增自减运算符"><a href="#4-3-5、自增自减运算符" class="headerlink" title="4.3.5、自增自减运算符"></a>4.3.5、自增自减运算符</h4><p>左++</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> <span class="hljs-keyword">operator</span> ++ (CStu&amp; st) &#123;<br><span class="hljs-keyword">return</span> ++st.nAge;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CStu</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> nAge;<br><br><span class="hljs-built_in">CStu</span>()<br>&#123;<br>nAge = <span class="hljs-number">12</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-keyword">operator</span> ++ () &#123;<br><span class="hljs-keyword">return</span> ++nAge;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>右++</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> <span class="hljs-keyword">operator</span> ++ (CStu&amp; st, <span class="hljs-type">int</span> n)<br>&#123;<br>n = st.nAge++;<br><span class="hljs-keyword">return</span> n;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CStu</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> nAge;<br><br><span class="hljs-built_in">CStu</span>()<br>&#123;<br>nAge = <span class="hljs-number">12</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-keyword">operator</span> ++ (<span class="hljs-type">int</span> n)<br>&#123;<br>n = nAge++;<br><span class="hljs-keyword">return</span> n;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="4-3-6、重载类型转换"><a href="#4-3-6、重载类型转换" class="headerlink" title="4.3.6、重载类型转换"></a>4.3.6、重载类型转换</h4><p>只能定义在类内</p><p>不能对类成员进行修改</p><p>没有返回类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">int</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">double</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> b;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>CStu st;<br>std::cout &lt;&lt; (<span class="hljs-type">int</span>)st &lt;&lt; std::endl;<br>std::cout &lt;&lt; (<span class="hljs-type">double</span>)st &lt;&lt; std::endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从C开始的CPP学习生活01-基础内容</title>
    <link href="/2022/10/26/cppnote01/"/>
    <url>/2022/10/26/cppnote01/</url>
    
    <content type="html"><![CDATA[<h2 id="0、写在前面"><a href="#0、写在前面" class="headerlink" title="0、写在前面"></a>0、写在前面</h2><p>本笔记为学习cpp过程中记录的一些知识，并不全面，也并不一定完全正确</p><p>参考视频教程：<a href="https://www.bilibili.com/video/BV1rW411R7g4/?spm_id_from=333.999.0.0">bilibili</a></p><p>代码测试环境：win10 + vs2017</p><h2 id="1、换行"><a href="#1、换行" class="headerlink" title="1、换行"></a>1、换行</h2><p>endl换行并清空并刷新缓冲区</p><p>\n只进行换行</p><h2 id="2、newdelete和mallocfree的区别"><a href="#2、newdelete和mallocfree的区别" class="headerlink" title="2、newdelete和mallocfree的区别"></a>2、newdelete和mallocfree的区别</h2><p>new和delete会触发构造函数和析构函数</p><p>malloc和free不会</p><h2 id="3、引用"><a href="#3、引用" class="headerlink" title="3、引用"></a>3、引用</h2><h3 id="3-1、引用是给我们的变量起别名"><a href="#3-1、引用是给我们的变量起别名" class="headerlink" title="3.1、引用是给我们的变量起别名"></a>3.1、引用是给我们的变量起别名</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">12</span>;<br><span class="hljs-type">int</span> &amp;c = a;<span class="hljs-comment">//声明变量a的一个引用c</span><br><br>c = <span class="hljs-number">13</span>;<br>std::cout &lt;&lt; a &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure><p>打印13</p><p>注意：引用声明的时候一定要初始化int&amp; d;是非法的</p><p>​    一个变量可以有无数个引用</p><h3 id="3-2、常量的引用"><a href="#3-2、常量的引用" class="headerlink" title="3.2、常量的引用"></a>3.2、常量的引用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; a = <span class="hljs-number">12</span>;<br></code></pre></td></tr></table></figure><p>a不可修改，const是必须的</p><h3 id="3-3、数组的引用"><a href="#3-3、数组的引用" class="headerlink" title="3.3、数组的引用"></a>3.3、数组的引用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> arr[<span class="hljs-number">12</span>];<br><span class="hljs-built_in">int</span>(&amp;x)[<span class="hljs-number">12</span>] = arr;<span class="hljs-comment">//p的用法和arr相同</span><br><br><span class="hljs-type">int</span> arr2[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>];<br><span class="hljs-built_in">int</span>(&amp;p)[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] = arr2;<br></code></pre></td></tr></table></figure><h3 id="3-4、指针的引用"><a href="#3-4、指针的引用" class="headerlink" title="3.4、指针的引用"></a>3.4、指针的引用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> b = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> *point = &amp;b;<br><span class="hljs-type">int</span>* (&amp;q) = point;<br></code></pre></td></tr></table></figure><h3 id="3-5、引用做参数"><a href="#3-5、引用做参数" class="headerlink" title="3.5、引用做参数"></a>3.5、引用做参数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Exchange</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; a, <span class="hljs-type">int</span>&amp; b)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> nTemp = a;<br>a = b;<br>b = nTemp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">13</span>, b = <span class="hljs-number">15</span>;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;b:&quot;</span> &lt;&lt; b &lt;&lt; std::endl;<br><span class="hljs-built_in">Exchange</span>(a, b);<br>std::cout &lt;&lt; <span class="hljs-string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;b:&quot;</span> &lt;&lt; b &lt;&lt; std::endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-6、引用做返回值"><a href="#3-6、引用做返回值" class="headerlink" title="3.6、引用做返回值"></a>3.6、引用做返回值</h3><p>不要引用局部变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">fun</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">12</span>;<br><span class="hljs-keyword">return</span> a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span>&amp; b = <span class="hljs-built_in">fun</span>();<br>std::cout &lt;&lt; b &lt;&lt; std::endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>warning:warning C4172: returning address of local variable or temporary: a</code></p><p>操作非法内存的结果是未知的，所以不要这样使用</p><p>局部变量所占用的内存空间的分配和销毁取决于编译器的实现，编译器为了优化程序性能，可能有不同的策略来分配、释放内存</p><p>比如：VC编译器可能在函数入口处即分配这里的全部变量，GCC编译器也可能在定义出才分配变量</p><p>因此除了之哟用于的局部变量是不允许访问的，该空间可能暂时没有被释放，也可能被释放，所以不要访问这样的内存。</p><h3 id="3-7、引用与指针的区别"><a href="#3-7、引用与指针的区别" class="headerlink" title="3.7、引用与指针的区别"></a>3.7、引用与指针的区别</h3><ul><li>引用声明就要初始化，指针不用</li><li>引用初始化之后就不能指向其他空间了，指针可以</li><li>引用不占存储空间，指针占空间</li><li>引用效率更高，指针属于间接操作</li><li>引用更安全，指针可以偏移</li><li>指针更灵活，直接操作地址，指针更通用</li></ul><h2 id="4、参数缺省"><a href="#4、参数缺省" class="headerlink" title="4、参数缺省"></a>4、参数缺省</h2><h3 id="4-1、函数定义"><a href="#4-1、函数定义" class="headerlink" title="4.1、函数定义"></a>4.1、函数定义</h3><p>全部指定：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> a = <span class="hljs-number">12</span>, <span class="hljs-type">char</span> c = <span class="hljs-string">&#x27;v&#x27;</span>)</span> <span class="hljs-comment">//全部指定</span></span><br><span class="hljs-function"></span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>部分指定，部分指定必须从右向左连续指定，不能指定左侧的参数而右侧参数未指定</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">char</span> c, <span class="hljs-type">float</span> f = <span class="hljs-number">123.123f</span>)</span> </span><br><span class="hljs-function"></span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>不满足这条规则会报错：<br><code>Error (active)E0306default argument not at end of parameter list</code><br><code>ErrorC2548&#39;fun1&#39;: missing default parameter for parameter</code></p><h3 id="4-2、函数调用"><a href="#4-2、函数调用" class="headerlink" title="4.2、函数调用"></a>4.2、函数调用</h3><p>函数调用时，有默认值的参数，可以不用传递实参</p><p>没有指定默认值的，一定要传递实参</p><p>有默认值还传递实参，实参会覆盖掉默认值</p><h2 id="5、函数重载"><a href="#5、函数重载" class="headerlink" title="5、函数重载"></a>5、函数重载</h2><h3 id="5-1、定义"><a href="#5-1、定义" class="headerlink" title="5.1、定义"></a>5.1、定义</h3><p><strong>同一个作用域内，函数名字相同，参数列表不同（参数类型不同或者参数个数不同）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;fun1&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;fun2&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">char</span> a)</span> </span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;fun3&quot;</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>根据参数不同可以调用不同的函数</p><h3 id="5-2、二义性问题"><a href="#5-2、二义性问题" class="headerlink" title="5.2、二义性问题"></a>5.2、二义性问题</h3><p>但是，考虑到缺省值的问题，不合理的使用缺省值会导致重载函数产生二义性，比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;fun1&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b = <span class="hljs-number">12</span>)</span> </span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;fun2&quot;</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里面函数互为重载函数，但是再调用<code>fun(12)</code>是编译器会报错：<br><code>ErrorC2668&#39;fun&#39;: ambiguous call to overloaded function</code></p><p>所以在使用函数重载时要谨慎使用缺省值</p><h3 id="5-3、返回值问题"><a href="#5-3、返回值问题" class="headerlink" title="5.3、返回值问题"></a>5.3、返回值问题</h3><p>函数重载不包括返回值，因为C++是可以不考虑返回值的，void类型的数据也可以return 0;bool类型的数据也可以return 1;</p><h2 id="6、防止头文件重复包含"><a href="#6、防止头文件重复包含" class="headerlink" title="6、防止头文件重复包含"></a>6、防止头文件重复包含</h2><p>两种方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> AAA</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AAA</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>另一种方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br></code></pre></td></tr></table></figure><p>第二种方法能否使用取决于编译器，因此使用这种方法移植性特别差，所以不建议使用</p><h2 id="7、类"><a href="#7、类" class="headerlink" title="7、类"></a>7、类</h2><p>类是具有相同属性和行为的对象的集合</p><h3 id="7-1、类的声明"><a href="#7-1、类的声明" class="headerlink" title="7.1、类的声明"></a>7.1、类的声明</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CPeople</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> a;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;fun&quot;</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; a &lt;&lt; std::endl;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="7-3、声明对象及成员调用"><a href="#7-3、声明对象及成员调用" class="headerlink" title="7.3、声明对象及成员调用"></a>7.3、声明对象及成员调用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>CPeople op;<br>CPeople* op1 = <span class="hljs-keyword">new</span> CPeople;<br>op1-&gt;a = <span class="hljs-number">9</span>;<br>op1-&gt;<span class="hljs-built_in">fun</span>();<br>op.a = <span class="hljs-number">12</span>;<br>op.<span class="hljs-built_in">fun</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>类的所有成员(个别特殊的static)，必须通过对象访问。</strong></p><h3 id="7-4、访问修饰符"><a href="#7-4、访问修饰符" class="headerlink" title="7.4、访问修饰符"></a>7.4、访问修饰符</h3><p>作用范围：书写位置开始，一直到下一个修饰符，或者类结尾的花括号</p><h4 id="7-4-1、public"><a href="#7-4-1、public" class="headerlink" title="7.4.1、public"></a>7.4.1、public</h4><p>public修饰符对外可见，其他的类也可以访问</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CPeople</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> a;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; <span class="hljs-string">&quot;fun&quot;</span> &lt;&lt; std::endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CBird</span> &#123;<br><span class="hljs-keyword">public</span>:<br>CPeople p;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun2</span><span class="hljs-params">()</span> </span>&#123;<br>p.<span class="hljs-built_in">fun</span>();<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>C++结构体是特殊的类，访问修饰符默认是public</p><h4 id="7-4-2、private"><a href="#7-4-2、private" class="headerlink" title="7.4.2、private"></a>7.4.2、private</h4><p>类里面不注明修饰符默认是private修饰符</p><p>private是私有修饰符，其成员只有类内可以访问</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CPeople</span> &#123;<br><span class="hljs-type">int</span> a;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; <span class="hljs-string">&quot;fun&quot;</span> &lt;&lt; std::endl;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>a是私有成员，fun方法中可以调用</p><h4 id="7-4-3、protected"><a href="#7-4-3、protected" class="headerlink" title="7.4.3、protected"></a>7.4.3、protected</h4><p>protected修饰符修饰的成员对类内以及子类可见</p><h2 id="8、友元"><a href="#8、友元" class="headerlink" title="8、友元"></a>8、友元</h2><p>友元 类内成员对于这个函数&#x2F;类来说相当于public，protected修饰符也可以</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CStu</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> age;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>age = <span class="hljs-number">12</span>;<br>std::cout &lt;&lt; age &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CTeach</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CTeach</span> &#123;<br><span class="hljs-keyword">public</span>:<br>CStu stu2;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>stu2.<span class="hljs-built_in">fun</span>();<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>CStu cstu;<br>cstu.<span class="hljs-built_in">fun</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>特点：</p><ul><li>不受访问修饰符的影响</li><li>破坏了类的封装性</li></ul><h2 id="9、函数成员"><a href="#9、函数成员" class="headerlink" title="9、函数成员"></a>9、函数成员</h2><h3 id="9-1、构造函数"><a href="#9-1、构造函数" class="headerlink" title="9.1、构造函数"></a>9.1、构造函数</h3><h4 id="9-1-1、普通构造函数"><a href="#9-1-1、普通构造函数" class="headerlink" title="9.1.1、普通构造函数"></a>9.1.1、普通构造函数</h4><p>类中的成员初始化有三种方法：</p><ul><li>定义时直接赋值（比较古老的C++版本不支持）</li><li>初始化列表</li><li>构造函数里面初始化</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CStu</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> age = <span class="hljs-number">13</span>;<br><span class="hljs-built_in">CStu</span>() : <span class="hljs-built_in">age</span>(<span class="hljs-number">2</span>) <br>&#123;<br>age = <span class="hljs-number">3</span>;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>三种初始化方式优先级依次递增，所以age打印出来的时候是3</p><p>构造函数在对象创造过程中调用的，只有栈区对象会调用构造函数，栈区对象就是普通的变量，堆区的对象不会调用构造函数，比如指针对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">CStu* stu;<br></code></pre></td></tr></table></figure><p>此时不会调用构造函数</p><h4 id="9-1-2、带参数的构造函数"><a href="#9-1-2、带参数的构造函数" class="headerlink" title="9.1.2、带参数的构造函数"></a>9.1.2、带参数的构造函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CStu</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> age;<br><span class="hljs-type">float</span> f;<br><span class="hljs-built_in">CStu</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">float</span> b) : <span class="hljs-built_in">age</span>(a), <span class="hljs-built_in">f</span>(b) &#123;<br><br>&#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">CStu <span class="hljs-title">stu1</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">2.3f</span>)</span></span>;<br>std::cout &lt;&lt; stu1.age &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; stu1.f &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>参数并不需要完全用于初始化</p><p>构造函数也可以指定默认值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CStu</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> age;<br><span class="hljs-type">float</span> f;<br><span class="hljs-built_in">CStu</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">float</span> b = <span class="hljs-number">12.23f</span>) : <span class="hljs-built_in">age</span>(a), <span class="hljs-built_in">f</span>(b) &#123;<br><br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>但是会被实际的传参值覆盖掉，优先级问题。</p><p>指针对象初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">CStu stu2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">CStu</span>(<span class="hljs-number">2</span>, <span class="hljs-number">45.56f</span>);<br></code></pre></td></tr></table></figure><h4 id="9-1-3、多个构造函数构成重载"><a href="#9-1-3、多个构造函数构成重载" class="headerlink" title="9.1.3、多个构造函数构成重载"></a>9.1.3、多个构造函数构成重载</h4><p>根据参数传递区分使用哪个构造函数</p><h4 id="9-1-4、类中函数的声明与定义（实现位置）"><a href="#9-1-4、类中函数的声明与定义（实现位置）" class="headerlink" title="9.1.4、类中函数的声明与定义（实现位置）"></a>9.1.4、类中函数的声明与定义（实现位置）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CStu</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> age;<br><span class="hljs-type">float</span> f;<br><span class="hljs-built_in">CStu</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">float</span> b);<span class="hljs-comment">//不可以给b缺省值</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br>CStu::<span class="hljs-built_in">CStu</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">float</span> b = <span class="hljs-number">12.35f</span>) &#123;<br>age = a;<br>f = b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CStu::fun</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;fun&quot;</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以在类内实现，也可以在类外实现</p><p>但是，<strong>在定义函数时不可以添加缺省值</strong></p><h3 id="9-2、构造函数初始化列表"><a href="#9-2、构造函数初始化列表" class="headerlink" title="9.2、构造函数初始化列表"></a>9.2、构造函数初始化列表</h3><h4 id="9-2-1、初始化与赋值的区别"><a href="#9-2-1、初始化与赋值的区别" class="headerlink" title="9.2.1、初始化与赋值的区别"></a>9.2.1、初始化与赋值的区别</h4><p>初始化时一个变量或者对象产生时就赋予一个初始值，伴随性质</p><p>赋值是一个变量或者对象产生之后的任意时刻可以赋予一个值，随意性质</p><p>宏观代码上的区别</p><ul><li>基本数据类型：作用完全相同；</li><li>数组、结构体：数组和结构体初始化时可以采用花括号的形式赋值，初始化之后的赋值不可以使用花括号赋值；作用也完全相同</li><li>引用、const：一定要进行初始化，不能赋值；const变量不初始化报错：<code>&#39;const&#39; object must be initialized if not &#39;extern&#39;</code></li></ul><h4 id="9-2-2、构造函数与初始化列表的区别"><a href="#9-2-2、构造函数与初始化列表的区别" class="headerlink" title="9.2.2、构造函数与初始化列表的区别"></a>9.2.2、构造函数与初始化列表的区别</h4><p>构造函数的本质是赋值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CStu</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> a;<br><span class="hljs-type">float</span> f;<br><span class="hljs-built_in">CStu</span>()<br>&#123;<br>a = <span class="hljs-number">13</span>;<br>f = <span class="hljs-number">13.23f</span>;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>初始化列表的本质是初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CStu</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> a;<br><span class="hljs-type">float</span> f;<br><span class="hljs-built_in">CStu</span>() : <span class="hljs-built_in">a</span>(<span class="hljs-number">13</span>), <span class="hljs-built_in">f</span>(<span class="hljs-number">13.23f</span>)&#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="9-2-3、通过参数进行构造函数初始化"><a href="#9-2-3、通过参数进行构造函数初始化" class="headerlink" title="9.2.3、通过参数进行构造函数初始化"></a>9.2.3、通过参数进行构造函数初始化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CStu</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> a;<br><span class="hljs-type">float</span> f;<br><span class="hljs-built_in">CStu</span>(<span class="hljs-type">int</span> b, <span class="hljs-type">float</span> c) : <span class="hljs-built_in">a</span>(b), <span class="hljs-built_in">f</span>(c)&#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在CStu初始化时需要使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">CStu <span class="hljs-title">stu</span><span class="hljs-params">(<span class="hljs-number">12</span>, <span class="hljs-number">45.6f</span>)</span></span>;<br></code></pre></td></tr></table></figure><p>我们不需要通过参数初始化所有的列表</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CStu</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> a;<br><span class="hljs-type">float</span> f;<br><span class="hljs-built_in">CStu</span>(<span class="hljs-type">int</span> b) : <span class="hljs-built_in">a</span>(b), <span class="hljs-built_in">f</span>(<span class="hljs-number">15.56f</span>)&#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>或者有不被使用的参数也可以</p><h4 id="9-2-4、类内变量的初始化顺序"><a href="#9-2-4、类内变量的初始化顺序" class="headerlink" title="9.2.4、类内变量的初始化顺序"></a>9.2.4、类内变量的初始化顺序</h4><p>变量的初始化顺序只与声明顺序有关，与初始化列表中的顺序无关</p><p>在前面的例子中，我们对CStu初始化时首先初始化a，然后初始化f</p><p>改变写法</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">CStu</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">int</span> a;<br><span class="hljs-built_in">float</span> f;<br>CStu(<span class="hljs-built_in">int</span> b) : f(<span class="hljs-number">15.56f</span>), a(b)&#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>同样先对a初始化，然后再初始化f</p><h4 id="9-2-5、在成员变量之间进行初始化"><a href="#9-2-5、在成员变量之间进行初始化" class="headerlink" title="9.2.5、在成员变量之间进行初始化"></a>9.2.5、在成员变量之间进行初始化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CStu</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> a;<br><span class="hljs-type">int</span> f;<br><span class="hljs-built_in">CStu</span>(<span class="hljs-type">int</span> b) : <span class="hljs-built_in">f</span>(a), <span class="hljs-built_in">a</span>(<span class="hljs-number">12</span>)&#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>同样，根据9.2.4中的描述我们可知，我们会先对a进行初始化，然后对f初始化，所以两个变量都是12</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CStu</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> a;<br><span class="hljs-type">int</span> f;<br><span class="hljs-built_in">CStu</span>(<span class="hljs-type">int</span> b) : <span class="hljs-built_in">f</span>(<span class="hljs-number">12</span>), <span class="hljs-built_in">a</span>(f)&#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>上面这种初始化方式则不正确，我们将a初始化为f，这是一段未赋值的数据，会出现随机数，也可能根据编译器的不同造成报错。</p><h3 id="9-3、引用和const的初始化"><a href="#9-3、引用和const的初始化" class="headerlink" title="9.3、引用和const的初始化"></a>9.3、引用和const的初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CStu</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> f;<br><span class="hljs-type">int</span> &amp;a;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> e;<br><span class="hljs-built_in">CStu</span>(<span class="hljs-type">int</span> c) : <span class="hljs-built_in">a</span>(c), <span class="hljs-built_in">f</span>(<span class="hljs-number">13</span>), <span class="hljs-built_in">e</span>(<span class="hljs-number">18</span>)<br>&#123;<br><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>std::cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; f &lt;&lt; std::endl;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>注意：初始化之后相当于a和f是一个变量</p><p>同时，对引用进行初始化的时候需要注意生命周期的问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CStu</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> f;<br><span class="hljs-type">int</span> &amp;a;<br><span class="hljs-built_in">CStu</span>(<span class="hljs-type">int</span> c) : <span class="hljs-built_in">a</span>(c), <span class="hljs-built_in">f</span>(<span class="hljs-number">13</span>)<br>&#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>std::cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; f &lt;&lt; std::endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">CStu <span class="hljs-title">stu1</span><span class="hljs-params">(<span class="hljs-number">12</span>)</span></span>;<br>stu1.<span class="hljs-built_in">show</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时打印的a会是一个无效的数字，因为此时12这个局部变量的生命周期已经结束，引用不再有效。在构造函数内部打印则是12。</p><h3 id="9-4、析构函数"><a href="#9-4、析构函数" class="headerlink" title="9.4、析构函数"></a>9.4、析构函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CStu</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> nAge;<br><span class="hljs-built_in">CStu</span>()<br>&#123;<br>nAge = <span class="hljs-number">12</span>;<br>&#125;<br>~<span class="hljs-built_in">CStu</span>()<br>&#123;<br><br>&#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><ul><li>析构函数中没有参数（没有重载）</li><li>析构函数前面需要一个<code>~</code></li><li>默认的析构函数什么都不做</li><li>对象生命周期结束时，自动调用</li><li>指针对象存放在堆中，声明时需要使用new才能触发构造函数，在使用delete或者整个程序结束时触发析构函数</li><li>临时对象</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">CStu</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>CStu();就是一个临时对象，临时对象的作用域就是当前所在的语句。</p><h3 id="9-5、mallocfree和new-delete的区别"><a href="#9-5、mallocfree和new-delete的区别" class="headerlink" title="9.5、mallocfree和new delete的区别"></a>9.5、mallocfree和new delete的区别</h3><p>malloc free不会触发构造函数和析构函数</p><p>new delete会触发构造函数和析构函数</p><h3 id="9-6、this"><a href="#9-6、this" class="headerlink" title="9.6、this"></a>9.6、this</h3><p>看下面这段代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CStu</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> a;<br><span class="hljs-built_in">CStu</span>(<span class="hljs-type">int</span> a) &#123;<br>a = a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; a &lt;&lt; std::endl;<br>&#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">CStu <span class="hljs-title">stu1</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;<br>stu1.<span class="hljs-built_in">show</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码在执行之后，打印a的值为<code>-858993460</code>。</p><p>原因是在构造函数的作用域中，构造函数只认得a是通过参数传递过来的a，而类本身的成员（属性）a构造函数并不承认，所以最后在打印a的值的时候，会是一个随机值。</p><p>为了解决这样的问题，C++给出了this指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CStu</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> a;<br><span class="hljs-built_in">CStu</span>(<span class="hljs-type">int</span> a) &#123;<br><span class="hljs-keyword">this</span>-&gt;a = a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; a &lt;&lt; std::endl;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>this指针是指向当前对象的指针。</p><ul><li>this指针是在对象创建时才存在的</li><li>this指针的类型是其所指向的对象的类型</li><li>this指针不是成员，不能使用<code>stu.this</code>等方法</li><li>this指针是类成员函数的隐含参数，每个函数都隐含一个this参数，所以我们只能在函数里面使用this指针，函数外不可使用</li><li>this指针的作用域在类的内部，准确来说在类的函数内部</li></ul><h3 id="9-7、常函数"><a href="#9-7、常函数" class="headerlink" title="9.7、常函数"></a>9.7、常函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CStu</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;i am show&quot;</span> &lt;&lt; std::endl;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>函数名() 后面增加一个const即为常函数</li><li>构造函数和析构函数不能是常函数</li><li>常函数不能修改数据成员，但是可以使用。这里的数据成员是指类内的数据成员，在函数中定义的数据成员可以被修改。</li><li>常函数对函数的功能有更明确的限定</li><li>长函数的this指针的数据类型是const CStu*</li><li>常对象只能调用常函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CStu</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;i am show&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;fun&quot;</span> &lt;&lt; std::endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">const</span> CStu st1;<br>st1.<span class="hljs-built_in">fun</span>(); <span class="hljs-comment">//error</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中<code>st1.fun();</code>是错误的。st1是常对象，只能调用常函数</p><h3 id="9-8、static"><a href="#9-8、static" class="headerlink" title="9.8、static"></a>9.8、static</h3><h4 id="9-8-1、静态变量"><a href="#9-8-1、静态变量" class="headerlink" title="9.8.1、静态变量"></a>9.8.1、静态变量</h4><p>静态成员属于类作用域，但不属于类对象。它的声明周期和普通的静态变量一样，程序运行时进行分配内存和初始化，程序结束时则被释放。所以不能在类的构造函数中进行初始化。</p><p>但是可以赋值！！！不要搞混</p><ul><li>静态成员无法通过初始化列表进行初始化</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CStu</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> a; <span class="hljs-comment">//error</span><br><span class="hljs-built_in">CStu</span>() : <span class="hljs-built_in">a</span>(<span class="hljs-number">12</span>)<br>&#123;<br><br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>也无法在类内直接初始化</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CStu</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> a = <span class="hljs-number">12</span>; <span class="hljs-comment">//error</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>但是可以通过构造函数赋值的方法进行初始化</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CStu</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> a;<br><span class="hljs-built_in">CStu</span>()<br>&#123;<br>a = <span class="hljs-number">12</span>;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>也可以在类外初始化</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CStu</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> a;<br>&#125;;<br><br><span class="hljs-type">int</span> CStu::a = <span class="hljs-number">12</span>;<span class="hljs-comment">//此处千万不要加static</span><br></code></pre></td></tr></table></figure><ul><li>有一种比较特殊：<strong>静态常量整形</strong>数据成员可以在类内进行初始化</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CStu</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">const</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> a = <span class="hljs-number">12</span>;<br>    <span class="hljs-comment">//const static float b = 12.13f; //error</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="9-8-2、函数成员"><a href="#9-8-2、函数成员" class="headerlink" title="9.8.2、函数成员"></a>9.8.2、函数成员</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CStu</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> a;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; a &lt;&lt; std::endl;<br>&#125;<br>&#125;;<br><br><br><span class="hljs-type">int</span> CStu::a = <span class="hljs-number">13</span>;<br></code></pre></td></tr></table></figure><p>函数调用方法有两种</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//1、类名作用域</span><br>CStu::<span class="hljs-built_in">fun</span>();<br><br><span class="hljs-comment">//2、对象调用</span><br>CStu stu1;<br>stu1.<span class="hljs-built_in">fun</span>();<br></code></pre></td></tr></table></figure><h4 id="9-8-3、注意"><a href="#9-8-3、注意" class="headerlink" title="9.8.3、注意"></a>9.8.3、注意</h4><ul><li>静态成员没有this指针</li><li>类内的静态函数不能调用普通的数据成员，只能调用静态成员</li></ul><h3 id="9-9、拷贝构造"><a href="#9-9、拷贝构造" class="headerlink" title="9.9、拷贝构造"></a>9.9、拷贝构造</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CStu</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">CStu</span>()<br>&#123;<br><br>&#125;<br><br><span class="hljs-built_in">CStu</span>(<span class="hljs-type">const</span> CStu&amp; a) <span class="hljs-comment">//拷贝构造函数</span><br>&#123;<br><br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="9-9-1、何时调用？"><a href="#9-9-1、何时调用？" class="headerlink" title="9.9.1、何时调用？"></a>9.9.1、何时调用？</h4><ul><li><p>新建一个对象，并将其初始化为同类现有对象<code> CStu st1;</code></p><ol><li>CStu stNew(st1);</li><li>CStu stNew &#x3D; st1;</li><li>CStu stNew &#x3D; CStu(st1);</li><li>CStu* stNew &#x3D; new CStu();</li></ol></li><li><p>注意：使用对象进行赋值的时候不会调用拷贝构造函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">CStu st2;<br>st2 = st1;<br></code></pre></td></tr></table></figure></li><li><p>当程序生成对象副本时，调用拷贝构造函数</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(CStu a)</span></span><br><span class="hljs-function"></span>&#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>CStu st1;<br><span class="hljs-built_in">fun</span>(st1);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在调用fun函数时会使用拷贝构造生成一个临时的对象</p><ul><li>做函数的返回值时</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">CStu <span class="hljs-title">fun</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>CStu a;<br><span class="hljs-keyword">return</span> a;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>CStu st1;<br><span class="hljs-built_in">fun</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，是在返回的时候调用拷贝构造函数</p><h4 id="9-9-2、有何功能"><a href="#9-9-2、有何功能" class="headerlink" title="9.9.2、有何功能"></a>9.9.2、有何功能</h4><p>默认的拷贝构造函数，逐个赋值非静态成员（成员的复制为浅复制）值，复制的是成员的值</p><h4 id="9-9-3、浅拷贝的问题–指针"><a href="#9-9-3、浅拷贝的问题–指针" class="headerlink" title="9.9.3、浅拷贝的问题–指针"></a>9.9.3、浅拷贝的问题–指针</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CStu</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span>* a;<br><span class="hljs-built_in">CStu</span>()<br>&#123;<br>a = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">2</span>];<br>a[<span class="hljs-number">0</span>] = <span class="hljs-number">12</span>;<br>a[<span class="hljs-number">1</span>] = <span class="hljs-number">13</span>;<br>&#125;<br><br>~<span class="hljs-built_in">CStu</span>()<br>&#123;<br><span class="hljs-keyword">delete</span>[] a;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>CStu stu;<br>std::cout &lt;&lt; stu.a[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; stu.a[<span class="hljs-number">1</span>] &lt;&lt; std::endl;<br><br>CStu stNew = stu;<br>std::cout &lt;&lt; stNew.a[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; stNew.a[<span class="hljs-number">1</span>] &lt;&lt; std::endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段程序可以编译通过，但是运行的时候会崩溃，这就是浅拷贝的问题，<strong>指针内存的释放问题</strong></p><p>浅拷贝只是复制了指针的值，在释放st的时候a(stu.a)指针的内存就已经被释放，而再次释放stNew的时候，仍需要对a(stNew.a)进行释放，由于此前已经释放过一次，所以程序会发生崩溃。</p><h3 id="9-4、深拷贝"><a href="#9-4、深拷贝" class="headerlink" title="9.4、深拷贝"></a>9.4、深拷贝</h3><p>深拷贝就是亲自实现拷贝构造方法</p><p>考虑到，对象释放的时候肯定会执行析构函数，而指针是每个Stu对象必不可少的内容，所以我们需要将每个对象的a指针都申请一段空间，这样在释放的时候就不会出现问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">CStu</span>(<span class="hljs-type">const</span> CStu&amp; b)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;a = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">2</span>];<br><span class="hljs-built_in">memcpy</span>(<span class="hljs-keyword">this</span>-&gt;a, b.a, <span class="hljs-number">8</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样的拷贝构造函数就可以实现每个Stu对象的a指针都有一段内存</p><h3 id="9-5、内联函数"><a href="#9-5、内联函数" class="headerlink" title="9.5、内联函数"></a>9.5、内联函数</h3><h4 id="9-5-1、常规内联函数"><a href="#9-5-1、常规内联函数" class="headerlink" title="9.5.1、常规内联函数"></a>9.5.1、常规内联函数</h4><p>常规函数调用需要根据函数地址跳转到函数的代码空间，然后执行指令</p><p>内联函数则是将函数的代码直接复制到函数调用的位置</p><p>二者的区别：</p><ul><li>比常规函数稍快</li><li>代价是占用内存过多</li></ul><p>内联函数声明的方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//声明</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span><span class="hljs-comment">//定义</span></span><br><span class="hljs-function"></span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>函数声明与函数定义位置都需要添加<code>inline</code></p><p>在使用内联函数的时候需要考虑内联函数的性价比问题。而实际上我们在使用内联函数的时候，编译器不一定会答应的。</p><h4 id="9-5-2、类内的内联函数"><a href="#9-5-2、类内的内联函数" class="headerlink" title="9.5.2、类内的内联函数"></a>9.5.2、类内的内联函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CStu</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span> <span class="hljs-comment">//inline 隐式定义</span></span><br><span class="hljs-function"></span>&#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">()</span> <span class="hljs-comment">// inline 显式定义</span></span><br><span class="hljs-function"></span>&#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun2</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">fun3</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun4</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">CStu::fun2</span><span class="hljs-params">()</span> <span class="hljs-comment">//内联函数</span></span><br><span class="hljs-function"></span>&#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun3</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun4</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>在上述的四个函数中,fun1肯定是内联函数,fun4()肯定不是内联函数</p><p>fun2()与fun3()一个在类内声明，而定义没有inline；另一个声明没有inline而定义有inline，这两个函数是否为内联函数需要看编译器的执行情况。</p><h4 id="9-5-3、注意"><a href="#9-5-3、注意" class="headerlink" title="9.5.3、注意"></a>9.5.3、注意</h4><p>内联函数的声明与定义必须在一个文件中，即使在头文件中，也需要将定义写在头文件中，不然不会得到内联的效果</p>]]></content>
    
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零开始的操作系统生活06-interrupt</title>
    <link href="/2022/10/06/wyoos006/"/>
    <url>/2022/10/06/wyoos006/</url>
    
    <content type="html"><![CDATA[<p>本节代码地址<a href="https://github.com/anhongzhan/wyoos/tree/master/006">github</a></p><h2 id="1、Introduction"><a href="#1、Introduction" class="headerlink" title="1、Introduction"></a>1、Introduction</h2><p><a href="https://wiki.osdev.org/Interrupts">中断</a>是指来自外部设备的信号，给到CPU，例如键盘或者其他的硬件设备。CPU收到中断信号后不顾一切的停止正在执行的指令，转而去执行一些预先设定好的中断指令。</p><p>注意，中断指来自外部设备的信号，其他的比如除以0等问题来自于CPU内部，我们称之为异常(Exception)。</p><p>中断和异常本质上工作原理相同，只不过来源不同。本节我们也会涉及一些异常的内容。</p><h2 id="2、IDT"><a href="#2、IDT" class="headerlink" title="2、IDT"></a>2、IDT</h2><p>和GDT类似。IDT也是一种描述符表格，全称为<a href="https://wiki.osdev.org/Interrupt_Descriptor_Table">Interrupt Descriptor Table</a>。IDT中的每一项叫做门描述符(Gate Descriptor)，门描述符的数据结构如下图所示：</p><p><img src="/2022/10/06/wyoos006/GateDescriptor.PNG" alt="GateDescriptor"></p><p>可以看到，IDT中有一部分为Segment Selector，段选择子的内容我们在GDT中讲过，负责选择GDT中的某个描述符，然后根据描述符中的内容获得基地址。这里也是同样的原理，由于中断是CPU停止现在的工作，转到执行一些预先设定好的指令，这些指令也存在内存中，一般在代码段中。通过IDT中的段选择子以及Offset我们可以跳转到要执行的中断指令处，这样就实现了中断。</p><p>IDT的其他部分内容如下所示：</p><ul><li><strong>Offset:</strong> A 32-bit value, split in two parts. It represents the address of the entry point of the <strong><a href="https://wiki.osdev.org/Interrupt_Service_Routines">Interrupt Service Routine</a></strong>.</li><li><strong>Selector:</strong> A <strong><a href="https://wiki.osdev.org/Segment_Selector">Segment Selector</a></strong> with multiple fields which must point to a valid code segment in your <strong><a href="https://wiki.osdev.org/GDT">GDT</a></strong>.</li><li>Gate Type: A 4-bit value which defines the type of gate this Interrupt Descriptor represents. There are five valid type values:<ul><li><strong>0b0101</strong> or <strong>0x5</strong>: Task Gate, note that in this case, the <strong>Offset</strong> value is unused and should be set to zero.</li><li><strong>0b0110</strong> or <strong>0x6</strong>: 16-bit Interrupt Gate</li><li><strong>0b0111</strong> or <strong>0x7</strong>: 16-bit Trap Gate</li><li><strong>0b1110</strong> or <strong>0xE</strong>: 32-bit Interrupt Gate</li><li><strong>0b1111</strong> or <strong>0xF</strong>: 32-bit Trap Gate</li></ul></li><li><strong>DPL:</strong> A 2-bit value which defines the <strong><a href="https://wiki.osdev.org/Security#Rings">CPU Privilege Levels</a></strong> which are allowed to access this interrupt via the <strong>INT</strong> instruction. Hardware interrupts ignore this mechanism.</li><li><strong>P:</strong> Present bit. Must be set (<strong>1</strong>) for the descriptor to be valid.</li></ul><p>For more information, see <strong>Section 6.11: IDT Descriptors</strong> and <strong>Figure 6-2: IDT Gate Descriptors</strong> of the Intel Software Developer Manual, Volume 3-A.</p><p>通过上面的描述我们可以看出，IDT中一共存在四种门描述符，分别是任务门、中断门、陷阱门以及调用门，这四种结构的具体内容如下：</p><p>任务门：</p><p><img src="/2022/10/06/wyoos006/TaskGate.png" alt="TaskGate"></p><p>中断门：</p><p><img src="/2022/10/06/wyoos006/InterruptGate.jpg" alt="InterruptGate"></p><p>陷阱门：</p><p><img src="/2022/10/06/wyoos006/TrapGate.jpg" alt="TrapGate"></p><p>调用门：</p><p><img src="/2022/10/06/wyoos006/CallGate.jpg" alt="CallGate"></p><p>可以看到，每种门的<code>TYPE</code>字段是不同的。另一个不同点是，任务们选择子字段是TSS选择子。TSS(Task Status Segment)是Intel处理器中提供任务切换机制时使用的数据结构。由于我们本次实现的操作系统不涉及TSS，所以这里不做展开讲述。</p><p>详细了解TSS可以参考《Linux内核完全剖析 -基于0.12内核》这本书的140页开始的boot.s以及head.s的讲解。</p><p>门描述符的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">GateDescriptor</span> &#123;<br>    <span class="hljs-type">uint16_t</span> handleAddressLowBits;<br>    <span class="hljs-type">uint16_t</span> gdt_codeSegementSelector;<br>    <span class="hljs-type">uint8_t</span> reserved;<br>    <span class="hljs-type">uint8_t</span> access;<br>    <span class="hljs-type">uint16_t</span> handleAddressHighBits;<br>&#125;__attribute__((packed));<br><br><span class="hljs-type">static</span> GateDescriptor interruptDescriptorTable[<span class="hljs-number">256</span>];<br></code></pre></td></tr></table></figure><p>处理器只支持256个中断，所以我们设置一个长度为256的数组来存放门描述符，也就是IDT</p><h2 id="3、Where-is-IDT"><a href="#3、Where-is-IDT" class="headerlink" title="3、Where is IDT?"></a>3、Where is IDT?</h2><p>在GDT一节中我们介绍过，通过GDTR存储GDT的位置，这样访问GDTR我们就能找到GDT。</p><p>同样，IDT的地址存储在IDTR(Interrupt Descriptor Table Register)中，</p><p><img src="/2022/10/06/wyoos006/IDTR.PNG" alt="IDTR"></p><p>没错，IDTR的结构也和GDTR非常类似，图中Offset存储着IDT的基地址，32位系统中基地址有32位，64位系统中基地址自然是64位。size表示IDT中门描述符的个数，在OSDEV中有这样一句：<br>Although the <strong>IDT</strong> can contain less than 256 entries, any entries that are not present (due to this or other reasons) will generate a <strong><a href="https://wiki.osdev.org/Exceptions#General_Protection_Fault">General Protection Fault</a></strong> when an attempt to access them is made. Ideally the <strong>IDT</strong> should contain enough entries so that this fault (which is itself an interrupt vector) can be handled.</p><p>虽然我们可能用不到256个中断，但是这256个中断必须都存在，哪怕是什么都不执行也要存在。因为访问不存在的中断会引起General Protection Fault。</p><p>最后，我们使用LIDT指令将IDT地址加载到IDTR中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">asm</span> <span class="hljs-title">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;lidt %0&quot;</span> : : <span class="hljs-string">&quot;m&quot;</span> (idt))</span></span>;<br></code></pre></td></tr></table></figure><h2 id="4、How-to-find-Gate-Descriptor"><a href="#4、How-to-find-Gate-Descriptor" class="headerlink" title="4、How to find Gate Descriptor?"></a>4、How to find Gate Descriptor?</h2><p>中断的发生由外部或者内部的信号出发，这里的信号包含中断号信息，系统通过这个中断号就可以找到对应的门描述符（当然还有很多其他的处理），然后就可以执行中断了，这里不需要我们做太多的处理。</p><p>和GDT不同，我们没有段选择子。</p><h2 id="5、Coding"><a href="#5、Coding" class="headerlink" title="5、Coding"></a>5、Coding</h2><p>首先创建三个文件：<code>interrupts.h</code>,<code>interrupts.cpp</code>,<code>interruptstubs.s</code></p><p>这里我们只实现Intel设计者设计的17个中断以及20个异常的程序，其他的内容理论上要有，但是我们控制处理器不访问其他的内容即可。</p><p>首先是<code>interrupts.h</code>，定义IDT</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">InterruptManager</span> &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">GateDescriptor</span> &#123;<br>        <span class="hljs-type">uint16_t</span> handleAddressLowBits;<br>        <span class="hljs-type">uint16_t</span> gdt_codeSegementSelector;<br>        <span class="hljs-type">uint8_t</span> reserved;<br>        <span class="hljs-type">uint8_t</span> access;<br>        <span class="hljs-type">uint16_t</span> handleAddressHighBits;<br>    &#125;__attribute__((packed));<br><br>    <span class="hljs-type">static</span> GateDescriptor interruptDescriptorTable[<span class="hljs-number">256</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><p>然后加载IDTR，填写IDT表</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">InterruptManager</span> &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">InterruptorDescriptorTablePointer</span>&#123;<br>        <span class="hljs-type">uint16_t</span> size;<br>        <span class="hljs-type">uint32_t</span> base;<br>    &#125;__attribute__((packed));<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">SetInterruptDescriptorTableEntry</span> <span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">uint8_t</span> interruptNumber,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">uint16_t</span> codeSegmentSelectorOffset,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">void</span> (*handler)(),</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">uint8_t</span> DescriptorPrivilegeLevel,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">uint8_t</span> DescriptorType</span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>再然后设定需要完成的中断和异常处理指令，在cpp里面就是函数，这部分由<code>interruptstubs.s</code>实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">InterruptManager</span> &#123;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleInterruptRequest0x00</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleInterruptRequest0x01</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleInterruptRequest0x02</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleInterruptRequest0x03</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleInterruptRequest0x04</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleInterruptRequest0x05</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleInterruptRequest0x06</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleInterruptRequest0x07</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleInterruptRequest0x08</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleInterruptRequest0x09</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleInterruptRequest0x0A</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleInterruptRequest0x0B</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleInterruptRequest0x0C</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleInterruptRequest0x0D</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleInterruptRequest0x0E</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleInterruptRequest0x0F</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleInterruptRequest0x31</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleException0x00</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleException0x01</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleException0x02</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleException0x03</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleException0x04</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleException0x05</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleException0x06</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleException0x07</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleException0x08</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleException0x09</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleException0x0A</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleException0x0B</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleException0x0C</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleException0x0D</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleException0x0E</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleException0x0F</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleException0x10</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleException0x11</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleException0x12</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleException0x13</span><span class="hljs-params">()</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>最后，还有设定中断端口的指令，这部分内容后面会讲：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">    <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;port.h&quot;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">InterruptManager</span> &#123;    <br>    Port8BitSlow picMasterCommand;<br>    Port8BitSlow picMasterData;<br>    Port8BitSlow picSlaveCommand;<br>    Port8BitSlow picSlaveData;<br>&#125;;<br></code></pre></td></tr></table></figure><p>最后的最后，还有中断处理函数、中断激活和失效函数以及InterruptManager的构造函数、析构函数等</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">InterruptManager</span> &#123;<br><span class="hljs-built_in">InterruptManager</span>(GlobalDescriptorTable* gdt, <span class="hljs-type">uint16_t</span> hardwareInterruptOffset);<br>    ~<span class="hljs-built_in">InterruptManager</span>();<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Activate</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Deactivate</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">uint32_t</span> <span class="hljs-title">HandleInterrupt</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> interruptNumber, <span class="hljs-type">uint32_t</span> esp)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">DoHandleInterrupt</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> interruptNumber, <span class="hljs-type">uint32_t</span> esp)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>以上内容都是InterruptManager类中的内容，我们需要额外实现中断处理类，专门负责InterruptManager中的中断处理工作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">InterruptHandler</span> &#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-built_in">InterruptHandler</span>(<span class="hljs-type">uint8_t</span> interruptNumber, InterruptManager* interruptManager);<br>    ~<span class="hljs-built_in">InterruptHandler</span>();<br><br>    <span class="hljs-type">uint8_t</span> interruptNumber;<br>    InterruptManager* interruptManager;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">HandleInterrupt</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> esp)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>头文件定义完毕，接下来是实现：</p><p><code>interruptstubs.s</code>实现了InterruptManager中的中断异常处理函数：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">.set</span> IRQ_BASE, <span class="hljs-number">0x20</span><br><span class="hljs-meta">.section</span> .text<br><span class="hljs-meta">.extern</span> _ZN16InterruptManager15HandleInterruptEhj<br><span class="hljs-meta"></span><br><span class="hljs-meta">.macro</span> HandleInterruptRequest num<br><span class="hljs-meta">.global</span> _ZN16InterruptManager26HandleInterruptRequest\num\()Ev<br>_ZN16InterruptManager26HandleInterruptRequest\num\()Ev:<br>    movb $\num + IRQ_BASE, (interruptnumber)<br>    <span class="hljs-keyword">jmp</span> int_bottom<br><span class="hljs-meta">.endm</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">.macro</span> HandleException num<br><span class="hljs-meta">.global</span> _ZN16InterruptManager19HandleException\num\()Ev<br>_ZN16InterruptManager19HandleException\num\()Ev:<br>    movb $\num, (interruptnumber)<br>    <span class="hljs-keyword">jmp</span> int_bottom<br><span class="hljs-meta">.endm</span><br><br>HandleInterruptRequest <span class="hljs-number">0x00</span><br>HandleInterruptRequest <span class="hljs-number">0x01</span><br>HandleInterruptRequest <span class="hljs-number">0x02</span><br>HandleInterruptRequest <span class="hljs-number">0x03</span><br>HandleInterruptRequest <span class="hljs-number">0x04</span><br>HandleInterruptRequest <span class="hljs-number">0x05</span><br>HandleInterruptRequest <span class="hljs-number">0x06</span><br>HandleInterruptRequest <span class="hljs-number">0x07</span><br>HandleInterruptRequest <span class="hljs-number">0x08</span><br>HandleInterruptRequest <span class="hljs-number">0x09</span><br>HandleInterruptRequest <span class="hljs-number">0x0A</span><br>HandleInterruptRequest <span class="hljs-number">0x0B</span><br>HandleInterruptRequest <span class="hljs-number">0x0C</span><br>HandleInterruptRequest <span class="hljs-number">0x0D</span><br>HandleInterruptRequest <span class="hljs-number">0x0E</span><br>HandleInterruptRequest <span class="hljs-number">0x0F</span><br>HandleInterruptRequest <span class="hljs-number">0x31</span><br><br>HandleException <span class="hljs-number">0x00</span><br>HandleException <span class="hljs-number">0x01</span><br>HandleException <span class="hljs-number">0x02</span><br>HandleException <span class="hljs-number">0x03</span><br>HandleException <span class="hljs-number">0x04</span><br>HandleException <span class="hljs-number">0x05</span><br>HandleException <span class="hljs-number">0x06</span><br>HandleException <span class="hljs-number">0x07</span><br>HandleException <span class="hljs-number">0x08</span><br>HandleException <span class="hljs-number">0x09</span><br>HandleException <span class="hljs-number">0x0A</span><br>HandleException <span class="hljs-number">0x0B</span><br>HandleException <span class="hljs-number">0x0C</span><br>HandleException <span class="hljs-number">0x0D</span><br>HandleException <span class="hljs-number">0x0E</span><br>HandleException <span class="hljs-number">0x0F</span><br>HandleException <span class="hljs-number">0x10</span><br>HandleException <span class="hljs-number">0x11</span><br>HandleException <span class="hljs-number">0x12</span><br>HandleException <span class="hljs-number">0x13</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">int_bottom:</span><br>    <span class="hljs-keyword">pusha</span> <br>    pushl %ds<br>    pushl %es<br>    pushl %fs<br>    pushl %gs<br><br>    pushl %esp<br>    <span class="hljs-keyword">push</span> (interruptnumber)<br>    <span class="hljs-keyword">call</span> _ZN16InterruptManager15HandleInterruptEhj<br>    <br>    movl %eax, %esp<br>    popl %gs<br>    popl %fs<br>    popl %es<br>    popl %ds<br>    <span class="hljs-keyword">popa</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">.global</span> _ZN16InterruptManager15InterruptIgnoreEv<br><span class="hljs-symbol">_ZN16InterruptManager15InterruptIgnoreEv:</span><br><br><br>    <span class="hljs-keyword">iret</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">.data</span><br><span class="hljs-symbol">    interruptnumber:</span> .byte <span class="hljs-number">0</span><br><br></code></pre></td></tr></table></figure><p>首先，<code>_ZN16InterruptManager26HandleInterruptRequest\num\()Ev</code>是我们通过objdump反汇编之后得到的名称，由于我们函数数量比较多，所以采用这种拼接的方式组成函数名称，这里建议观看<a href="https://www.bilibili.com/video/BV1RX4y157CM?p=14&vd_source=71ff1308c23d0ef0791f945a3cc515e6">参考资料</a>学习一下具体的命名方式。</p><p>下面说一下中断的处理方式，中断信号来到之后，CPU需要停止正在进行的工作，转而去执行中断指令。但同时需要考虑另一个问题，那就是执行完中断指令后要怎么办？那肯定是回到之前执行的工作继续执行啦。那怎么回去呢？寄存器就那么几个，肯定无法保存前面执行的内容，所以操作系统的实现者考虑使用栈来保存中断执行前的信息，中断执行之后再弹栈即可，这就是我们下面的中断执行函数的实现：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs llvm">int_bottom:<br>    pusha <br>    pushl <span class="hljs-variable">%ds</span><br>    pushl <span class="hljs-variable">%es</span><br>    pushl <span class="hljs-variable">%fs</span><br>    pushl <span class="hljs-variable">%gs</span><br><br>    pushl <span class="hljs-variable">%esp</span><br>    push (interruptnumber)<br>    <span class="hljs-keyword">call</span> _ZN<span class="hljs-number">16</span>InterruptManager<span class="hljs-number">15</span>HandleInterruptEhj<br>    <br>    movl <span class="hljs-variable">%eax</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%esp</span><br>    popl <span class="hljs-variable">%gs</span><br>    popl <span class="hljs-variable">%fs</span><br>    popl <span class="hljs-variable">%es</span><br>    popl <span class="hljs-variable">%ds</span><br>    popa<br></code></pre></td></tr></table></figure><p>可以看到，每个中断或者异常处理函数都跳转到<code>int_bottom</code>，跳转之后开始压栈，然后执行InterruptManager::HandleInterrupt()函数。执行完毕后再弹栈，继续前面被终止的工作。</p><p>最后解释一下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">.<span class="hljs-built_in">set</span> IRQ_BASE, 0x20<br></code></pre></td></tr></table></figure><p>前面提到过，中断是由硬件发来的信号。CPU内部的“中断”叫做异常。操作系统设计者对这些内容编号时，设定了32个异常，排在前32位，后面紧接着就是中断，所以说我们的中断号是从32开始的，也就是0x20。意思就是，我们的第一号中断对应的中断编号位0x20+0x1</p><p>注：当我们提到中断号时就泛指所有的中断和异常。</p><p>最后是<code>interrupts.cpp</code></p><p>首先是中断激活以及失效函数，<code>sti</code>指set interrupt，用于开启中断，<code>cli</code>指clear interrupt，用于清空中断。</p><p>ActiveInterruptManager指当前激活的InterruptManager对象，很明显，我们的中断请求由这个对象来处理。但这种中断处理对象不能存在多个，所以我们需要将其他的InterruptManager对象关闭掉，然后使用新的ActiveInterruptManager来处理中断。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InterruptManager::Activate</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(ActiveInterruptManager != <span class="hljs-number">0</span>)&#123;<br>        ActiveInterruptManager-&gt;<span class="hljs-built_in">Deactivate</span>();<br>    &#125;<br>    ActiveInterruptManager = <span class="hljs-keyword">this</span>;<br>    <span class="hljs-built_in">asm</span>(<span class="hljs-string">&quot;sti&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InterruptManager::Deactivate</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(ActiveInterruptManager == <span class="hljs-keyword">this</span>)&#123;<br>        ActiveInterruptManager = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">asm</span>(<span class="hljs-string">&quot;cli&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来就是中断处理，这里为了清晰明了作者(wyoos的作者)采用了两个函数来实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">InterruptManager::HandleInterrupt</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> InterruptNumber, <span class="hljs-type">uint32_t</span> esp)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(ActiveInterruptManager != <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> ActiveInterruptManager-&gt;<span class="hljs-built_in">DoHandleInterrupt</span>(InterruptNumber, esp);<br>    &#125;<br>    <span class="hljs-keyword">return</span> esp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">InterruptManager::DoHandleInterrupt</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> InterruptNumber, <span class="hljs-type">uint32_t</span> esp)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(handlers[InterruptNumber] != <span class="hljs-number">0</span>)&#123;<br>        esp = handlers[InterruptNumber]-&gt;<span class="hljs-built_in">HandleInterrupt</span>(esp);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(InterruptNumber != hardwareInterruptOffset)&#123;<br>        <span class="hljs-type">char</span>* foo = (<span class="hljs-type">char</span>*)<span class="hljs-string">&quot;UNHANDLED INTERRUPT 0X00&quot;</span>;<br>        <span class="hljs-type">const</span> <span class="hljs-type">char</span>* hex = <span class="hljs-string">&quot;0123456789ABCDEF&quot;</span>;<br>        foo[<span class="hljs-number">22</span>] = hex[(InterruptNumber &gt;&gt; <span class="hljs-number">4</span>) &amp; <span class="hljs-number">0x0f</span>];<br>        foo[<span class="hljs-number">23</span>] = hex[InterruptNumber &amp; <span class="hljs-number">0x0f</span>];<br>        <span class="hljs-built_in">printf</span>((<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)foo);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(hardwareInterruptOffset &lt;= InterruptNumber &amp;&amp; InterruptNumber &lt; hardwareInterruptOffset + <span class="hljs-number">16</span>)&#123;<br>        picMasterCommand.<span class="hljs-built_in">Write</span>(<span class="hljs-number">0x20</span>);<br>        <span class="hljs-keyword">if</span>(hardwareInterruptOffset + <span class="hljs-number">8</span> &lt;= InterruptNumber)&#123;<br>            picSlaveCommand.<span class="hljs-built_in">Write</span>(<span class="hljs-number">0x20</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> esp;<br>&#125;<br></code></pre></td></tr></table></figure><p>HandleInterrupt判断是否存在前面所说的ActiveInterruptManager对象，如果不存在，自然不能执行中断</p><p>DoHandleInterrupt则是执行中断，这里我们采用打印相应的中断号作为中断处理程序，这样比较明显。</p><p>我们可以看到判断<code>if(handlers[InterruptNumber] != 0)</code>，这里是为了我们后面实现键盘和鼠标做准备，我们设定好的中断自然有其自己的执行程序，而未设定好的中断则是采用打印<code>UNHANDLED INTERRUPT 0X</code>+中断号来实现的。其中，中断号0x20(第一个硬件中断)是指时钟中断，时时刻刻都在发生，所以我们将其屏蔽掉。</p><p>最后的判断是指8259A芯片编程，对硬件端口写入一些特定值，从而告知硬件中断已经处理完成。</p><p>接下来：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InterruptManager::SetInterruptDescriptorTableEntry</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">uint8_t</span> interruptNumber,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">uint16_t</span> codeSegmentSelectorOffset,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">void</span> (*handler)(),</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">uint8_t</span> DescriptorPrivilegeLevel,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">uint8_t</span> DescriptorType)</span></span>&#123;<br>        <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> IDT_DESC_PRESENT = <span class="hljs-number">0x80</span>;<br><br>        interruptDescriptorTable[interruptNumber].handleAddressLowBits = ((<span class="hljs-type">uint32_t</span>)handler) &amp; <span class="hljs-number">0xffff</span>;<br>        interruptDescriptorTable[interruptNumber].handleAddressHighBits = ((<span class="hljs-type">uint32_t</span>)handler &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xffff</span>;<br>        interruptDescriptorTable[interruptNumber].gdt_codeSegementSelector = codeSegmentSelectorOffset;<br>        interruptDescriptorTable[interruptNumber].access = IDT_DESC_PRESENT | ((DescriptorPrivilegeLevel &amp; <span class="hljs-number">3</span>) &lt;&lt; <span class="hljs-number">5</span>) | DescriptorType;<br>        interruptDescriptorTable[interruptNumber].reserved = <span class="hljs-number">0</span>; <br>    &#125;<br></code></pre></td></tr></table></figure><p>设定门描述符，每处设定都是按照前面的门描述符的结构设定的，大家可以去对应一下。后面会不断调用这个门描述符表，毕竟有256个中断。</p><p>再然后：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs cpp">InterruptManager::<span class="hljs-built_in">InterruptManager</span>(GlobalDescriptorTable* gdt, <span class="hljs-type">uint16_t</span> hardwareInterruptOffset)<br>    :<span class="hljs-built_in">picMasterCommand</span>(<span class="hljs-number">0x20</span>),<br>    <span class="hljs-built_in">picMasterData</span>(<span class="hljs-number">0x21</span>),<br>    <span class="hljs-built_in">picSlaveCommand</span>(<span class="hljs-number">0xA0</span>),<br>    <span class="hljs-built_in">picSlaveData</span>(<span class="hljs-number">0xA1</span>)<br>&#123;<br>    <span class="hljs-keyword">this</span>-&gt;hardwareInterruptOffset = hardwareInterruptOffset;<br>    <span class="hljs-type">uint16_t</span> codeSegemnt = gdt-&gt;<span class="hljs-built_in">CodeSegmentSelector</span>();<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> IDT_INTERRUPT_GATE = <span class="hljs-number">0xe</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">uint16_t</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">256</span>; i++)&#123;<br>        handlers[i] = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(i, codeSegemnt, &amp;InterruptIgnore, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    &#125;<br><br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(<span class="hljs-number">0x00</span>, codeSegemnt, &amp;HandleException0x00, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(<span class="hljs-number">0x01</span>, codeSegemnt, &amp;HandleException0x01, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(<span class="hljs-number">0x02</span>, codeSegemnt, &amp;HandleException0x02, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(<span class="hljs-number">0x03</span>, codeSegemnt, &amp;HandleException0x03, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(<span class="hljs-number">0x04</span>, codeSegemnt, &amp;HandleException0x04, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(<span class="hljs-number">0x05</span>, codeSegemnt, &amp;HandleException0x05, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(<span class="hljs-number">0x06</span>, codeSegemnt, &amp;HandleException0x06, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(<span class="hljs-number">0x07</span>, codeSegemnt, &amp;HandleException0x07, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(<span class="hljs-number">0x08</span>, codeSegemnt, &amp;HandleException0x08, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(<span class="hljs-number">0x09</span>, codeSegemnt, &amp;HandleException0x09, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(<span class="hljs-number">0x0A</span>, codeSegemnt, &amp;HandleException0x0A, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(<span class="hljs-number">0x0B</span>, codeSegemnt, &amp;HandleException0x0B, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(<span class="hljs-number">0x0C</span>, codeSegemnt, &amp;HandleException0x0C, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(<span class="hljs-number">0x0D</span>, codeSegemnt, &amp;HandleException0x0D, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(<span class="hljs-number">0x0E</span>, codeSegemnt, &amp;HandleException0x0E, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(<span class="hljs-number">0x0F</span>, codeSegemnt, &amp;HandleException0x0F, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(<span class="hljs-number">0x10</span>, codeSegemnt, &amp;HandleException0x10, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(<span class="hljs-number">0x11</span>, codeSegemnt, &amp;HandleException0x11, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(<span class="hljs-number">0x12</span>, codeSegemnt, &amp;HandleException0x12, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(<span class="hljs-number">0x13</span>, codeSegemnt, &amp;HandleException0x13, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br><br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(hardwareInterruptOffset + <span class="hljs-number">0x00</span>, codeSegemnt, &amp;HandleInterruptRequest0x00, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(hardwareInterruptOffset + <span class="hljs-number">0x01</span>, codeSegemnt, &amp;HandleInterruptRequest0x01, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(hardwareInterruptOffset + <span class="hljs-number">0x02</span>, codeSegemnt, &amp;HandleInterruptRequest0x02, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(hardwareInterruptOffset + <span class="hljs-number">0x03</span>, codeSegemnt, &amp;HandleInterruptRequest0x03, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(hardwareInterruptOffset + <span class="hljs-number">0x04</span>, codeSegemnt, &amp;HandleInterruptRequest0x04, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(hardwareInterruptOffset + <span class="hljs-number">0x05</span>, codeSegemnt, &amp;HandleInterruptRequest0x05, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(hardwareInterruptOffset + <span class="hljs-number">0x06</span>, codeSegemnt, &amp;HandleInterruptRequest0x06, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(hardwareInterruptOffset + <span class="hljs-number">0x07</span>, codeSegemnt, &amp;HandleInterruptRequest0x07, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(hardwareInterruptOffset + <span class="hljs-number">0x08</span>, codeSegemnt, &amp;HandleInterruptRequest0x08, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(hardwareInterruptOffset + <span class="hljs-number">0x09</span>, codeSegemnt, &amp;HandleInterruptRequest0x09, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(hardwareInterruptOffset + <span class="hljs-number">0x0A</span>, codeSegemnt, &amp;HandleInterruptRequest0x0A, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(hardwareInterruptOffset + <span class="hljs-number">0x0B</span>, codeSegemnt, &amp;HandleInterruptRequest0x0B, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(hardwareInterruptOffset + <span class="hljs-number">0x0C</span>, codeSegemnt, &amp;HandleInterruptRequest0x0C, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(hardwareInterruptOffset + <span class="hljs-number">0x0D</span>, codeSegemnt, &amp;HandleInterruptRequest0x0D, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(hardwareInterruptOffset + <span class="hljs-number">0x0E</span>, codeSegemnt, &amp;HandleInterruptRequest0x0E, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(hardwareInterruptOffset + <span class="hljs-number">0x0F</span>, codeSegemnt, &amp;HandleInterruptRequest0x0F, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(hardwareInterruptOffset + <span class="hljs-number">0x31</span>, codeSegemnt, &amp;HandleInterruptRequest0x31, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br><br>    picMasterCommand.<span class="hljs-built_in">Write</span>(<span class="hljs-number">0x11</span>);<br>    picSlaveCommand.<span class="hljs-built_in">Write</span>(<span class="hljs-number">0x11</span>);<br><br>    picMasterData.<span class="hljs-built_in">Write</span>(hardwareInterruptOffset);<br>    picSlaveData.<span class="hljs-built_in">Write</span>(hardwareInterruptOffset + <span class="hljs-number">0x8</span>);<br><br>    picMasterData.<span class="hljs-built_in">Write</span>(<span class="hljs-number">0x04</span>);<br>    picSlaveData.<span class="hljs-built_in">Write</span>(<span class="hljs-number">0x02</span>);<br><br>    picMasterData.<span class="hljs-built_in">Write</span>(<span class="hljs-number">0x01</span>);<br>    picSlaveData.<span class="hljs-built_in">Write</span>(<span class="hljs-number">0x01</span>);<br><br>    picMasterData.<span class="hljs-built_in">Write</span>(<span class="hljs-number">0x00</span>);<br>    picSlaveData.<span class="hljs-built_in">Write</span>(<span class="hljs-number">0x00</span>);<br><br>    InterruptorDescriptorTablePointer idt;<br>    idt.size = <span class="hljs-number">256</span> * <span class="hljs-built_in">sizeof</span>(GateDescriptor) - <span class="hljs-number">1</span>;<br>    idt.base = (<span class="hljs-type">uint32_t</span>)interruptDescriptorTable;<br><br>    <span class="hljs-function"><span class="hljs-keyword">asm</span> <span class="hljs-title">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;lidt %0&quot;</span> : : <span class="hljs-string">&quot;m&quot;</span> (idt))</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>InterruptManager的构造函数，主要是构造IDT以及开启8259芯片，8259芯片的问题我们放在后面讲。这里主要数一下构造IDT</p><p>首先，硬件offset为0x20，设定好256个空的门描述符。</p><p>由于我们设定好了17个中断以及20个异常，所以分别将我们设定好的内容填入到IDT中，这样在执行中断时，遇到我们设定好的中断号，就会执行相应设定好的函数，为设定的中断号则执行InterruptIgnore，这个函数可以去<code>interruptstubs.s</code>中查看，本质上什么都没看，就一个函数名。最后我们设定IDTR，将中断描述符数量以及IDT基地址加载进去。</p><p>前面说过，InterruptManager中的中断处理交由InterruptHandler来实现，在InterruptManager中也设定好256个中断处理数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">InterruptHandler* handlers[<span class="hljs-number">256</span>];<br></code></pre></td></tr></table></figure><p>这样我们就可以执行相应的中断了。</p><p>结合前面的DoHandleInterrupt函数我们可知，当相应的中断号传输过来之后，我们首先判断是否有相应的中断处理函数（这些中断处理函数是我们提前设定好的，比如键盘、鼠标），如果有，则去执行相应的中断，如果没有，则是打印<code>UNHANDLED INTERRUPT 0X</code>+中断号</p><p>这就是当前我们的处理逻辑，后续我们实现键盘以及鼠标中断之后，只需要继承InterruptHandler，然后在InterruptManager中的handlers数组中添加相应的内容即可。</p><h2 id="6、串联一下"><a href="#6、串联一下" class="headerlink" title="6、串联一下"></a>6、串联一下</h2><p>如何实现中断？</p><p>首先，设定好IDT以及IDTR;</p><p>然后，实现InterruptManager以及InterruptHandler类，InterruptHandler包含在InterruptManager中，负责处理中断</p><p>最后，中断触发，产生相应的中断号，系统根据中断号找到对应的中断处理函数，完成中断处理</p><h2 id="7、8259A"><a href="#7、8259A" class="headerlink" title="7、8259A"></a>7、8259A</h2><p>！！！本篇重点，干货满满</p><p>首先列出参考资料</p><p><a href="https://wiki.osdev.org/8259_PIC">资料1</a></p><p><a href="https://blog.csdn.net/longintchar/article/details/79439466">资料2</a></p><p><a href="http://www.brokenthorn.com/Resources/OSDevPic.html">资料3</a></p><p>8259芯片是x86体系结构中最重要的芯片之一，8259A芯片的主要功能是管理硬件中断并且发送中断信号去执行。</p><p>8259A的原理图如下：</p><p><img src="/2022/10/06/wyoos006/8259A.gif" alt="8259A"></p><p>其中的IR0到IR7与外部设备链接，每个管脚代表一种中断，中断信号就是从这里传输进来的。</p><p>由于8个中断无法满足操作系统的需求，设计者又增加了一块8259A芯片，我们称第一块芯片为主芯片(Master)，第二块芯片为从芯片(Slave)。从芯片连接在主芯片的IR2管脚，如下图所示：</p><p><img src="/2022/10/06/wyoos006/8259ATwochips.PNG" alt="8259ATwochips"></p><p>这样就扩展为15条中断，足够操作系统使用。</p><p>学习过中断的朋友们知道中断也是存在优先级的，高优先级的中断来会优先执行高优先级的内容。8259A芯片管脚从0-7中断优先级逐级下降，所以我们硬件中断的优先级IR0 &gt; IR1 &gt; IR8 &gt; IR9 &gt; …… &gt; IRC &gt; IR3 &gt; … &gt; IR7，IR2也存在，但不是独立存在，而是成为了从芯片的入口。</p><p>8259A存在两个端口，分别是指令端口(command)以及数据端口(data)为了控制8259A的主从芯片，操作系统设计者将两块芯片分别连接在如下端口中：</p><p><img src="/2022/10/06/wyoos006/8259port.PNG" alt="8259port"></p><p>看着是不是有些熟悉了，这就是我们在InterruptManager类的构造函数中设置的四个值。</p><p>我们通过对这四个端口的操作，就可以使8259A芯片正常工作。</p><h3 id="7-1、初始化命令字"><a href="#7-1、初始化命令字" class="headerlink" title="7.1、初始化命令字"></a>7.1、初始化命令字</h3><p>此处参考<a href="https://blog.csdn.net/longintchar/article/details/79439466">资料2</a>，非常感谢！大家给这个姐姐点个赞！</p><p>在8259A可以正常工作之前，必须首先设置初始化命令字 ICW (Initialization Command Words)寄存器组的内容。而在其工作过程中，则可以使用写入操作命令字 OCW (Operation Command Words)寄存器组来随时设置和管理8259A的工作方式。</p><p>观察8259A芯片管脚，存在一个A0端口，这个端口负责控制选择操作的寄存器<strong>当A0&#x3D;0时芯片的端口地址是0x20(主芯片)和0xA0(从芯片）；当 A0&#x3D;1时端口就是0x21(主芯片)和0xA1(从芯片)。</strong></p><p>初始化命令字的编程操作流程如下图所示。由图可以看出，对 ICW1和 ICW2 的设置是必需的。而只有当系统中包含多片 8259A 芯片并且是级联的情况下才需要对 ICW3 进行设置。这需要在 ICW1 的设置中明确指出。 另外，是否需要对 ICW4 进行设置也需要在 ICW1 中指明。<br><img src="/2022/10/06/wyoos006/init8259A.PNG" alt="init8259A"></p><h3 id="7-2、ICW1"><a href="#7-2、ICW1" class="headerlink" title="7.2、ICW1"></a>7.2、ICW1</h3><p>当发送的字节第 5 比特位(D4)&#x3D;1，并且地址线 A0&#x3D;0 时，表示是对 ICW1 编程。此时对于 PC&#x2F;AT 微机系统的多片级联情况下，8259A 主芯片的端口地址是 0x20，从芯片的端口地址是 0xA0。</p><p>ICW1表格如下：</p><p><img src="/2022/10/06/wyoos006/ICW1.png" alt="ICW1"></p><p>我们向ICW1中写入0x11，表示中断请求是边沿触发、多片 8259A 级联并且需要发送 ICW4。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">picMasterCommand.<span class="hljs-built_in">Write</span>(<span class="hljs-number">0x11</span>);<br>picSlaveCommand.<span class="hljs-built_in">Write</span>(<span class="hljs-number">0x11</span>);<br></code></pre></td></tr></table></figure><p>根据流程图，接下来我们需要设定ICW2</p><h3 id="7-3、ICW2"><a href="#7-3、ICW2" class="headerlink" title="7.3、ICW2"></a>7.3、ICW2</h3><p>ICW2 用于设置芯片送出的中断号的高5位。在设置了 ICW1 之后，当 A0&#x3D;1 时表示对 ICW2 进行设置。此时对于PC&#x2F;AT微机系统的多片级联情况下，8259A主芯片的端口地址是0x21，从芯片的端口地址是0xA1。</p><p>ICW2 格式如下:</p><p><img src="/2022/10/06/wyoos006/ICW2.PNG" alt="ICW2"></p><p>ICW2 用于设置芯片送出的中断号的高5位。在设置了 ICW1 之后，当 A0&#x3D;1 时表示对 ICW2 进行设置。此时对于PC&#x2F;AT微机系统的多片级联情况下，8259A主芯片的端口地址是0x21，从芯片的端口地址是0xA1。</p><p>我们的硬件中断是从0x20开始的，每个芯片可以相应8个中断，所以主芯片0x20-0x27，从芯片0x28-0x30。ICW2设定主从芯片的起始中断号，后面的内容由芯片自行填入，所以我们将两块芯片的起始终端号填入0x20以及0x28即可。由因为ICW2只读取终端号的高5位，后面3位置0，而0x20和0x28后3位恰好都是0，所以我们将0x20和0x28写入对应端口即可。这门看来中断号的设置并不是随意设置的，而是和每种芯片的工作原理也是相结合着设定的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">picMasterData.<span class="hljs-built_in">Write</span>(hardwareInterruptOffset);<br>picSlaveData.<span class="hljs-built_in">Write</span>(hardwareInterruptOffset + <span class="hljs-number">0x8</span>);<br></code></pre></td></tr></table></figure><h3 id="7-3、ICW3"><a href="#7-3、ICW3" class="headerlink" title="7.3、ICW3"></a>7.3、ICW3</h3><p>观察ICW1的第一位SNGL&#x3D;0，表示需要级联芯片，根据流程图可以看出我们需要设置ICW3</p><p>地址线A0&#x3D;1，主芯片的端口地址是0x21，从芯片的端口地址是0xA1。</p><p><code>ICW3 (for master device) indicates where the slave is connected to the master.</code></p><p><code>ICW3 (for slave device) indicates where the slave is connected to the master</code></p><p><img src="/2022/10/06/wyoos006/ICW3.PNG" alt="ICW3"></p><p>若8259为主片，ICW3用于指示哪个管脚与从片相连</p><p>哪一位为1，表明哪一位上有从片相连，<br>哪一位为0，表明哪一位上无从片相连。</p><p><code>IR2和从片相连则ICW3为00000100，即0x04</code></p><p><code>IR6和从片相连则ICW3为01000000，即0x40</code></p><p>若8259为从片，ICW3用于指示从片与主片的哪个引脚相连</p><p>相连的内容由后三位指示，高五位置零</p><p><code>和IR2相连则后三位为010,即0x02</code></p><p><code>和IR6相连则后三位为110,即0x06</code></p><p>所以我们要向主片中写入0x04，从片中写入0x02</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">picMasterData.<span class="hljs-built_in">Write</span>(<span class="hljs-number">0x04</span>);<br>picSlaveData.<span class="hljs-built_in">Write</span>(<span class="hljs-number">0x02</span>);<br></code></pre></td></tr></table></figure><h3 id="7-4、ICW4"><a href="#7-4、ICW4" class="headerlink" title="7.4、ICW4"></a>7.4、ICW4</h3><p>ICW1的第0位为1，表示需要设置ICW4</p><p>地址线A0&#x3D;1，主芯片的端口地址是0x21，从芯片的端口地址是0xA1。</p><p><img src="/2022/10/06/wyoos006/ICW4.PNG" alt="ICW4"></p><p>换一张中文图：</p><p><img src="/2022/10/06/wyoos006/ICW4Simple.PNG" alt="ICW4Simple"></p><p>我们向主从芯片中分别写入0x01，表示 8259A 芯片被设置成普通全嵌套、非缓冲、非自动结束中断方式，并且用于 8086 及其兼容系统。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">picMasterData.<span class="hljs-built_in">Write</span>(<span class="hljs-number">0x01</span>);<br>picSlaveData.<span class="hljs-built_in">Write</span>(<span class="hljs-number">0x01</span>);<br></code></pre></td></tr></table></figure><h2 id="8、操作命令字"><a href="#8、操作命令字" class="headerlink" title="8、操作命令字"></a>8、操作命令字</h2><p>在对 8259A 设置了初始化命令字后，芯片就已准备好接收设备的中断请求信号了。但在 8259A 工作期间，我们也可以利用操作命令字 OCW1~OCW3 来监测 8259A 的工作状况，或者随时改变初始化时设定的 8259A 的工作方式。</p><p>需要说明的是，与初始化命令字ICW1～ICW4需要按规定的顺序进行设置不同，操作命令字OCW1～OCW3的设置没有规定其先后顺序，使用时可根据需要灵活选择不同的操作命令字写入到8259A中。</p><h3 id="8-1、OCW1"><a href="#8-1、OCW1" class="headerlink" title="8.1、OCW1"></a>8.1、OCW1</h3><p>OCW1 用于对 8259A 中中断屏蔽寄存器 IMR 进行读&#x2F;写操作。地址线A0&#x3D;1</p><p>若 $M_i&#x3D;1$，则屏蔽对应中断请求级${IR}_i$；若$M_i&#x3D;0$，则允许${IR}_i$. 另外，屏蔽高优先级并不会影响其他低优先级的中断请求。</p><p><img src="/2022/10/06/wyoos006/OCW1.PNG" alt="OCW1"></p><p>这里由于我们不需要屏蔽任何的中断（时钟中断我们只是不做处理，而不是屏蔽，所以在这里不需要设置），所以我们向其中传入0x0</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">picMasterData.<span class="hljs-built_in">Write</span>(<span class="hljs-number">0x00</span>);<br>picSlaveData.<span class="hljs-built_in">Write</span>(<span class="hljs-number">0x00</span>);<br></code></pre></td></tr></table></figure><h3 id="8-2、OCW2"><a href="#8-2、OCW2" class="headerlink" title="8.2、OCW2"></a>8.2、OCW2</h3><p>由于ICW4中第1位AEOI我们设定为非自动结束方式，所以在执行中断之后，我们需要手动输入某些内容告诉8259A 中断已经结束。</p><p>这就使用到了OCW2</p><p><img src="/2022/10/06/wyoos006/OCW2.PNG" alt="OCW2"></p><p>这里是具体OCW2各位表示的内容</p><p><img src="/2022/10/06/wyoos006/OCW2Table.PNG" alt="OCW2Table"></p><p>Linux-0.11 内核仅使用该操作命令字在中断处理过程结束之前向 8259A 发送结束中断（EOI）命令。所使用的OCW2 值为 0x20，表示固定优先级、一般EOI（对应上表的第一行）。</p><p>也就是DoHandleInterrupt中的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> picMasterCommand.<span class="hljs-built_in">Write</span>(<span class="hljs-number">0x20</span>);<br><span class="hljs-keyword">if</span>(hardwareInterruptOffset + <span class="hljs-number">8</span> &lt;= InterruptNumber)&#123;<br>      picSlaveCommand.<span class="hljs-built_in">Write</span>(<span class="hljs-number">0x20</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的判断是在判断从片是否在使用，无论从片是否使用，主片都需要写入0x20</p><h3 id="8-3、OCW3"><a href="#8-3、OCW3" class="headerlink" title="8.3、OCW3"></a>8.3、OCW3</h3><p><a href="https://blog.csdn.net/longintchar/article/details/79439466">再次感谢姐姐</a></p><h2 id="9、总结"><a href="#9、总结" class="headerlink" title="9、总结"></a>9、总结</h2><p>本节内容较多，大家应该结合代码和视频参考资料多多学习，本人也是反复研究之后才写出这篇文章！</p>]]></content>
    
    
    
    <tags>
      
      <tag>wyoos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零开始的操作系统生活05-port</title>
    <link href="/2022/09/30/wyoos005/"/>
    <url>/2022/09/30/wyoos005/</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/anhongzhan/wyoos/tree/master/005">github</a></p><h2 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>操作系统想要实现键盘写入或者其他硬件的相关操作时，需要用到端口读写。</p><p>本节内容较为单一，也没有太多前置知识，主要实现向固定的端口中写入数据以及读取数据。</p><h2 id="2、code"><a href="#2、code" class="headerlink" title="2、code"></a>2、code</h2><p>新建文件<code>port.h</code>,<code>port.cpp</code></p><p>我们需要实现8Bit、16Bit以及32Bit数据的读写</p><p>首先是<code>port.h</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __PORT_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __PORT_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;types.h&quot;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Port</span>&#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">uint16_t</span> portnumber;<br>    <span class="hljs-built_in">Port</span>(<span class="hljs-type">uint16_t</span> portnumber);<br>    ~<span class="hljs-built_in">Port</span>();<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Port8Bit</span> : <span class="hljs-keyword">public</span> Port &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Port8Bit</span>(<span class="hljs-type">uint16_t</span> portnumber);<br>    ~<span class="hljs-built_in">Port8Bit</span>();<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> data)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">uint8_t</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Port16Bit</span> : <span class="hljs-keyword">public</span> Port &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Port16Bit</span>(<span class="hljs-type">uint16_t</span> portnumber);<br>    ~<span class="hljs-built_in">Port16Bit</span>();<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> data)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">uint16_t</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Port32Bit</span> : <span class="hljs-keyword">public</span> Port &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Port32Bit</span>(<span class="hljs-type">uint16_t</span> portnumber);<br>    ~<span class="hljs-built_in">Port32Bit</span>();<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> data)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">uint32_t</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>我们首先创建一个port类表示需要写入的端口，端口长度位16Bit，然后使用具体的8Bit，16Bit，32Bit的类继承并实现读写功能。</p><p>接下来是实现<code>port.cpp</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;port.h&quot;</span></span><br><br><br>Port::<span class="hljs-built_in">Port</span>(<span class="hljs-type">uint16_t</span> portnumber)<br>    : <span class="hljs-built_in">portnumber</span>(portnumber)&#123;&#125;<br><br>Port::~<span class="hljs-built_in">Port</span>() &#123;&#125;<br><br><span class="hljs-comment">//8Bit</span><br>Port8Bit::<span class="hljs-built_in">Port8Bit</span>(<span class="hljs-type">uint16_t</span> portnumber)<br>    : <span class="hljs-built_in">Port</span>(portnumber)&#123;&#125;<br><br>Port8Bit::~<span class="hljs-built_in">Port8Bit</span>() &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Port8Bit::Write</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> data)</span></span>&#123;<br>    <span class="hljs-function">__asm__ <span class="hljs-title">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;outb %0, %1&quot;</span> : : <span class="hljs-string">&quot;a&quot;</span> (data), <span class="hljs-string">&quot;Nd&quot;</span> (portnumber))</span></span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">uint8_t</span> <span class="hljs-title">Port8Bit::Read</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">uint8_t</span> data;<br>    <span class="hljs-function">__asm__ <span class="hljs-title">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;inb %1, %0&quot;</span> : <span class="hljs-string">&quot;=a&quot;</span> (data) : <span class="hljs-string">&quot;Nd&quot;</span> (portnumber))</span></span>;<br>    <span class="hljs-keyword">return</span> data;<br>&#125;<br><br><span class="hljs-comment">// 16 Bit</span><br>Port16Bit::<span class="hljs-built_in">Port16Bit</span>(<span class="hljs-type">uint16_t</span> portnumber)<br>    : <span class="hljs-built_in">Port</span>(portnumber)&#123;&#125;<br><br>Port16Bit::~<span class="hljs-built_in">Port16Bit</span>() &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Port16Bit::Write</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> data)</span></span>&#123;<br>    <span class="hljs-function">__asm__ <span class="hljs-title">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;outw %0, %1&quot;</span> : : <span class="hljs-string">&quot;a&quot;</span> (data) , <span class="hljs-string">&quot;Nd&quot;</span> (portnumber))</span></span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">uint16_t</span> <span class="hljs-title">Port16Bit::Read</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">uint16_t</span> data;<br>    <span class="hljs-function">__asm__ <span class="hljs-title">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;inw %1, %0&quot;</span> : <span class="hljs-string">&quot;=a&quot;</span> (data) : <span class="hljs-string">&quot;Nd&quot;</span> (portnumber))</span></span>;<br>    <span class="hljs-keyword">return</span> data;<br>&#125;<br><br><span class="hljs-comment">// 32Bit</span><br>Port32Bit::<span class="hljs-built_in">Port32Bit</span>(<span class="hljs-type">uint16_t</span> portnumber)<br>    : <span class="hljs-built_in">Port</span>(portnumber)&#123;&#125;<br><br>Port32Bit::~<span class="hljs-built_in">Port32Bit</span>() &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Port32Bit::Write</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> data)</span></span>&#123;<br>    <span class="hljs-function">__asm__ <span class="hljs-title">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;outl %0, %1&quot;</span> : : <span class="hljs-string">&quot;a&quot;</span> (data) , <span class="hljs-string">&quot;Nd&quot;</span> (portnumber))</span></span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">Port32Bit::Read</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">uint32_t</span> data;<br>    <span class="hljs-function">__asm__ <span class="hljs-title">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;inl %1, %0&quot;</span> : <span class="hljs-string">&quot;=a&quot;</span> (data) : <span class="hljs-string">&quot;Nd&quot;</span> (portnumber))</span></span>;<br>    <span class="hljs-keyword">return</span> data;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们这里仍然采用内嵌汇编的方法实现功能，其中<code>outb</code>以及<code>inb</code>分别表示向固定的端口写入以及读取端口数据</p><h2 id="3、slow-write"><a href="#3、slow-write" class="headerlink" title="3、slow write"></a>3、slow write</h2><p>最后，我们需要实现一个<strong>慢写入</strong>，这里面由于未查到资料，所以并不清楚实现慢写入的原因，暂时码住。</p><p><code>port.h</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Port8BitSlow</span> : <span class="hljs-keyword">public</span> Port8Bit &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Port8BitSlow</span>(<span class="hljs-type">uint16_t</span> portnumber);<br>    ~<span class="hljs-built_in">Port8BitSlow</span>();<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> data)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>port.cpp</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Port8BitSlow::<span class="hljs-built_in">Port8BitSlow</span>(<span class="hljs-type">uint16_t</span> portnumber)<br>    : <span class="hljs-built_in">Port8Bit</span>(portnumber)&#123;&#125;<br><br>Port8BitSlow::~<span class="hljs-built_in">Port8BitSlow</span>() &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Port8BitSlow::Write</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> data)</span></span>&#123;<br>    <span class="hljs-function">__asm__ <span class="hljs-title">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;outb %0, %1\njmp 1f\n1: jmp 1f\n1:&quot;</span> : : <span class="hljs-string">&quot;a&quot;</span> (data) , <span class="hljs-string">&quot;Nd&quot;</span> (portnumber))</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，慢写入的汇编语句如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">outb</span> data, portnumber<br><span class="hljs-attribute">jmp</span> <span class="hljs-number">1</span>f<br><span class="hljs-attribute">1</span>: jmp <span class="hljs-number">1</span>f<br><span class="hljs-attribute">1</span>:<br></code></pre></td></tr></table></figure><p>上面的data以及portnumber不是真实的汇编语句，这里只是为了说明汇编语句的操作，而且主要目的是介绍下面的内容</p><p><code>jmp 1f</code>，f表示向下跳转，跳转到1这个位置，到达1这个位置之后又出现了一句<code>jmp 1f</code>，再次向下跳转无汇编语句，执行结束。</p><p>我们通过两次跳转指令实现了慢写入，也就是在执行<code>outb</code>汇编指令之后做一些无用功，然后再返回，应该是为了等待一些工作的完成。</p>]]></content>
    
    
    
    <tags>
      
      <tag>wyoos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零开始的操作系统生活04-GDT</title>
    <link href="/2022/09/26/wyoos004/"/>
    <url>/2022/09/26/wyoos004/</url>
    
    <content type="html"><![CDATA[<p>本节代码地址<a href="https://github.com/anhongzhan/wyoos/tree/master/004">github</a></p><h2 id="1、从实模式到保护模式"><a href="#1、从实模式到保护模式" class="headerlink" title="1、从实模式到保护模式"></a>1、从实模式到保护模式</h2><p><a href="https://wiki.osdev.org/Real_Mode">实模式(Real mode)</a>是x86处理器中的一种16位的寻址方式，但是x86处理器的物理地址有20位，为了实现20位的寻址，x86处理器采用了基地址(base)+偏移量(offset)的方法进行寻址，具体的寻址方式 base&lt;&lt; 4 + offset，寻址空间有$$2^{20}$$一共1MB的地址空间，这对于早期的处理器来说足够使用了，但随着技术的发展，逐渐出现了两个问题：</p><ul><li>地址空间逐渐不足</li><li>非法访问内存问题</li></ul><p>地址空间不足问题很好理解，程序主键变得复杂，需要的空间会逐渐增加。对于非法访问内存，实模式下的内存访问方式可以访问任何一块内存，但是实际上很多内容比如内核代码和数据等是不允许访问或者修改的，所以就需要对内存进行规划，于是就出现了<a href="https://wiki.osdev.org/Protected_Mode">保护模式(Protected Mode)</a>。</p><p>保护模式采用32位的寻址方式，理论的寻址空间有4GB，这样就可以解决地址空间不足的问题。对于内存非法访问的问题，保护模式将内存划分为不同的段(Segment)，比如代码段、数据段、栈段等等，不同的段有不同的访问权限。保护模式下的寻址方式依旧采用基地址+偏移的方式，不过基地址的获取改成了通过GDT来获取，通过GDT就可以对内存访问进行限制，完美的解决非法访问内存问题。</p><h2 id="2、访问GDT"><a href="#2、访问GDT" class="headerlink" title="2、访问GDT"></a>2、访问GDT</h2><p><a href="https://wiki.osdev.org/GDT">Global Descriptor Table</a>，简称GDT，中文名为全局描述符表。</p><p>首先，GDT是一项数据结构，从名称table就可以知道GDT是一张表，表中肯定存储很多数据，每条数据就是一个描述符(descriptor)。</p><p>然后，这张表肯定要存储到某块内存，如何寻址到这块内存，就需要访问GDTR，R是register的意思，这个寄存器专门存储GDT表的内存地址以便访问。我们可以使用汇编语句lgdt对GDTR进行加载。</p><p><img src="/2022/09/26/wyoos004/GDTR.PNG" alt="GDTR"></p><p>GDTR是一个48位的数据结构，高32位存储GDT的地址，低16位存储表的尺寸，记录了表的存储项，同时也规定了最大的表的数量</p><p>其次，具体的访问方式。操作系统中指定下一条指令的寄存器为cs+eip，cs存储基地址，eip存储偏移。cs的访问方式转换为段选择子(Segment Selector)的访问方式：</p><p><img src="/2022/09/26/wyoos004/SegmentSelector.PNG" alt="SegmentSelector"></p><p>cs是16位的寄存器，最低的两位RPL，全称是Requested Privilege Level，表示访问权限，用两位数据表示说明最多有4个访问权限。</p><p>接下来的TI位表示需要访问GDT还是LDT，Index表示需要访问GDT的表项，即GDT中的第Index项。这样，通过访问GDT得到基地址即可。</p><h2 id="3、柳暗花明，终于开始访问GDT了"><a href="#3、柳暗花明，终于开始访问GDT了" class="headerlink" title="3、柳暗花明，终于开始访问GDT了"></a>3、柳暗花明，终于开始访问GDT了</h2><p>GDT中的表项叫做段描述符(Segment Descriptor)，我们所访问的内容就是第Index个描述符，下面是描述符的数据结构：</p><p><img src="/2022/09/26/wyoos004/SegmentDescriptor.PNG" alt="SegmentDescriptor"></p><p>段描述符是一个64位的数据结构，从具体的表项可以看出，我们可以拼出一个32位的基地址Base，这样就可以与偏移Offset结合得到访问地址。</p><p>其他的表项内容请大家自行学习，而且是必须学会的，本人也在学习过程中，所以这里不做展开。</p><h2 id="4、串联一下"><a href="#4、串联一下" class="headerlink" title="4、串联一下"></a>4、串联一下</h2><p>首先我们将GDT表填好并放在某块内存，通过lgdt指令设定GDTR，以便访问GDT。</p><p>设定好cs+eip寄存器的内容，cs通过段选择子(Segment Selector)找出需要访问GDT的哪一项。</p><p>然后我们根据GDTR找到相对应的段描述符(Segment Descriptor)，通过描述符的内容可以找出基地址(BASE)</p><p>这里面基地址直接与偏移offset相加即可。</p><p>这样我们就能跳转到下一条指令了。</p><h2 id="5、该写代码了"><a href="#5、该写代码了" class="headerlink" title="5、该写代码了"></a>5、该写代码了</h2><p>新建文件<code>gdt.h</code>、<code>gdt.cpp</code>、<code>types.h</code></p><p>首先是types.h，这里面主要将一些常用的数据结构设定为操作系统中常用的形式，内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __TYPES_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __TYPES_H</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> <span class="hljs-type">int8_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> <span class="hljs-type">uint8_t</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">short</span> <span class="hljs-type">int16_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">uint16_t</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> <span class="hljs-type">int32_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-type">uint32_t</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-type">int64_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-type">uint64_t</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>然后是gdt.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __GDT_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __GDT_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;types.h&quot;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GlobalDescriptorTable</span>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">SegementDescriptor</span>&#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SegementDescriptor</span>(<span class="hljs-type">uint32_t</span> base, <span class="hljs-type">uint32_t</span> limit, <span class="hljs-type">uint8_t</span> type);<br><br>    <span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">Base</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">Limit</span><span class="hljs-params">()</span></span>;<br><br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">uint16_t</span> limit_lo;<br>    <span class="hljs-type">uint16_t</span> base_lo;<br>    <span class="hljs-type">uint8_t</span> base_hi;<br>    <span class="hljs-type">uint8_t</span> type;<br>    <span class="hljs-type">uint8_t</span> flags_limit_hi;<br>    <span class="hljs-type">uint8_t</span> base_vhi;<br>  &#125; __attribute__((packed));<br><br>  SegementDescriptor nullSegmentDescriptor;<br>  SegementDescriptor unusedSegmentDescriptor;<br>  SegementDescriptor codeSegmentDescriptor;<br>  SegementDescriptor dataSegmentDescriptor;<br><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">GlobalDescriptorTable</span>();<br>  ~<span class="hljs-built_in">GlobalDescriptorTable</span>();<br><br>  <span class="hljs-function"><span class="hljs-type">uint16_t</span> <span class="hljs-title">CodeSegmentSelector</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">uint16_t</span> <span class="hljs-title">DataSegmentSelector</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>GDT的基地址、limit以及type数据外部数据可能会访问，所以设定为public</p><p>其他的位的数据则设定位private，<code>__attribute__((packed))</code>作用是告诉编译器取消结构在编译过程中的优化对齐，<a href="https://zhuanlan.zhihu.com/p/30007037">内存对齐参考</a></p><p>其他的还有一些空描述符（GDT的第0项就是空描述符），不可用描述符（暂时未接触到），数据段描述符、代码段描述符（这两部分可以参考S位以及type位的类型，就可以知道不同的段代表不同的内容）。</p><p>接下来使用<code>gdt.cpp</code>进行实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;gdt.h&quot;</span></span><br><br>GlobalDescriptorTable::<span class="hljs-built_in">GlobalDescriptorTable</span>()<br>  : <span class="hljs-built_in">nullSegmentDescriptor</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>),<br>  <span class="hljs-built_in">unusedSegmentDescriptor</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>),<br>  <span class="hljs-built_in">codeSegmentDescriptor</span>(<span class="hljs-number">0</span>, <span class="hljs-number">64</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>, <span class="hljs-number">0x9a</span>),<br>  <span class="hljs-built_in">dataSegmentDescriptor</span>(<span class="hljs-number">0</span>, <span class="hljs-number">64</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>, <span class="hljs-number">0x92</span>)&#123;<br>    <span class="hljs-type">uint32_t</span> i[<span class="hljs-number">2</span>];<br>    i[<span class="hljs-number">1</span>] = (<span class="hljs-type">uint32_t</span>)<span class="hljs-keyword">this</span>;<br>    i[<span class="hljs-number">0</span>] = <span class="hljs-built_in">sizeof</span>(GlobalDescriptorTable) &lt;&lt; <span class="hljs-number">16</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">asm</span> <span class="hljs-title">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;lgdt (%0)&quot;</span>: :<span class="hljs-string">&quot;p&quot;</span> (((<span class="hljs-type">uint8_t</span> *)i) + <span class="hljs-number">2</span>))</span></span>;<br>&#125;<br><br>GlobalDescriptorTable::~<span class="hljs-built_in">GlobalDescriptorTable</span>() &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">uint16_t</span> <span class="hljs-title">GlobalDescriptorTable::DataSegmentDescriptor</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> (<span class="hljs-type">uint8_t</span>*)&amp;dataSegmentDescriptor - (<span class="hljs-type">uint8_t</span>*)<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">uint16_t</span> <span class="hljs-title">GlobalDescriptorTable::CodeSegmentDescriptor</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">return</span> (<span class="hljs-type">uint8_t</span>*)&amp;codeSegmentDescriptor - (<span class="hljs-type">uint8_t</span>*)<span class="hljs-keyword">this</span>;<br>&#125;<br><br>GlobalDescriptorTable::SegementDescriptor::<span class="hljs-built_in">SegementDescriptor</span>(<span class="hljs-type">uint32_t</span> base, <span class="hljs-type">uint32_t</span> limit, <span class="hljs-type">uint8_t</span> type)&#123;<br>  <span class="hljs-type">uint8_t</span>* target = (<span class="hljs-type">uint8_t</span>*)<span class="hljs-keyword">this</span>;<br><br>  <span class="hljs-keyword">if</span>(limit &lt; <span class="hljs-number">65536</span>)&#123;<br>    target[<span class="hljs-number">6</span>] = <span class="hljs-number">0x40</span>;<br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">if</span>((limit &amp; <span class="hljs-number">0xfff</span>) != <span class="hljs-number">0xfff</span>)&#123;<br>      limit = (limit &gt;&gt; <span class="hljs-number">12</span>) - <span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>      limit = limit &gt;&gt; <span class="hljs-number">12</span>;<br>    &#125;<br>    target[<span class="hljs-number">6</span>] = <span class="hljs-number">0xC0</span>;<br>  &#125;<br><br>  <span class="hljs-comment">//limit</span><br>  target[<span class="hljs-number">0</span>] = limit &amp; <span class="hljs-number">0xff</span>;<br>  target[<span class="hljs-number">1</span>] = (limit &gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xff</span>;<br>  target[<span class="hljs-number">6</span>] = (limit &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xf</span>;<br><br>  <span class="hljs-comment">//base</span><br>  target[<span class="hljs-number">2</span>] = base &amp; <span class="hljs-number">0xff</span>;<br>  target[<span class="hljs-number">3</span>] = (base &gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xff</span>;<br>  target[<span class="hljs-number">4</span>] = (base &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xff</span>;<br>  target[<span class="hljs-number">7</span>] = (base &gt;&gt; <span class="hljs-number">24</span>) &amp; <span class="hljs-number">0xff</span>;<br><br>  <span class="hljs-comment">//type</span><br>  target[<span class="hljs-number">5</span>] = type;<br>&#125;<br><br><span class="hljs-type">uint32_t</span> GlobalDescriptorTable::SegementDescriptor::<span class="hljs-built_in">Base</span>()&#123;<br>  <span class="hljs-type">uint8_t</span>* target = (<span class="hljs-type">uint8_t</span>*)<span class="hljs-keyword">this</span>;<br>  <span class="hljs-type">uint32_t</span> result = target[<span class="hljs-number">7</span>];<br>  result = (result &lt;&lt; <span class="hljs-number">8</span>) + target[<span class="hljs-number">4</span>];<br>  result = (result &lt;&lt; <span class="hljs-number">8</span>) + target[<span class="hljs-number">3</span>];<br>  result = (result &lt;&lt; <span class="hljs-number">8</span>) + target[<span class="hljs-number">2</span>];<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-type">uint32_t</span> GlobalDescriptorTable::SegementDescriptor::<span class="hljs-built_in">Limit</span>()&#123;<br>  <span class="hljs-type">uint8_t</span>* target = (<span class="hljs-type">uint8_t</span>*)<span class="hljs-keyword">this</span>;<br>  <span class="hljs-type">uint32_t</span> result = target[<span class="hljs-number">6</span>] &amp; <span class="hljs-number">0xf</span>;<br>  result = (result &lt;&lt; <span class="hljs-number">8</span>) + target[<span class="hljs-number">1</span>];<br>  result = (result &lt;&lt; <span class="hljs-number">8</span>) + target[<span class="hljs-number">0</span>];<br><br>  <span class="hljs-keyword">if</span>((target[<span class="hljs-number">6</span>] &amp; <span class="hljs-number">0xC0</span>) == <span class="hljs-number">0xC0</span>)&#123;<br>    result = (result &lt;&lt; <span class="hljs-number">12</span>) | <span class="hljs-number">0xfff</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，下面的部分是在设定GDTR，GDTR前32位表示GDT的基地址，后16位代表GDT中表项的内容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">uint32_t</span> i[<span class="hljs-number">2</span>];<br>i[<span class="hljs-number">1</span>] = (<span class="hljs-type">uint32_t</span>)<span class="hljs-keyword">this</span>;<br>i[<span class="hljs-number">0</span>] = <span class="hljs-built_in">sizeof</span>(GlobalDescriptorTable) &lt;&lt; <span class="hljs-number">16</span>;<br><span class="hljs-function"><span class="hljs-keyword">asm</span> <span class="hljs-title">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;lgdt (%0)&quot;</span>: :<span class="hljs-string">&quot;p&quot;</span> (((<span class="hljs-type">uint8_t</span> *)i) + <span class="hljs-number">2</span>))</span></span>;<br></code></pre></td></tr></table></figure><p><code>asm</code>是cpp中使用汇编语句，<code>volatile</code>是防止汇编语句被编译器优化掉，内嵌汇编的具体格式为：</p><p>(“指令列表”:”输出列表”:”输入列表”:”破坏描述部分”);注意，括号中的冒号缺一不可，没有输入或者输出可以空着</p><p><code>%0 %1</code>代表出现的第一个第二个寄存器名，<code>p</code>表示下面的操作数是一个合法的地址。</p><p>下面的函数都是通过GDT表的具体表项，将需要的数据拼接出来，比如<code>Base()</code>函数就是将段描述符中的三部分拼接到一起得到的。</p><p>其他的内容也是如此，段描述符函数<code>SegementDescriptor</code>需要参考段描述符每一位代表的内容，所以需要进行判断是否大于65536等内容。</p><h2 id="6、还有Makefile"><a href="#6、还有Makefile" class="headerlink" title="6、还有Makefile"></a>6、还有Makefile</h2><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">objects</span> <span class="hljs-operator">=</span> loader.o kernel.o gdt.o<br></code></pre></td></tr></table></figure><p>在objects后面增加gdt.o即可，然后进行编译即可、</p><h2 id="7、运行结果"><a href="#7、运行结果" class="headerlink" title="7、运行结果"></a>7、运行结果</h2><p>由于我们只是将GDT建立起来而没有使用，所以运行结果不会有任何区别，只要不报错就算成功！</p><h2 id="8、补充"><a href="#8、补充" class="headerlink" title="8、补充"></a>8、补充</h2><p>从实模式到保护模式是操作系统中非常精彩的内容，请大家多查阅一些资料学习一下！</p>]]></content>
    
    
    
    <tags>
      
      <tag>wyoos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零开始的操作系统生活03-镜像制作</title>
    <link href="/2022/09/21/wyoos003/"/>
    <url>/2022/09/21/wyoos003/</url>
    
    <content type="html"><![CDATA[<h2 id="0、环境配置"><a href="#0、环境配置" class="headerlink" title="0、环境配置"></a>0、环境配置</h2><p>安装grub-legacy与xorriso，最后我们会将制作好的镜像放入虚拟机中运行，而不是在虚拟机中再安装一个虚拟机运行</p><p>但是安装grub-legacy时会发现报错了，原因应该是因为版本迭代问题导致的，最新的安装包名称应该是grub-efi-amd64</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> install grub-efi-amd64 xorriso<br></code></pre></td></tr></table></figure><p><a href="https://github.com/anhongzhan/wyoos/tree/master/003">github</a></p><h2 id="1、mykernel-iso"><a href="#1、mykernel-iso" class="headerlink" title="1、mykernel.iso"></a>1、mykernel.iso</h2><p>我们在使用虚拟机安装ubuntu系统的时候，选择的虚拟盘都是.iso后缀格式的，ISO文件是光盘的镜像文件，所有我们要做的事情就是将我们目前所写的内容转换成ISO镜像然后使用虚拟机打开即可</p><p><a href="https://www.gnu.org/software/grub/">GRUB</a>是一款multiboot loader，在链接中我们可以看到，grub-legacy已经不再维护了，所以我们需要安装替代的包，前面我们提过loader使用multiboot规范，multiboot规范对应的就是Multiboot loader</p><p><a href="https://www.gnu.org/software/xorriso/">xorriso</a>是一个用来创建和操作ISO 9660文件系统映像文件的工具，可以用来将影响文件烧录到DVD&#x2F;CD中</p><p>接下来开始制作镜像</p><p>我们在Makefile中添加如下语句：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">mykernel.iso: mykernel.bin<br><span class="hljs-built_in">mkdir</span> iso<br><span class="hljs-built_in">mkdir</span> iso/boot<br><span class="hljs-built_in">mkdir</span> iso/boot/grub<br><span class="hljs-built_in">cp</span> $&lt; iso/boot/<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;set timeout=0&#x27;</span> &gt;&gt; iso/boot/grub/grub.cfg<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;set default=0&#x27;</span> &gt;&gt; iso/boot/grub/grub.cfg<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;&#x27;</span> &gt;&gt; iso/boot/grub/grub.cfg<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;menuentry &quot;My Operating System&quot; &#123;&#x27;</span> &gt;&gt; iso/boot/grub/grub.cfg<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;multiboot /boot/mykernel.bin&#x27;</span> &gt;&gt; iso/boot/grub/grub.cfg<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;boot&#x27;</span> &gt;&gt; iso/boot/grub/grub.cfg<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;&#125;&#x27;</span> &gt;&gt; iso/boot/grub/grub.cfg<br>grub-mkrescue --output=<span class="hljs-variable">$@</span> iso<br><span class="hljs-built_in">rm</span> -rf iso<br></code></pre></td></tr></table></figure><p>前三句命令负责创建对应文件夹，**$&lt;**表示第一个依赖文件，也就是把mykernel.bin复制到&#x2F;iso&#x2F;boot&#x2F;文件夹中去</p><p>grub是引导操作系统的程序，他会根据自己的配置文件去引导内核，这项配置文件就是grub.cfg</p><p><em>set timeout&#x3D;0</em>是设置启动等待的时间，加入我们的电脑存在两个系统，设置timeout&#x3D;10，则进入系统之前会给我们10s的时间去选择进入哪一个系统</p><p><em>set default&#x3D;0</em>表示设置默认进入的系统，计算机都是从0开始的，也就是默认进入第一个系统。当然，我们也只有这一个系统</p><p><em>menuentry</em>指设置启动菜单，<em>My Operating System</em>是菜单名称，<em>multiboot &#x2F;boot&#x2F;mykernel.bin</em>是指其中的一个启动项</p><p><strong>下面的<em>boot</em>不清楚是干什么的，暂时码住，以后有机会回来解释</strong></p><p>运行结束后的grub.cfg内容如下所示：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">set</span> <span class="hljs-attribute">timeout</span>=0<br><span class="hljs-built_in">set</span> <span class="hljs-attribute">default</span>=0<br><br>menuentry <span class="hljs-string">&quot;My Operating System&quot;</span> &#123;<br>multiboot /boot/mykernel.bin<br>boot<br>&#125;<br><br></code></pre></td></tr></table></figure><p>像看到这个文件内容则需要删除makefile的最后一句rm -rf iso，但是记得下一次编译的时候加上这句话并且先把iso文件夹删除掉</p><p>最后<em>grub-mkrescue --output&#x3D;$@ iso</em>则是使用grub-mkrescue命令制作镜像文件，–output是指定输出文件，<strong>但是后面的iso我并不清楚是什么作用，如果是指定文件夹，那么生成的mykernel.iso会在&#x2F;iso中，但实际上是与&#x2F;iso同名文件夹，也不需要修改文件的后缀，甚至稍作修改也不会出现问题，此处码住，有待解决</strong></p><p>最后的<em>rm -rf iso</em>就是删除无用的文件夹</p><h2 id="2、打开mykernel-iso"><a href="#2、打开mykernel-iso" class="headerlink" title="2、打开mykernel.iso"></a>2、打开mykernel.iso</h2><p>激动人心的时刻到了，我们经过了三节的努力，终于可以看到一些成果了</p><p>首先，本人使用的是virtualbox虚拟机安装的ubuntu 20.04系统，生成的iso镜像文件也在ubuntu系统中，想要再次使用虚拟机运行则需要将iso文件拷贝到windows系统中，这部分使用共享文件夹或者直接拖动即可，大家根据自身情况自行解决这个问题</p><p>然后打开VirtualBox，选择新建</p><p><img src="/2022/09/21/wyoos003/newVirtual.PNG" alt="newVirtual"></p><p>操作系统类型和版本要选择Other</p><p>点击下一步之后打开虚拟机，然后选择设备-&gt;分配光驱-&gt;选择虚拟盘</p><p><img src="/2022/09/21/wyoos003/open.png" alt="open"></p><p>然后将我们制作好的iso镜像添加进去，关闭虚拟机后再次开启即可。</p><p>最后的运行效果如下：</p><p><img src="/2022/09/21/wyoos003/result.png" alt="result"></p><h2 id="3、补充"><a href="#3、补充" class="headerlink" title="3、补充"></a>3、补充</h2><h3 id="3-1、timeout"><a href="#3-1、timeout" class="headerlink" title="3.1、timeout"></a>3.1、timeout</h3><p>大家也可以试试修改Makefile中的set timeout&#x3D;10，然后再运行看看结果</p><h3 id="3-2、VirtualBox虚拟机中使用VirtualBox"><a href="#3-2、VirtualBox虚拟机中使用VirtualBox" class="headerlink" title="3.2、VirtualBox虚拟机中使用VirtualBox"></a>3.2、VirtualBox虚拟机中使用VirtualBox</h3><p>为了方便运行我们的结果，而不是来回调换系统运行调试，并且在参考视频的提示下，我们最终选择使用VIrtualBox虚拟机中再安装VirtualBox虚拟机</p><p>首先我的ubuntu虚拟机配置 8192MB 显存 16MB</p><p>在ubuntu中安装VirtualBox之前记得设置windows的VirtualBox中的<strong>启用嵌套VT-x&#x2F;AMD-V</strong></p><p>具体设置方式如下：设置-&gt;系统-&gt;处理器-&gt;启用嵌套VT-x&#x2F;AMD-V</p><p>如果<strong>启用嵌套VT-x&#x2F;AMD-V</strong>是灰色的，请参考<a href="https://www.cnblogs.com/88223100/p/How_to_enable_Nested_VT-x_AMD-V_on_VirtualBox.html">链接</a></p><p>然后虚拟机中安装VirtualBox</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> install VirtualBox<br></code></pre></td></tr></table></figure><p>安装完毕之后打开VIrtualBox，然后和前面的流程相同，创建新的虚拟电脑，不添加镜像，启动虚拟电脑然后添加镜像，最后重启虚拟电脑即可。</p><p>最后的最后，我们在Makefile中添加内容</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-built_in">run</span>: mykernel.iso<br>(killall virtualboxvm &amp;&amp; <span class="hljs-built_in">sleep</span> <span class="hljs-number">1</span>) || <span class="hljs-literal">true</span><br>virtualboxvm --startvm <span class="hljs-string">&quot;wyoos&quot;</span> &amp;<br></code></pre></td></tr></table></figure><p>这样每次我们编译完成后只要执行<strong>make run</strong>即可</p>]]></content>
    
    
    
    <tags>
      
      <tag>wyoos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零开始的操作系统生活02-对Hello World的补充</title>
    <link href="/2022/09/20/wyoos002/"/>
    <url>/2022/09/20/wyoos002/</url>
    
    <content type="html"><![CDATA[<h2 id="1、开始"><a href="#1、开始" class="headerlink" title="1、开始"></a>1、开始</h2><p><a href="https://github.com/anhongzhan/wyoos/tree/master/002">github</a></p><h3 id="1-1、环境配置"><a href="#1-1、环境配置" class="headerlink" title="1.1、环境配置"></a>1.1、环境配置</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">sudo apt-get <span class="hljs-keyword">install </span>g++ <span class="hljs-keyword">binutils </span>libc6-dev-i386<br></code></pre></td></tr></table></figure><h3 id="1-2、对linker-ld的补充"><a href="#1-2、对linker-ld的补充" class="headerlink" title="1.2、对linker.ld的补充"></a>1.2、对linker.ld的补充</h3><p>linker脚本是用来控制link过程的文件，文件中包含内容为linker的处理命令，主要用于描述输入文件到输出文件时各个内容的分步以及内存映射等</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">ENTRY(<span class="hljs-params">loader</span>)</span><br><span class="hljs-constructor">OUTPUT_FORMAT(<span class="hljs-params">elf32</span>-<span class="hljs-params">i386</span>)</span><br><span class="hljs-constructor">OUTPUT_ARCH(<span class="hljs-params">i386</span>:<span class="hljs-params">i386</span>)</span><br><br>SECTIONS<br>&#123;<br>  . = <span class="hljs-number">0x0100000</span>;<br><br>  .text : <br>  &#123;<br>    *(.multiboot)<br>    *(.text*)<br>    *(.rodata)<br>  &#125;<br><br>  .data :<br>  &#123;<br>    start_ctors = .;<br>    <span class="hljs-constructor">KEEP(<span class="hljs-operator">*</span>( .<span class="hljs-params">init_array</span> )</span>);<br>    <span class="hljs-constructor">KEEP(<span class="hljs-operator">*</span>(SORT_BY_INIT_PRIORITY( .<span class="hljs-params">init_array</span>.<span class="hljs-operator">*</span> )</span>));<br>    end_ctors = .;<br><br>    *(.data)<br>  &#125;<br><br>  .bss :<br>  &#123;<br>    *(.bss)<br>  &#125;<br><br>  /DISCARD/ : <br>  &#123;<br>    *(.fini_array*)<br>    *(.comment)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-2-1、首地址设置"><a href="#1-2-1、首地址设置" class="headerlink" title="1.2.1、首地址设置"></a>1.2.1、首地址设置</h4><p>首先是.SECTION{}中第一句*. &#x3D; 0x0100000;*</p><p>这句话的意思是设置我们所要输出的文件的字段的起始地址，比如我们将地址设置为0x100000，则后面的.text段就从该地址开始放置，紧接着是.data段和.bss段，同样我们也可以使用如下方法：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">. </span>= 0x010000;<br><span class="hljs-title">.text : </span><br>&#123;<br>&#125;<br><span class="hljs-bullet">. </span>= 0x080000;<br><span class="hljs-title">.data :</span><br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>将不同的段放置在不同的区域</p><h4 id="1-2-2、data段的设置"><a href="#1-2-2、data段的设置" class="headerlink" title="1.2.2、data段的设置"></a>1.2.2、data段的设置</h4><p>接下来是.data段中的内容，ELF文件中对于.data段的描述是：<em>已初始化的全局和静态C变量</em></p><p>在调用KernelMain方法之前，我们还需要的一个步骤就是保证初始化必要的全局变量，这些全局变量存放在**.init_array**段中。</p><p>为了完成以上操作，我们还需要在Kernel.cpp中添加初始化函数<strong>callConstructors()<strong>，该函数获取</strong>.init_array</strong>段中的指令</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">typedef <span class="hljs-title">void</span> (<span class="hljs-params">*constructor</span>)()</span>;<br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> constructor start_ctors;<br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> constructor end_ctors;<br><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">callConstructors</span>()</span>&#123;<br>    <span class="hljs-keyword">for</span>(constructor* i = &amp;start_ctors; i != &amp;end_ctors; i++)&#123;<br>        (*i)();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>这里面其实我也不是很清楚内部的运行机制，暂时码住，以后遇到答案之后再回来做出解释</strong></p><p><em>补充一：kernel.cpp中两个函数start_ctors与end_stors获取到linker.ld中的两个位置，然后执行linker.ld两个位置之间的命令（代码）</em></p><p>还记得我们前面说过，在<strong>loader.s</strong>中需要暴漏<strong>KernelMain</strong>的地址让链接器知道吗？同理，我们也需要暴漏<strong>callConstructors</strong>的地址，也就是在<strong>loader.s</strong>中添加如下代码：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">.section</span> <span class="hljs-string">.text</span><br><span class="hljs-string">.extern</span> kernelMain<br><span class="hljs-string">.extern</span> callConstructors<br><span class="hljs-string">.global</span> loader<br></code></pre></td></tr></table></figure><p>第三行代码为我们刚刚所添加的内容</p><p>最后我们来看.data段中的内容，第一句与最后一句分别为start_ctors和end_ctors，这两部分是链接器指定的两个具体地址，然后将初始化指令，也就是.data段中的数据放置在这两段地址之间，也就是说链接器指定了一段空间用于存放.data段的数据，也就是**.init_array*<em>，前面提到过，</em>KEEP的作用是即使为引用符号，我们也要保留这部分*，另一种解释方法就是KEEP函数可以保证数据不被系统释放，属于对全局变量的保护，也可能是出于对程序生命周期的考虑。</p><p><strong>SORT_BY_INIT_PRIORITY</strong>函数会对**.init_array**中的数据以升序的方式进行排序，然后再放置到输出文件中</p><h4 id="1-2-3、-x2F-DISCARD-x2F"><a href="#1-2-3、-x2F-DISCARD-x2F" class="headerlink" title="1.2.3、&#x2F;DISCARD&#x2F;"></a>1.2.3、&#x2F;DISCARD&#x2F;</h4><p>放置在**&#x2F;DISCARD&#x2F;**段中的内容不会被链接器输出出去</p><h3 id="1-3、printf函数"><a href="#1-3、printf函数" class="headerlink" title="1.3、printf函数"></a>1.3、printf函数</h3><p>还记得上一节中我们写的<strong>kernel.cpp</strong>文件吗，里面调用了printf函数进行打印，但是我们并没有引入头文件，结果可想而知，肯定无法编译过去，报错内容如下：<em>identifier “printf” is undefined</em></p><p>printf函数本身就是调用操作系统的函数然后进行打印，所以我们不可以直接引入头文件进行编译，必须自己实现，实现的方法如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printf</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str)</span></span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> *VideoMemory = (<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>*)<span class="hljs-number">0xb8000</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;str[i];i++)&#123;<br>        VideoMemory[i] = (VideoMemory[i] &amp; <span class="hljs-number">0xFF00</span>) | str[i];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://wiki.osdev.org/Printing_To_Screen">0xb8000</a>是操作系统向屏幕写入数据的第一个地址，我们只需要将数据一次写入相应的地址，最后就能够打印出来</p><p>根据<a href="https://wiki.osdev.org/Printing_To_Screen">0xb8000</a>中的介绍，操作系统使用两个字节存储一个字符，第一个字节存储字符内容，第二个字节存储字符的颜色，我们这里不关心颜色，所以只需要将每一个低位字节置零之后将要写入的字符“与”进去即可。</p><p>同时我们也需要注意大端和小端的问题！！！</p><p>也就是<strong>VideoMemory[i] &#x3D; (VideoMemory[i] &amp; 0xFF00) | str[i];</strong></p><h3 id="1-4、运行结果"><a href="#1-4、运行结果" class="headerlink" title="1.4、运行结果"></a>1.4、运行结果</h3><p>直接运行<strong>make mykernel.bin</strong>，可以得到如下的文件序列：</p><p><img src="/2022/09/20/wyoos002/%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.PNG" alt="运行结果"></p><p>或者也可以分步运行：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-built_in">make</span> kernel.o<br><span class="hljs-built_in">make</span> loader.o<br><span class="hljs-built_in">make</span> mykernel.bin<br></code></pre></td></tr></table></figure><h2 id="2、后记"><a href="#2、后记" class="headerlink" title="2、后记"></a>2、后记</h2><p>在看<a href="https://www.bilibili.com/video/BV1RX4y157CM?p=1&vd_source=71ff1308c23d0ef0791f945a3cc515e6">视频链接1</a>进行学习以及在网上查阅资料时发现了一处不太一样的地方，我们使用<em>objdump -d kernel.o</em>进行反汇编时可能会发现<strong>KernelMain</strong>等函数编译后的方法名称有可能变成**_KernelMain**，这就需要对loader.s以及linker.ld进行修改，修改的方法就是把反汇编的名称替换原来的名称，具体做法可以参照<a href="https://www.bilibili.com/video/BV1RX4y157CM?p=1&vd_source=71ff1308c23d0ef0791f945a3cc515e6">视频链接1</a>，但是我并没有遇到这个问题</p>]]></content>
    
    
    
    <tags>
      
      <tag>wyoos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零开始的操作系统生活01-Hello World</title>
    <link href="/2022/09/19/wyoos001/"/>
    <url>/2022/09/19/wyoos001/</url>
    
    <content type="html"><![CDATA[<h2 id="0、目标"><a href="#0、目标" class="headerlink" title="0、目标"></a>0、目标</h2><p>使用cpp开发一个操作系统，具体能走到哪一步看毅力，加油！</p><h2 id="1、参考内容"><a href="#1、参考内容" class="headerlink" title="1、参考内容"></a>1、参考内容</h2><p><a href="https://www.bilibili.com/video/BV1RX4y157CM?p=1&vd_source=71ff1308c23d0ef0791f945a3cc515e6">视频链接1</a></p><p><a href="https://www.bilibili.com/video/BV1Ut411o7VG?p=2&share_medium=android&share_plat=android&share_source=COPY&share_tag=s_i&timestamp=1614198935&unique_k=Vu8Mmp&vd_source=71ff1308c23d0ef0791f945a3cc515e6">视频链接2</a></p><p><a href="https://github.com/anhongzhan/wyoos/tree/master/001">github</a></p><h2 id="2、开始"><a href="#2、开始" class="headerlink" title="2、开始"></a>2、开始</h2><p><a href="https://zh.wikipedia.org/zh-hans/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a>是一组主管并控制计算机操作、运用和运行硬件、软件资源和提供公共服务来组织用户交互的相互关联的系统软件程序</p><p>首先观察我们简单的操作系统的目录</p><p><img src="/2022/09/19/wyoos001/index.PNG" alt="index"></p><p>kernel.cpp是我们操作系统的运行程序，loader.s负责把我们的操作系统加载到硬件中运行，linker.ld负责将kernel与loader链接到一起，生成机器能够“读懂”的结构，Makefile负责进行编译。</p><h3 id="2-1、kernel-cpp"><a href="#2-1、kernel-cpp" class="headerlink" title="2.1、kernel.cpp"></a>2.1、kernel.cpp</h3><p>首先我们来编写最简单的操作系统：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">kernelMain</span><span class="hljs-params">(<span class="hljs-type">void</span>* multiboot_structure, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> magicnumber)</span></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world!&quot;</span>);<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们先来看程序的主体部分</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">kernelMain</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world!&quot;</span>);<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>程序主体就是要打印一句hello world，然后无限循环，操作系统本身就是无限循环，这里我们留下两个坑</p><p><em>*extern “C”<strong>以及</strong>void* multiboot_structure, unsigned int magicnumber</em>*稍后会做出解释</p><h3 id="2-2、GRUB-multiboot引导规范"><a href="#2-2、GRUB-multiboot引导规范" class="headerlink" title="2.2、GRUB multiboot引导规范"></a>2.2、GRUB multiboot引导规范</h3><p>操作系统的启动流程如下：</p><p><img src="/2022/09/19/wyoos001/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png" alt="操作系统启动流程"></p><p><a href="https://cloud.tencent.com/developer/article/1414532">参考链接</a></p><p>图中第三步GRUB引导存在各种各样的规范，我们所使用的称为multiboot引导规范，之所以存在各种规范，原因就是方便进行开发，比如我们下面的loader.s</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">.set</span> MAGIC, <span class="hljs-number">0x1badb002</span><br><span class="hljs-meta">.set</span> FLAGS, (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">0</span> | <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">1</span>)<br><span class="hljs-meta">.set</span> CHECKSUM, -(MAGIC + FLAGS)<br><span class="hljs-meta"></span><br><span class="hljs-meta">.section</span> .multiboot<br><span class="hljs-meta">.long</span> MAGIC<br><span class="hljs-meta">.long</span> FLAGS<br><span class="hljs-meta">.long</span> CHECKSUM<br><span class="hljs-meta">.section</span> .text<br><span class="hljs-meta">.extern</span> kernelMain<br><span class="hljs-meta">.global</span> loader<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">loader:</span><br>    <span class="hljs-keyword">mov</span> $kernel_stack, %esp<br>    <span class="hljs-keyword">push</span> %eax<br>    <span class="hljs-keyword">push</span> %ebx<br>    <span class="hljs-keyword">call</span> kernelMain<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">_stop:</span><br>    <span class="hljs-keyword">cli</span><br>    <span class="hljs-keyword">hlt</span><br>    <span class="hljs-keyword">jmp</span> _stop<br><span class="hljs-meta"></span><br><span class="hljs-meta">.section</span> .bss<br><span class="hljs-meta">.space</span> <span class="hljs-number">2</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span> <br><span class="hljs-symbol">kernel_stack:</span> <br><br></code></pre></td></tr></table></figure><p>multiboot的头的前三部分最为重要：</p><ul><li>magic：magic域固定为十六进制的0x1BADB002，这样方便BIOS的识别</li><li>flags：指出操作系统影响需要引导程序提供或支持的特性</li><li>checksum：32位无符号值，保证前三个域的值相加位0，即magic+flags+checksum&#x3D;0</li></ul><p>下面的内容即可得到解释：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">.set</span> MAGIC, 0x1badb002<br><span class="hljs-string">.set</span> FLAGS, <span class="hljs-params">(1&lt;&lt;0 | 1&lt;&lt;1)</span><br><span class="hljs-string">.set</span> CHECKSUM, -<span class="hljs-params">(MAGIC + FLAGS)</span><br><br><span class="hljs-string">.section</span> <span class="hljs-string">.multboot</span><br><span class="hljs-string">.long</span> MAGIC<br><span class="hljs-string">.long</span> FLAGS<br><span class="hljs-string">.long</span> CHECKSUM<br></code></pre></td></tr></table></figure><p>在引导multiboot规范头后，我们需要放出程序的入口点，即我们去哪执行kernel.cpp</p><p>这里插入一个汇编知识，汇编程序中以**.**开头的名称并不是指令的助记符，不会被翻译称机器指令，而是给汇编器一些特殊只是，成为汇编指示或伪操作。</p><p><strong>.section</strong>把代码划分为若干个段，成簇被操作系统加载执行时，每个段被加载到不同的地址，操作系统对不同的段赋予不同的读写执行权限</p><p><a href="https://wiki.osdev.org/ELF">ELF</a>is a format for storing programs or fragments of programs on disk, created as a result of compiling and linking</p><p>我们使用.section设置的各个段最终就存储在ELF文件中，下图介绍了ELF文件各个段所存储的内容极其权限</p><p><img src="/2022/09/19/wyoos001/ELF.jpg" alt="ELF"></p><p>观察我们的loader</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">.section</span> .text<br><span class="hljs-meta">.extern</span> kernelMain<br><span class="hljs-meta">.global</span> loader<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">loader:</span><br>    <span class="hljs-keyword">mov</span> $kernel_stack, %esp<br>    <span class="hljs-keyword">push</span> %eax<br>    <span class="hljs-keyword">push</span> %ebx<br>    <span class="hljs-keyword">call</span> kernelMain<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">kernel_stack:</span> <br></code></pre></td></tr></table></figure><p>首先定义.text段（已编译程序的机器代码），然后再text段中引入KernalMain编译后的内容</p><p>.global伪指令暴漏loader，以便让链接器linker能够找到loader地址</p><p>再接下来，loader中的内容，%esp是栈指针，在我们的<a href="https://www.bilibili.com/video/BV1Ut411o7VG?p=2&share_medium=android&share_plat=android&share_source=COPY&share_tag=s_i&timestamp=1614198935&unique_k=Vu8Mmp&vd_source=71ff1308c23d0ef0791f945a3cc515e6">视频链接2</a>的第一课提到，cpp文件并不会自动设置栈指针，需要我们手动设置，文件第11行有一个<strong>kernel_stack</strong>，我们将该位置设置为栈顶</p><p>接下来就要填我们前面提过的坑了，首先是<em><em>void</em> multiboot_structure, unsigned int magicnumber</em>*。按照规定，我们需要向kernel.cpp中传入两个参数，分别是Bootloader的地址和magic，这两个参数分别存在eax和ebx中，使用push指令将参数进行传递，其中一个坑填完。</p><p>接下来是另一个坑，我们在执行<strong>call kernelMain</strong>时会出现一个找不到函数的error，原因是cpp编译成汇编指令时会对函数名进行改变，所以我们访问不到，解决办法就是在cpp文件中添加<strong>extern “C”</strong></p><p>最后**_stop<strong>中，</strong>cli<strong>指令将IF置0，屏蔽掉“可屏蔽中断”，</strong>hlt<strong>指令是处理器的暂停指令，</strong>jmp**是跳转指令</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-symbol">_stop:</span><br>    <span class="hljs-keyword">cli</span><br>    <span class="hljs-keyword">hlt</span><br>    <span class="hljs-keyword">jmp</span> _stop<br><span class="hljs-meta"></span><br><span class="hljs-meta">.section</span> .bss<br><span class="hljs-meta">.space</span> <span class="hljs-number">2</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span> <br></code></pre></td></tr></table></figure><p>理论上我们的程序无法执行到_stop，因为call指令执行之后应当进入无线循环，如果执行到stop说明程序出现了问题</p><p>程序最后设置BSS段空间为2M，用于防止未初始化的全局和静态C变量</p><h3 id="2-3、linker-ld"><a href="#2-3、linker-ld" class="headerlink" title="2.3、linker.ld"></a>2.3、linker.ld</h3><p>首先放出linker.ld的内容，然后再尽力去分析每个部分的内容</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">ENTRY(<span class="hljs-params">loader</span>)</span><br><span class="hljs-constructor">OUTPUT_FORMAT(<span class="hljs-params">elf32</span>-<span class="hljs-params">i386</span>)</span><br><span class="hljs-constructor">OUTPUT_ARCH(<span class="hljs-params">i386</span>:<span class="hljs-params">i386</span>)</span><br><br>SECTIONS<br>&#123;<br>  . = <span class="hljs-number">0x0100000</span>;<br><br>  .text : <br>  &#123;<br>    *(.multiboot)<br>    *(.text*)<br>    *(.rodata)<br>  &#125;<br><br>  .data :<br>  &#123;<br>    start_ctors = .;<br>    <span class="hljs-constructor">KEEP(<span class="hljs-operator">*</span>( .<span class="hljs-params">init_array</span> )</span>);<br>    <span class="hljs-constructor">KEEP(<span class="hljs-operator">*</span>(SORT_BY_INIT_PRIORITY( .<span class="hljs-params">init_array</span>.<span class="hljs-operator">*</span> )</span>));<br>    end_ctors = .;<br><br>    *(.data)<br>  &#125;<br><br>  .bss :<br>  &#123;<br>    *(.bss)<br>  &#125;<br><br>  /DISCARD/ : <br>  &#123;<br>    *(.fini_array*)<br>    *(.comment)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>关于ld的参考内容，我找到了一下几个网站，后面讲解的内容也大概出自这里：</p><p><a href="https://wiki.osdev.org/LD">OSDEV</a></p><p><a href="https://www.gnu.org/software/binutils/">Binutils</a></p><p><a href="https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_node/ld_toc.html">Using ld</a></p><p>首先来看前面三行</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">ENTRY</span><span class="hljs-params">(loader)</span></span><br><span class="hljs-function"><span class="hljs-title">OUTPUT_FORMAT</span><span class="hljs-params">(elf32-i386)</span></span><br><span class="hljs-function"><span class="hljs-title">OUTPUT_ARCH</span><span class="hljs-params">(i386:i386)</span></span><br></code></pre></td></tr></table></figure><p><em>The linker command language includes a command specifically for defining the first executable instruction in an output file (its entry point). Its argument is a symbol name: ENTRY(symbol)</em></p><p>这句话翻译一下就是链接器的语言包括一句这样的指令：定义输出文件中要执行的第一行代码</p><p>参数的形式就是<strong>ENTRY(symbol)</strong></p><p>所以**ENTRY(loader)**就是告诉程序需要从loader处开始执行，我们在loader.s中有一句.global loader，暴漏了loader的位置，从而ld能够获取这个位置</p><p>OUTPUT_FORMAT(elf32-i386)以及OUTPUT_ARCH(i386:i386)就是指输出文件的格式以及输出文件所支持的平台</p><p>在<a href="https://wiki.osdev.org/LD">OSDEV</a>介绍linker的features中有这样一句</p><p><em>Supports most known output formats (ELF, Win32&#x2F;PE, COFF, a.out etc).</em></p><p>进一步找到<a href="https://wiki.osdev.org/Linker_Scripts">Linker Scripts关键词</a>可以找到OUTPUT_FORMAT可以填的内容</p><table><thead><tr><th>Format</th><th>Description</th></tr></thead><tbody><tr><td>binary</td><td>A flat binary with no formatting at all.</td></tr><tr><td>elf32-i386</td><td>32-bit ELF format for the i386 architecture.</td></tr><tr><td>elf64-x86-64</td><td>64-bit ELF format for the x86-64 architecture.</td></tr><tr><td>pe-i386</td><td>32-bit PE format for the i386 architecture.</td></tr></tbody></table><p>接下来是后面的.SECTIONS部分，<a href="https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_node/ld_18.html#SEC18">Section Defintions</a>中提到</p><p><em>The most frequently used statement in the SECTIONS command is the section definition, which specifies the properties of an output section: its location, alignment, contents, fill pattern, and target memory region</em></p><p>Section的格式一般为：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">SECTIONS &#123; <span class="hljs-string">...</span><br>  secname : &#123;<br>    contents<br>  &#125;<br><span class="hljs-string">...</span> &#125;<br></code></pre></td></tr></table></figure><p><em>secname is the name of the output section</em></p><p><em>contents is a specification of what goes there</em></p><p>secname需要包含在要输出文件各种中，比如(a.out中包括.text段，.data段或者.bss段，ELF文件包含的段前面提到过)</p><p>我们的SECTIONS中就包含.text,.bss以及.data段</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gcode">.text : <br>&#123;<br>  *<span class="hljs-comment">(.multiboot)</span><br>  *<span class="hljs-comment">(.text*)</span><br>  *<span class="hljs-comment">(.rodata)</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码。.text是我们要输出的段(section)，{}里面的内容是输入的内容，.multiboot表示成簇的multiboot段，*(.multiboot)表示所有文件的multiboot段，我们将{}内的内容作为输入，输出为.text段，同理.bss段</p><p>.data段的内容留到下一节一起解释，其中KEEP的作用是即使为引用符号，我们也要保留这部分</p><h3 id="2-4、Makefile"><a href="#2-4、Makefile" class="headerlink" title="2.4、Makefile"></a>2.4、Makefile</h3><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs mel">GPPPARAMS = -m32 -fno-use-cxa-atexit -nostdlib -fno-builtin -fno-rtti -fno-exceptions -fno-leading-underscore<br>ASPARAMS = -<span class="hljs-number">-32</span><br>LDPARAMS = -melf_i386<br><br>objects = loader.o kernel.o<br><br>%.o : %.cpp<br>g++ $&#123;GPPPARAMS&#125; -o $@ -c $&lt;<br><br>%.o : %.s<br>as $&#123;ASPARAMS&#125; -o $@ $&lt;<br><br>mykernel.bin: linker.ld $&#123;objects&#125;<br>ld $&#123;LDPARAMS&#125; -T $&lt; -o $@ $&#123;objects&#125;<br><br>install: mykernel.bin<br>sudo cp $&lt; /boot/mykernel.bin<br><br></code></pre></td></tr></table></figure><p>首先是GPPPARAMS，可以堪称g++ paramters，以下是各个参数代表的意思</p><figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ldif"><span class="hljs-literal">-</span>m32                    <span class="hljs-comment"># 指定编译为32位应用程序</span><br><span class="hljs-literal">-</span>fno-use-cxa-atexit     <span class="hljs-comment"># 禁用C析构函数__cxa_atexit</span><br><span class="hljs-literal">-</span>fleading-underscore    <span class="hljs-comment"># 编译时在C语言符号前加上下划线</span><br><span class="hljs-literal">-</span>fno-exceptions         <span class="hljs-comment"># 禁用异常机制</span><br><span class="hljs-literal">-</span>fno-builtin            <span class="hljs-comment"># 不使用C语言的内建函数</span><br><span class="hljs-literal">-</span>nostdlib               <span class="hljs-comment"># 不链接系统标准启动文件和标准库文件</span><br><span class="hljs-literal">-</span>fno-rtti               <span class="hljs-comment"># 禁用运行时类型信息</span><br><span class="hljs-literal">-</span>fno-pie                <span class="hljs-comment"># 禁用PIE模式</span><br></code></pre></td></tr></table></figure><p>ASPARAMS &#x3D; –32表示使用32位模式编译</p><p>LDPARAMS &#x3D; -melf_i386表示  -m -elf_i386保证调用时将需要的参数加上，然后调用真正的参数</p><p>后面的属于Makefile的常用内容，这里不做详细解释</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$@</span>:表示目标文件<br><span class="hljs-variable">$^</span>:表示所有的依赖文件<br><span class="hljs-variable">$&lt;</span>:表示第一个依赖文件<br><span class="hljs-variable">$?</span>:表示比目标还要鑫的以来文件列表<br></code></pre></td></tr></table></figure><h2 id="3、后记"><a href="#3、后记" class="headerlink" title="3、后记"></a>3、后记</h2><p>视频链接后面还有编写grub.cfg等操作，由于我们不使用这种方式打开自己的OS，所以这里暂时不展示该流程</p><p>本节留下了一个linker.ld的坑，下一节应该会填补完整</p><h3 id="3-1、乱七八糟的知识"><a href="#3-1、乱七八糟的知识" class="headerlink" title="3.1、乱七八糟的知识"></a>3.1、乱七八糟的知识</h3><p>在<a href="https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_node/ld_24.html#SEC24">The entry Point</a>中提到，<em>Entry is only one of several ways of choosing the entry point.</em></p><p>其他的方法包括：</p><ul><li>the &#96;-e’ entry command-line option;</li><li>the <code>ENTRY(symbol)</code> command in a linker control script;</li><li>the value of the symbol <code>start</code>, if present;</li><li>the address of the first byte of the <code>.text</code> section, if present;</li><li>The address <code>0</code>.</li></ul><p>其中第三条。<em>the value of the symbol start, if present</em>，在《Linux内核完全剖析》中有这样一段，</p><p><img src="/2022/09/19/wyoos001/entry_start.jpg" alt="entry_start"></p><p>此处用到了<strong>entry start</strong>。</p><p>这也算小小的学以致用了把。</p>]]></content>
    
    
    
    <tags>
      
      <tag>wyoos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/09/19/hello-world/"/>
    <url>/2022/09/19/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
