<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>从零开始的操作系统生活06-interrupt</title>
    <link href="/2022/10/06/wyoos006/"/>
    <url>/2022/10/06/wyoos006/</url>
    
    <content type="html"><![CDATA[<p>本节代码地址<a href="https://github.com/anhongzhan/wyoos/tree/master/006">github</a></p><h2 id="1、Introduction"><a href="#1、Introduction" class="headerlink" title="1、Introduction"></a>1、Introduction</h2><p><a href="https://wiki.osdev.org/Interrupts">中断</a>是指来自外部设备的信号，给到CPU，例如键盘或者其他的硬件设备。CPU收到中断信号后不顾一切的停止正在执行的指令，转而去执行一些预先设定好的中断指令。</p><p>注意，中断指来自外部设备的信号，其他的比如除以0等问题来自于CPU内部，我们称之为异常(Exception)。</p><p>中断和异常本质上工作原理相同，只不过来源不同。本节我们也会涉及一些异常的内容。</p><h2 id="2、IDT"><a href="#2、IDT" class="headerlink" title="2、IDT"></a>2、IDT</h2><p>和GDT类似。IDT也是一种描述符表格，全称为<a href="https://wiki.osdev.org/Interrupt_Descriptor_Table">Interrupt Descriptor Table</a>。IDT中的每一项叫做门描述符(Gate Descriptor)，门描述符的数据结构如下图所示：</p><p><img src="/2022/10/06/wyoos006/GateDescriptor.PNG" alt="GateDescriptor"></p><p>可以看到，IDT中有一部分为Segment Selector，段选择子的内容我们在GDT中讲过，负责选择GDT中的某个描述符，然后根据描述符中的内容获得基地址。这里也是同样的原理，由于中断是CPU停止现在的工作，转到执行一些预先设定好的指令，这些指令也存在内存中，一般在代码段中。通过IDT中的段选择子以及Offset我们可以跳转到要执行的中断指令处，这样就实现了中断。</p><p>IDT的其他部分内容如下所示：</p><ul><li><strong>Offset:</strong> A 32-bit value, split in two parts. It represents the address of the entry point of the <strong><a href="https://wiki.osdev.org/Interrupt_Service_Routines">Interrupt Service Routine</a></strong>.</li><li><strong>Selector:</strong> A <strong><a href="https://wiki.osdev.org/Segment_Selector">Segment Selector</a></strong> with multiple fields which must point to a valid code segment in your <strong><a href="https://wiki.osdev.org/GDT">GDT</a></strong>.</li><li>Gate Type: A 4-bit value which defines the type of gate this Interrupt Descriptor represents. There are five valid type values:<ul><li><strong>0b0101</strong> or <strong>0x5</strong>: Task Gate, note that in this case, the <strong>Offset</strong> value is unused and should be set to zero.</li><li><strong>0b0110</strong> or <strong>0x6</strong>: 16-bit Interrupt Gate</li><li><strong>0b0111</strong> or <strong>0x7</strong>: 16-bit Trap Gate</li><li><strong>0b1110</strong> or <strong>0xE</strong>: 32-bit Interrupt Gate</li><li><strong>0b1111</strong> or <strong>0xF</strong>: 32-bit Trap Gate</li></ul></li><li><strong>DPL:</strong> A 2-bit value which defines the <strong><a href="https://wiki.osdev.org/Security#Rings">CPU Privilege Levels</a></strong> which are allowed to access this interrupt via the <strong>INT</strong> instruction. Hardware interrupts ignore this mechanism.</li><li><strong>P:</strong> Present bit. Must be set (<strong>1</strong>) for the descriptor to be valid.</li></ul><p>For more information, see <strong>Section 6.11: IDT Descriptors</strong> and <strong>Figure 6-2: IDT Gate Descriptors</strong> of the Intel Software Developer Manual, Volume 3-A.</p><p>通过上面的描述我们可以看出，IDT中一共存在四种门描述符，分别是任务门、中断门、陷阱门以及调用门，这四种结构的具体内容如下：</p><p>任务门：</p><p><img src="/2022/10/06/wyoos006/TaskGate.png" alt="TaskGate"></p><p>中断门：</p><p><img src="/2022/10/06/wyoos006/InterruptGate.jpg" alt="InterruptGate"></p><p>陷阱门：</p><p><img src="/2022/10/06/wyoos006/TrapGate.jpg" alt="TrapGate"></p><p>调用门：</p><p><img src="/2022/10/06/wyoos006/CallGate.jpg" alt="CallGate"></p><p>可以看到，每种门的<code>TYPE</code>字段是不同的。另一个不同点是，任务们选择子字段是TSS选择子。TSS(Task Status Segment)是Intel处理器中提供任务切换机制时使用的数据结构。由于我们本次实现的操作系统不涉及TSS，所以这里不做展开讲述。</p><p>详细了解TSS可以参考《Linux内核完全剖析 -基于0.12内核》这本书的140页开始的boot.s以及head.s的讲解。</p><p>门描述符的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">GateDescriptor</span> &#123;<br>    <span class="hljs-type">uint16_t</span> handleAddressLowBits;<br>    <span class="hljs-type">uint16_t</span> gdt_codeSegementSelector;<br>    <span class="hljs-type">uint8_t</span> reserved;<br>    <span class="hljs-type">uint8_t</span> access;<br>    <span class="hljs-type">uint16_t</span> handleAddressHighBits;<br>&#125;__attribute__((packed));<br><br><span class="hljs-type">static</span> GateDescriptor interruptDescriptorTable[<span class="hljs-number">256</span>];<br></code></pre></td></tr></table></figure><p>处理器只支持256个中断，所以我们设置一个长度为256的数组来存放门描述符，也就是IDT</p><h2 id="3、Where-is-IDT"><a href="#3、Where-is-IDT" class="headerlink" title="3、Where is IDT?"></a>3、Where is IDT?</h2><p>在GDT一节中我们介绍过，通过GDTR存储GDT的位置，这样访问GDTR我们就能找到GDT。</p><p>同样，IDT的地址存储在IDTR(Interrupt Descriptor Table Register)中，</p><p><img src="/2022/10/06/wyoos006/IDTR.PNG" alt="IDTR"></p><p>没错，IDTR的结构也和GDTR非常类似，图中Offset存储着IDT的基地址，32位系统中基地址有32位，64位系统中基地址自然是64位。size表示IDT中门描述符的个数，在OSDEV中有这样一句：<br>Although the <strong>IDT</strong> can contain less than 256 entries, any entries that are not present (due to this or other reasons) will generate a <strong><a href="https://wiki.osdev.org/Exceptions#General_Protection_Fault">General Protection Fault</a></strong> when an attempt to access them is made. Ideally the <strong>IDT</strong> should contain enough entries so that this fault (which is itself an interrupt vector) can be handled.</p><p>虽然我们可能用不到256个中断，但是这256个中断必须都存在，哪怕是什么都不执行也要存在。因为访问不存在的中断会引起General Protection Fault。</p><p>最后，我们使用LIDT指令将IDT地址加载到IDTR中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">asm</span> <span class="hljs-title">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;lidt %0&quot;</span> : : <span class="hljs-string">&quot;m&quot;</span> (idt))</span></span>;<br></code></pre></td></tr></table></figure><h2 id="4、How-to-find-Gate-Descriptor"><a href="#4、How-to-find-Gate-Descriptor" class="headerlink" title="4、How to find Gate Descriptor?"></a>4、How to find Gate Descriptor?</h2><p>中断的发生由外部或者内部的信号出发，这里的信号包含中断号信息，系统通过这个中断号就可以找到对应的门描述符（当然还有很多其他的处理），然后就可以执行中断了，这里不需要我们做太多的处理。</p><p>和GDT不同，我们没有段选择子。</p><h2 id="5、Coding"><a href="#5、Coding" class="headerlink" title="5、Coding"></a>5、Coding</h2><p>首先创建三个文件：<code>interrupts.h</code>,<code>interrupts.cpp</code>,<code>interruptstubs.s</code></p><p>这里我们只实现Intel设计者设计的17个中断以及20个异常的程序，其他的内容理论上要有，但是我们控制处理器不访问其他的内容即可。</p><p>首先是<code>interrupts.h</code>，定义IDT</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">InterruptManager</span> &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">GateDescriptor</span> &#123;<br>        <span class="hljs-type">uint16_t</span> handleAddressLowBits;<br>        <span class="hljs-type">uint16_t</span> gdt_codeSegementSelector;<br>        <span class="hljs-type">uint8_t</span> reserved;<br>        <span class="hljs-type">uint8_t</span> access;<br>        <span class="hljs-type">uint16_t</span> handleAddressHighBits;<br>    &#125;__attribute__((packed));<br><br>    <span class="hljs-type">static</span> GateDescriptor interruptDescriptorTable[<span class="hljs-number">256</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><p>然后加载IDTR，填写IDT表</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">InterruptManager</span> &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">InterruptorDescriptorTablePointer</span>&#123;<br>        <span class="hljs-type">uint16_t</span> size;<br>        <span class="hljs-type">uint32_t</span> base;<br>    &#125;__attribute__((packed));<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">SetInterruptDescriptorTableEntry</span> <span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">uint8_t</span> interruptNumber,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">uint16_t</span> codeSegmentSelectorOffset,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">void</span> (*handler)(),</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">uint8_t</span> DescriptorPrivilegeLevel,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">uint8_t</span> DescriptorType</span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>再然后设定需要完成的中断和异常处理指令，在cpp里面就是函数，这部分由<code>interruptstubs.s</code>实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">InterruptManager</span> &#123;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleInterruptRequest0x00</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleInterruptRequest0x01</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleInterruptRequest0x02</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleInterruptRequest0x03</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleInterruptRequest0x04</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleInterruptRequest0x05</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleInterruptRequest0x06</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleInterruptRequest0x07</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleInterruptRequest0x08</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleInterruptRequest0x09</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleInterruptRequest0x0A</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleInterruptRequest0x0B</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleInterruptRequest0x0C</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleInterruptRequest0x0D</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleInterruptRequest0x0E</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleInterruptRequest0x0F</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleInterruptRequest0x31</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleException0x00</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleException0x01</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleException0x02</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleException0x03</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleException0x04</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleException0x05</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleException0x06</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleException0x07</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleException0x08</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleException0x09</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleException0x0A</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleException0x0B</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleException0x0C</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleException0x0D</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleException0x0E</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleException0x0F</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleException0x10</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleException0x11</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleException0x12</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleException0x13</span><span class="hljs-params">()</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>最后，还有设定中断端口的指令，这部分内容后面会讲：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">    <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;port.h&quot;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">InterruptManager</span> &#123;    <br>    Port8BitSlow picMasterCommand;<br>    Port8BitSlow picMasterData;<br>    Port8BitSlow picSlaveCommand;<br>    Port8BitSlow picSlaveData;<br>&#125;;<br></code></pre></td></tr></table></figure><p>最后的最后，还有中断处理函数、中断激活和失效函数以及InterruptManager的构造函数、析构函数等</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">InterruptManager</span> &#123;<br><span class="hljs-built_in">InterruptManager</span>(GlobalDescriptorTable* gdt, <span class="hljs-type">uint16_t</span> hardwareInterruptOffset);<br>    ~<span class="hljs-built_in">InterruptManager</span>();<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Activate</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Deactivate</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">uint32_t</span> <span class="hljs-title">HandleInterrupt</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> interruptNumber, <span class="hljs-type">uint32_t</span> esp)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">DoHandleInterrupt</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> interruptNumber, <span class="hljs-type">uint32_t</span> esp)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>以上内容都是InterruptManager类中的内容，我们需要额外实现中断处理类，专门负责InterruptManager中的中断处理工作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">InterruptHandler</span> &#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-built_in">InterruptHandler</span>(<span class="hljs-type">uint8_t</span> interruptNumber, InterruptManager* interruptManager);<br>    ~<span class="hljs-built_in">InterruptHandler</span>();<br><br>    <span class="hljs-type">uint8_t</span> interruptNumber;<br>    InterruptManager* interruptManager;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">HandleInterrupt</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> esp)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>头文件定义完毕，接下来是实现：</p><p><code>interruptstubs.s</code>实现了InterruptManager中的中断异常处理函数：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">.set</span> IRQ_BASE, <span class="hljs-number">0x20</span><br><span class="hljs-meta">.section</span> .text<br><span class="hljs-meta">.extern</span> _ZN16InterruptManager15HandleInterruptEhj<br><span class="hljs-meta"></span><br><span class="hljs-meta">.macro</span> HandleInterruptRequest num<br><span class="hljs-meta">.global</span> _ZN16InterruptManager26HandleInterruptRequest\num\()Ev<br>_ZN16InterruptManager26HandleInterruptRequest\num\()Ev:<br>    movb $\num + IRQ_BASE, (interruptnumber)<br>    <span class="hljs-keyword">jmp</span> int_bottom<br><span class="hljs-meta">.endm</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">.macro</span> HandleException num<br><span class="hljs-meta">.global</span> _ZN16InterruptManager19HandleException\num\()Ev<br>_ZN16InterruptManager19HandleException\num\()Ev:<br>    movb $\num, (interruptnumber)<br>    <span class="hljs-keyword">jmp</span> int_bottom<br><span class="hljs-meta">.endm</span><br><br>HandleInterruptRequest <span class="hljs-number">0x00</span><br>HandleInterruptRequest <span class="hljs-number">0x01</span><br>HandleInterruptRequest <span class="hljs-number">0x02</span><br>HandleInterruptRequest <span class="hljs-number">0x03</span><br>HandleInterruptRequest <span class="hljs-number">0x04</span><br>HandleInterruptRequest <span class="hljs-number">0x05</span><br>HandleInterruptRequest <span class="hljs-number">0x06</span><br>HandleInterruptRequest <span class="hljs-number">0x07</span><br>HandleInterruptRequest <span class="hljs-number">0x08</span><br>HandleInterruptRequest <span class="hljs-number">0x09</span><br>HandleInterruptRequest <span class="hljs-number">0x0A</span><br>HandleInterruptRequest <span class="hljs-number">0x0B</span><br>HandleInterruptRequest <span class="hljs-number">0x0C</span><br>HandleInterruptRequest <span class="hljs-number">0x0D</span><br>HandleInterruptRequest <span class="hljs-number">0x0E</span><br>HandleInterruptRequest <span class="hljs-number">0x0F</span><br>HandleInterruptRequest <span class="hljs-number">0x31</span><br><br>HandleException <span class="hljs-number">0x00</span><br>HandleException <span class="hljs-number">0x01</span><br>HandleException <span class="hljs-number">0x02</span><br>HandleException <span class="hljs-number">0x03</span><br>HandleException <span class="hljs-number">0x04</span><br>HandleException <span class="hljs-number">0x05</span><br>HandleException <span class="hljs-number">0x06</span><br>HandleException <span class="hljs-number">0x07</span><br>HandleException <span class="hljs-number">0x08</span><br>HandleException <span class="hljs-number">0x09</span><br>HandleException <span class="hljs-number">0x0A</span><br>HandleException <span class="hljs-number">0x0B</span><br>HandleException <span class="hljs-number">0x0C</span><br>HandleException <span class="hljs-number">0x0D</span><br>HandleException <span class="hljs-number">0x0E</span><br>HandleException <span class="hljs-number">0x0F</span><br>HandleException <span class="hljs-number">0x10</span><br>HandleException <span class="hljs-number">0x11</span><br>HandleException <span class="hljs-number">0x12</span><br>HandleException <span class="hljs-number">0x13</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">int_bottom:</span><br>    <span class="hljs-keyword">pusha</span> <br>    pushl %ds<br>    pushl %es<br>    pushl %fs<br>    pushl %gs<br><br>    pushl %esp<br>    <span class="hljs-keyword">push</span> (interruptnumber)<br>    <span class="hljs-keyword">call</span> _ZN16InterruptManager15HandleInterruptEhj<br>    <br>    movl %eax, %esp<br>    popl %gs<br>    popl %fs<br>    popl %es<br>    popl %ds<br>    <span class="hljs-keyword">popa</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">.global</span> _ZN16InterruptManager15InterruptIgnoreEv<br><span class="hljs-symbol">_ZN16InterruptManager15InterruptIgnoreEv:</span><br><br><br>    <span class="hljs-keyword">iret</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">.data</span><br><span class="hljs-symbol">    interruptnumber:</span> .byte <span class="hljs-number">0</span><br><br></code></pre></td></tr></table></figure><p>首先，<code>_ZN16InterruptManager26HandleInterruptRequest\num\()Ev</code>是我们通过objdump反汇编之后得到的名称，由于我们函数数量比较多，所以采用这种拼接的方式组成函数名称，这里建议观看<a href="https://www.bilibili.com/video/BV1RX4y157CM?p=14&vd_source=71ff1308c23d0ef0791f945a3cc515e6">参考资料</a>学习一下具体的命名方式。</p><p>下面说一下中断的处理方式，中断信号来到之后，CPU需要停止正在进行的工作，转而去执行中断指令。但同时需要考虑另一个问题，那就是执行完中断指令后要怎么办？那肯定是回到之前执行的工作继续执行啦。那怎么回去呢？寄存器就那么几个，肯定无法保存前面执行的内容，所以操作系统的实现者考虑使用栈来保存中断执行前的信息，中断执行之后再弹栈即可，这就是我们下面的中断执行函数的实现：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs llvm">int_bottom:<br>    pusha <br>    pushl <span class="hljs-variable">%ds</span><br>    pushl <span class="hljs-variable">%es</span><br>    pushl <span class="hljs-variable">%fs</span><br>    pushl <span class="hljs-variable">%gs</span><br><br>    pushl <span class="hljs-variable">%esp</span><br>    push (interruptnumber)<br>    <span class="hljs-keyword">call</span> _ZN<span class="hljs-number">16</span>InterruptManager<span class="hljs-number">15</span>HandleInterruptEhj<br>    <br>    movl <span class="hljs-variable">%eax</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%esp</span><br>    popl <span class="hljs-variable">%gs</span><br>    popl <span class="hljs-variable">%fs</span><br>    popl <span class="hljs-variable">%es</span><br>    popl <span class="hljs-variable">%ds</span><br>    popa<br></code></pre></td></tr></table></figure><p>可以看到，每个中断或者异常处理函数都跳转到<code>int_bottom</code>，跳转之后开始压栈，然后执行InterruptManager::HandleInterrupt()函数。执行完毕后再弹栈，继续前面被终止的工作。</p><p>最后解释一下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">.<span class="hljs-built_in">set</span> IRQ_BASE, 0x20<br></code></pre></td></tr></table></figure><p>前面提到过，中断是由硬件发来的信号。CPU内部的“中断”叫做异常。操作系统设计者对这些内容编号时，设定了32个异常，排在前32位，后面紧接着就是中断，所以说我们的中断号是从32开始的，也就是0x20。意思就是，我们的第一号中断对应的中断编号位0x20+0x1</p><p>注：当我们提到中断号时就泛指所有的中断和异常。</p><p>最后是<code>interrupts.cpp</code></p><p>首先是中断激活以及失效函数，<code>sti</code>指set interrupt，用于开启中断，<code>cli</code>指clear interrupt，用于清空中断。</p><p>ActiveInterruptManager指当前激活的InterruptManager对象，很明显，我们的中断请求由这个对象来处理。但这种中断处理对象不能存在多个，所以我们需要将其他的InterruptManager对象关闭掉，然后使用新的ActiveInterruptManager来处理中断。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InterruptManager::Activate</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(ActiveInterruptManager != <span class="hljs-number">0</span>)&#123;<br>        ActiveInterruptManager-&gt;<span class="hljs-built_in">Deactivate</span>();<br>    &#125;<br>    ActiveInterruptManager = <span class="hljs-keyword">this</span>;<br>    <span class="hljs-built_in">asm</span>(<span class="hljs-string">&quot;sti&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InterruptManager::Deactivate</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(ActiveInterruptManager == <span class="hljs-keyword">this</span>)&#123;<br>        ActiveInterruptManager = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">asm</span>(<span class="hljs-string">&quot;cli&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来就是中断处理，这里为了清晰明了作者(wyoos的作者)采用了两个函数来实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">InterruptManager::HandleInterrupt</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> InterruptNumber, <span class="hljs-type">uint32_t</span> esp)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(ActiveInterruptManager != <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> ActiveInterruptManager-&gt;<span class="hljs-built_in">DoHandleInterrupt</span>(InterruptNumber, esp);<br>    &#125;<br>    <span class="hljs-keyword">return</span> esp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">InterruptManager::DoHandleInterrupt</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> InterruptNumber, <span class="hljs-type">uint32_t</span> esp)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(handlers[InterruptNumber] != <span class="hljs-number">0</span>)&#123;<br>        esp = handlers[InterruptNumber]-&gt;<span class="hljs-built_in">HandleInterrupt</span>(esp);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(InterruptNumber != hardwareInterruptOffset)&#123;<br>        <span class="hljs-type">char</span>* foo = (<span class="hljs-type">char</span>*)<span class="hljs-string">&quot;UNHANDLED INTERRUPT 0X00&quot;</span>;<br>        <span class="hljs-type">const</span> <span class="hljs-type">char</span>* hex = <span class="hljs-string">&quot;0123456789ABCDEF&quot;</span>;<br>        foo[<span class="hljs-number">22</span>] = hex[(InterruptNumber &gt;&gt; <span class="hljs-number">4</span>) &amp; <span class="hljs-number">0x0f</span>];<br>        foo[<span class="hljs-number">23</span>] = hex[InterruptNumber &amp; <span class="hljs-number">0x0f</span>];<br>        <span class="hljs-built_in">printf</span>((<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)foo);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(hardwareInterruptOffset &lt;= InterruptNumber &amp;&amp; InterruptNumber &lt; hardwareInterruptOffset + <span class="hljs-number">16</span>)&#123;<br>        picMasterCommand.<span class="hljs-built_in">Write</span>(<span class="hljs-number">0x20</span>);<br>        <span class="hljs-keyword">if</span>(hardwareInterruptOffset + <span class="hljs-number">8</span> &lt;= InterruptNumber)&#123;<br>            picSlaveCommand.<span class="hljs-built_in">Write</span>(<span class="hljs-number">0x20</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> esp;<br>&#125;<br></code></pre></td></tr></table></figure><p>HandleInterrupt判断是否存在前面所说的ActiveInterruptManager对象，如果不存在，自然不能执行中断</p><p>DoHandleInterrupt则是执行中断，这里我们采用打印相应的中断号作为中断处理程序，这样比较明显。</p><p>我们可以看到判断<code>if(handlers[InterruptNumber] != 0)</code>，这里是为了我们后面实现键盘和鼠标做准备，我们设定好的中断自然有其自己的执行程序，而未设定好的中断则是采用打印<code>UNHANDLED INTERRUPT 0X</code>+中断号来实现的。其中，中断号0x20(第一个硬件中断)是指时钟中断，时时刻刻都在发生，所以我们将其屏蔽掉。</p><p>最后的判断是指8259A芯片编程，对硬件端口写入一些特定值，从而告知硬件中断已经处理完成。</p><p>接下来：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InterruptManager::SetInterruptDescriptorTableEntry</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">uint8_t</span> interruptNumber,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">uint16_t</span> codeSegmentSelectorOffset,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">void</span> (*handler)(),</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">uint8_t</span> DescriptorPrivilegeLevel,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">uint8_t</span> DescriptorType)</span></span>&#123;<br>        <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> IDT_DESC_PRESENT = <span class="hljs-number">0x80</span>;<br><br>        interruptDescriptorTable[interruptNumber].handleAddressLowBits = ((<span class="hljs-type">uint32_t</span>)handler) &amp; <span class="hljs-number">0xffff</span>;<br>        interruptDescriptorTable[interruptNumber].handleAddressHighBits = ((<span class="hljs-type">uint32_t</span>)handler &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xffff</span>;<br>        interruptDescriptorTable[interruptNumber].gdt_codeSegementSelector = codeSegmentSelectorOffset;<br>        interruptDescriptorTable[interruptNumber].access = IDT_DESC_PRESENT | ((DescriptorPrivilegeLevel &amp; <span class="hljs-number">3</span>) &lt;&lt; <span class="hljs-number">5</span>) | DescriptorType;<br>        interruptDescriptorTable[interruptNumber].reserved = <span class="hljs-number">0</span>; <br>    &#125;<br></code></pre></td></tr></table></figure><p>设定门描述符，每处设定都是按照前面的门描述符的结构设定的，大家可以去对应一下。后面会不断调用这个门描述符表，毕竟有256个中断。</p><p>再然后：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs cpp">InterruptManager::<span class="hljs-built_in">InterruptManager</span>(GlobalDescriptorTable* gdt, <span class="hljs-type">uint16_t</span> hardwareInterruptOffset)<br>    :<span class="hljs-built_in">picMasterCommand</span>(<span class="hljs-number">0x20</span>),<br>    <span class="hljs-built_in">picMasterData</span>(<span class="hljs-number">0x21</span>),<br>    <span class="hljs-built_in">picSlaveCommand</span>(<span class="hljs-number">0xA0</span>),<br>    <span class="hljs-built_in">picSlaveData</span>(<span class="hljs-number">0xA1</span>)<br>&#123;<br>    <span class="hljs-keyword">this</span>-&gt;hardwareInterruptOffset = hardwareInterruptOffset;<br>    <span class="hljs-type">uint16_t</span> codeSegemnt = gdt-&gt;<span class="hljs-built_in">CodeSegmentSelector</span>();<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> IDT_INTERRUPT_GATE = <span class="hljs-number">0xe</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">uint16_t</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">256</span>; i++)&#123;<br>        handlers[i] = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(i, codeSegemnt, &amp;InterruptIgnore, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    &#125;<br><br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(<span class="hljs-number">0x00</span>, codeSegemnt, &amp;HandleException0x00, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(<span class="hljs-number">0x01</span>, codeSegemnt, &amp;HandleException0x01, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(<span class="hljs-number">0x02</span>, codeSegemnt, &amp;HandleException0x02, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(<span class="hljs-number">0x03</span>, codeSegemnt, &amp;HandleException0x03, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(<span class="hljs-number">0x04</span>, codeSegemnt, &amp;HandleException0x04, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(<span class="hljs-number">0x05</span>, codeSegemnt, &amp;HandleException0x05, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(<span class="hljs-number">0x06</span>, codeSegemnt, &amp;HandleException0x06, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(<span class="hljs-number">0x07</span>, codeSegemnt, &amp;HandleException0x07, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(<span class="hljs-number">0x08</span>, codeSegemnt, &amp;HandleException0x08, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(<span class="hljs-number">0x09</span>, codeSegemnt, &amp;HandleException0x09, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(<span class="hljs-number">0x0A</span>, codeSegemnt, &amp;HandleException0x0A, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(<span class="hljs-number">0x0B</span>, codeSegemnt, &amp;HandleException0x0B, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(<span class="hljs-number">0x0C</span>, codeSegemnt, &amp;HandleException0x0C, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(<span class="hljs-number">0x0D</span>, codeSegemnt, &amp;HandleException0x0D, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(<span class="hljs-number">0x0E</span>, codeSegemnt, &amp;HandleException0x0E, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(<span class="hljs-number">0x0F</span>, codeSegemnt, &amp;HandleException0x0F, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(<span class="hljs-number">0x10</span>, codeSegemnt, &amp;HandleException0x10, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(<span class="hljs-number">0x11</span>, codeSegemnt, &amp;HandleException0x11, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(<span class="hljs-number">0x12</span>, codeSegemnt, &amp;HandleException0x12, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(<span class="hljs-number">0x13</span>, codeSegemnt, &amp;HandleException0x13, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br><br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(hardwareInterruptOffset + <span class="hljs-number">0x00</span>, codeSegemnt, &amp;HandleInterruptRequest0x00, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(hardwareInterruptOffset + <span class="hljs-number">0x01</span>, codeSegemnt, &amp;HandleInterruptRequest0x01, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(hardwareInterruptOffset + <span class="hljs-number">0x02</span>, codeSegemnt, &amp;HandleInterruptRequest0x02, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(hardwareInterruptOffset + <span class="hljs-number">0x03</span>, codeSegemnt, &amp;HandleInterruptRequest0x03, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(hardwareInterruptOffset + <span class="hljs-number">0x04</span>, codeSegemnt, &amp;HandleInterruptRequest0x04, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(hardwareInterruptOffset + <span class="hljs-number">0x05</span>, codeSegemnt, &amp;HandleInterruptRequest0x05, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(hardwareInterruptOffset + <span class="hljs-number">0x06</span>, codeSegemnt, &amp;HandleInterruptRequest0x06, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(hardwareInterruptOffset + <span class="hljs-number">0x07</span>, codeSegemnt, &amp;HandleInterruptRequest0x07, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(hardwareInterruptOffset + <span class="hljs-number">0x08</span>, codeSegemnt, &amp;HandleInterruptRequest0x08, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(hardwareInterruptOffset + <span class="hljs-number">0x09</span>, codeSegemnt, &amp;HandleInterruptRequest0x09, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(hardwareInterruptOffset + <span class="hljs-number">0x0A</span>, codeSegemnt, &amp;HandleInterruptRequest0x0A, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(hardwareInterruptOffset + <span class="hljs-number">0x0B</span>, codeSegemnt, &amp;HandleInterruptRequest0x0B, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(hardwareInterruptOffset + <span class="hljs-number">0x0C</span>, codeSegemnt, &amp;HandleInterruptRequest0x0C, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(hardwareInterruptOffset + <span class="hljs-number">0x0D</span>, codeSegemnt, &amp;HandleInterruptRequest0x0D, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(hardwareInterruptOffset + <span class="hljs-number">0x0E</span>, codeSegemnt, &amp;HandleInterruptRequest0x0E, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(hardwareInterruptOffset + <span class="hljs-number">0x0F</span>, codeSegemnt, &amp;HandleInterruptRequest0x0F, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br>    <span class="hljs-built_in">SetInterruptDescriptorTableEntry</span>(hardwareInterruptOffset + <span class="hljs-number">0x31</span>, codeSegemnt, &amp;HandleInterruptRequest0x31, <span class="hljs-number">0</span>, IDT_INTERRUPT_GATE);<br><br>    picMasterCommand.<span class="hljs-built_in">Write</span>(<span class="hljs-number">0x11</span>);<br>    picSlaveCommand.<span class="hljs-built_in">Write</span>(<span class="hljs-number">0x11</span>);<br><br>    picMasterData.<span class="hljs-built_in">Write</span>(hardwareInterruptOffset);<br>    picSlaveData.<span class="hljs-built_in">Write</span>(hardwareInterruptOffset + <span class="hljs-number">0x8</span>);<br><br>    picMasterData.<span class="hljs-built_in">Write</span>(<span class="hljs-number">0x04</span>);<br>    picSlaveData.<span class="hljs-built_in">Write</span>(<span class="hljs-number">0x02</span>);<br><br>    picMasterData.<span class="hljs-built_in">Write</span>(<span class="hljs-number">0x01</span>);<br>    picSlaveData.<span class="hljs-built_in">Write</span>(<span class="hljs-number">0x01</span>);<br><br>    picMasterData.<span class="hljs-built_in">Write</span>(<span class="hljs-number">0x00</span>);<br>    picSlaveData.<span class="hljs-built_in">Write</span>(<span class="hljs-number">0x00</span>);<br><br>    InterruptorDescriptorTablePointer idt;<br>    idt.size = <span class="hljs-number">256</span> * <span class="hljs-built_in">sizeof</span>(GateDescriptor) - <span class="hljs-number">1</span>;<br>    idt.base = (<span class="hljs-type">uint32_t</span>)interruptDescriptorTable;<br><br>    <span class="hljs-function"><span class="hljs-keyword">asm</span> <span class="hljs-title">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;lidt %0&quot;</span> : : <span class="hljs-string">&quot;m&quot;</span> (idt))</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>InterruptManager的构造函数，主要是构造IDT以及开启8259芯片，8259芯片的问题我们放在后面讲。这里主要数一下构造IDT</p><p>首先，硬件offset为0x20，设定好256个空的门描述符。</p><p>由于我们设定好了17个中断以及20个异常，所以分别将我们设定好的内容填入到IDT中，这样在执行中断时，遇到我们设定好的中断号，就会执行相应设定好的函数，为设定的中断号则执行InterruptIgnore，这个函数可以去<code>interruptstubs.s</code>中查看，本质上什么都没看，就一个函数名。最后我们设定IDTR，将中断描述符数量以及IDT基地址加载进去。</p><p>前面说过，InterruptManager中的中断处理交由InterruptHandler来实现，在InterruptManager中也设定好256个中断处理数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">InterruptHandler* handlers[<span class="hljs-number">256</span>];<br></code></pre></td></tr></table></figure><p>这样我们就可以执行相应的中断了。</p><p>结合前面的DoHandleInterrupt函数我们可知，当相应的中断号传输过来之后，我们首先判断是否有相应的中断处理函数（这些中断处理函数是我们提前设定好的，比如键盘、鼠标），如果有，则去执行相应的中断，如果没有，则是打印<code>UNHANDLED INTERRUPT 0X</code>+中断号</p><p>这就是当前我们的处理逻辑，后续我们实现键盘以及鼠标中断之后，只需要继承InterruptHandler，然后在InterruptManager中的handlers数组中添加相应的内容即可。</p><h2 id="6、串联一下"><a href="#6、串联一下" class="headerlink" title="6、串联一下"></a>6、串联一下</h2><p>如何实现中断？</p><p>首先，设定好IDT以及IDTR;</p><p>然后，实现InterruptManager以及InterruptHandler类，InterruptHandler包含在InterruptManager中，负责处理中断</p><p>最后，中断触发，产生相应的中断号，系统根据中断号找到对应的中断处理函数，完成中断处理</p><h2 id="7、8259A"><a href="#7、8259A" class="headerlink" title="7、8259A"></a>7、8259A</h2><p>！！！本篇重点，干货满满</p><p>首先列出参考资料</p><p><a href="https://wiki.osdev.org/8259_PIC">资料1</a></p><p><a href="https://blog.csdn.net/longintchar/article/details/79439466">资料2</a></p><p><a href="http://www.brokenthorn.com/Resources/OSDevPic.html">资料3</a></p><p>8259芯片是x86体系结构中最重要的芯片之一，8259A芯片的主要功能是管理硬件中断并且发送中断信号去执行。</p><p>8259A的原理图如下：</p><p><img src="/2022/10/06/wyoos006/8259A.gif" alt="8259A"></p><p>其中的IR0到IR7与外部设备链接，每个管脚代表一种中断，中断信号就是从这里传输进来的。</p><p>由于8个中断无法满足操作系统的需求，设计者又增加了一块8259A芯片，我们称第一块芯片为主芯片(Master)，第二块芯片为从芯片(Slave)。从芯片连接在主芯片的IR2管脚，如下图所示：</p><p><img src="/2022/10/06/wyoos006/8259ATwochips.PNG" alt="8259ATwochips"></p><p>这样就扩展为15条中断，足够操作系统使用。</p><p>学习过中断的朋友们知道中断也是存在优先级的，高优先级的中断来会优先执行高优先级的内容。8259A芯片管脚从0-7中断优先级逐级下降，所以我们硬件中断的优先级IR0 &gt; IR1 &gt; IR8 &gt; IR9 &gt; …… &gt; IRC &gt; IR3 &gt; … &gt; IR7，IR2也存在，但不是独立存在，而是成为了从芯片的入口。</p><p>8259A存在两个端口，分别是指令端口(command)以及数据端口(data)为了控制8259A的主从芯片，操作系统设计者将两块芯片分别连接在如下端口中：</p><p><img src="/2022/10/06/wyoos006/8259port.PNG" alt="8259port"></p><p>看着是不是有些熟悉了，这就是我们在InterruptManager类的构造函数中设置的四个值。</p><p>我们通过对这四个端口的操作，就可以使8259A芯片正常工作。</p><h3 id="7-1、初始化命令字"><a href="#7-1、初始化命令字" class="headerlink" title="7.1、初始化命令字"></a>7.1、初始化命令字</h3><p>此处参考<a href="https://blog.csdn.net/longintchar/article/details/79439466">资料2</a>，非常感谢！大家给这个姐姐点个赞！</p><p>在8259A可以正常工作之前，必须首先设置初始化命令字 ICW (Initialization Command Words)寄存器组的内容。而在其工作过程中，则可以使用写入操作命令字 OCW (Operation Command Words)寄存器组来随时设置和管理8259A的工作方式。</p><p>观察8259A芯片管脚，存在一个A0端口，这个端口负责控制选择操作的寄存器<strong>当A0&#x3D;0时芯片的端口地址是0x20(主芯片)和0xA0(从芯片）；当 A0&#x3D;1时端口就是0x21(主芯片)和0xA1(从芯片)。</strong></p><p>初始化命令字的编程操作流程如下图所示。由图可以看出，对 ICW1和 ICW2 的设置是必需的。而只有当系统中包含多片 8259A 芯片并且是级联的情况下才需要对 ICW3 进行设置。这需要在 ICW1 的设置中明确指出。 另外，是否需要对 ICW4 进行设置也需要在 ICW1 中指明。<br><img src="/2022/10/06/wyoos006/init8259A.PNG" alt="init8259A"></p><h3 id="7-2、ICW1"><a href="#7-2、ICW1" class="headerlink" title="7.2、ICW1"></a>7.2、ICW1</h3><p>当发送的字节第 5 比特位(D4)&#x3D;1，并且地址线 A0&#x3D;0 时，表示是对 ICW1 编程。此时对于 PC&#x2F;AT 微机系统的多片级联情况下，8259A 主芯片的端口地址是 0x20，从芯片的端口地址是 0xA0。</p><p>ICW1表格如下：</p><p><img src="/2022/10/06/wyoos006/ICW1.png" alt="ICW1"></p><p>我们向ICW1中写入0x11，表示中断请求是边沿触发、多片 8259A 级联并且需要发送 ICW4。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">picMasterCommand.<span class="hljs-built_in">Write</span>(<span class="hljs-number">0x11</span>);<br>picSlaveCommand.<span class="hljs-built_in">Write</span>(<span class="hljs-number">0x11</span>);<br></code></pre></td></tr></table></figure><p>根据流程图，接下来我们需要设定ICW2</p><h3 id="7-3、ICW2"><a href="#7-3、ICW2" class="headerlink" title="7.3、ICW2"></a>7.3、ICW2</h3><p>ICW2 用于设置芯片送出的中断号的高5位。在设置了 ICW1 之后，当 A0&#x3D;1 时表示对 ICW2 进行设置。此时对于PC&#x2F;AT微机系统的多片级联情况下，8259A主芯片的端口地址是0x21，从芯片的端口地址是0xA1。</p><p>ICW2 格式如下:</p><p><img src="/2022/10/06/wyoos006/ICW2.PNG" alt="ICW2"></p><p>ICW2 用于设置芯片送出的中断号的高5位。在设置了 ICW1 之后，当 A0&#x3D;1 时表示对 ICW2 进行设置。此时对于PC&#x2F;AT微机系统的多片级联情况下，8259A主芯片的端口地址是0x21，从芯片的端口地址是0xA1。</p><p>我们的硬件中断是从0x20开始的，每个芯片可以相应8个中断，所以主芯片0x20-0x27，从芯片0x28-0x30。ICW2设定主从芯片的起始中断号，后面的内容由芯片自行填入，所以我们将两块芯片的起始终端号填入0x20以及0x28即可。由因为ICW2只读取终端号的高5位，后面3位置0，而0x20和0x28后3位恰好都是0，所以我们将0x20和0x28写入对应端口即可。这门看来中断号的设置并不是随意设置的，而是和每种芯片的工作原理也是相结合着设定的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">picMasterData.<span class="hljs-built_in">Write</span>(hardwareInterruptOffset);<br>picSlaveData.<span class="hljs-built_in">Write</span>(hardwareInterruptOffset + <span class="hljs-number">0x8</span>);<br></code></pre></td></tr></table></figure><h3 id="7-3、ICW3"><a href="#7-3、ICW3" class="headerlink" title="7.3、ICW3"></a>7.3、ICW3</h3><p>观察ICW1的第一位SNGL&#x3D;0，表示需要级联芯片，根据流程图可以看出我们需要设置ICW3</p><p>地址线A0&#x3D;1，主芯片的端口地址是0x21，从芯片的端口地址是0xA1。</p><p><code>ICW3 (for master device) indicates where the slave is connected to the master.</code></p><p><code>ICW3 (for slave device) indicates where the slave is connected to the master</code></p><p><img src="/2022/10/06/wyoos006/ICW3.PNG" alt="ICW3"></p><p>若8259为主片，ICW3用于指示哪个管脚与从片相连</p><p>哪一位为1，表明哪一位上有从片相连，<br>哪一位为0，表明哪一位上无从片相连。</p><p><code>IR2和从片相连则ICW3为00000100，即0x04</code></p><p><code>IR6和从片相连则ICW3为01000000，即0x40</code></p><p>若8259为从片，ICW3用于指示从片与主片的哪个引脚相连</p><p>相连的内容由后三位指示，高五位置零</p><p><code>和IR2相连则后三位为010,即0x02</code></p><p><code>和IR6相连则后三位为110,即0x06</code></p><p>所以我们要向主片中写入0x04，从片中写入0x02</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">picMasterData.<span class="hljs-built_in">Write</span>(<span class="hljs-number">0x04</span>);<br>picSlaveData.<span class="hljs-built_in">Write</span>(<span class="hljs-number">0x02</span>);<br></code></pre></td></tr></table></figure><h3 id="7-4、ICW4"><a href="#7-4、ICW4" class="headerlink" title="7.4、ICW4"></a>7.4、ICW4</h3><p>ICW1的第0位为1，表示需要设置ICW4</p><p>地址线A0&#x3D;1，主芯片的端口地址是0x21，从芯片的端口地址是0xA1。</p><p><img src="/2022/10/06/wyoos006/ICW4.PNG" alt="ICW4"></p><p>换一张中文图：</p><p><img src="/2022/10/06/wyoos006/ICW4Simple.PNG" alt="ICW4Simple"></p><p>我们向主从芯片中分别写入0x01，表示 8259A 芯片被设置成普通全嵌套、非缓冲、非自动结束中断方式，并且用于 8086 及其兼容系统。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">picMasterData.<span class="hljs-built_in">Write</span>(<span class="hljs-number">0x01</span>);<br>picSlaveData.<span class="hljs-built_in">Write</span>(<span class="hljs-number">0x01</span>);<br></code></pre></td></tr></table></figure><h2 id="8、操作命令字"><a href="#8、操作命令字" class="headerlink" title="8、操作命令字"></a>8、操作命令字</h2><p>在对 8259A 设置了初始化命令字后，芯片就已准备好接收设备的中断请求信号了。但在 8259A 工作期间，我们也可以利用操作命令字 OCW1~OCW3 来监测 8259A 的工作状况，或者随时改变初始化时设定的 8259A 的工作方式。</p><p>需要说明的是，与初始化命令字ICW1～ICW4需要按规定的顺序进行设置不同，操作命令字OCW1～OCW3的设置没有规定其先后顺序，使用时可根据需要灵活选择不同的操作命令字写入到8259A中。</p><h3 id="8-1、OCW1"><a href="#8-1、OCW1" class="headerlink" title="8.1、OCW1"></a>8.1、OCW1</h3><p>OCW1 用于对 8259A 中中断屏蔽寄存器 IMR 进行读&#x2F;写操作。地址线A0&#x3D;1</p><p>若 $M_i&#x3D;1$，则屏蔽对应中断请求级${IR}_i$；若$M_i&#x3D;0$，则允许${IR}_i$. 另外，屏蔽高优先级并不会影响其他低优先级的中断请求。</p><p><img src="/2022/10/06/wyoos006/OCW1.PNG" alt="OCW1"></p><p>这里由于我们不需要屏蔽任何的中断（时钟中断我们只是不做处理，而不是屏蔽，所以在这里不需要设置），所以我们向其中传入0x0</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">picMasterData.<span class="hljs-built_in">Write</span>(<span class="hljs-number">0x00</span>);<br>picSlaveData.<span class="hljs-built_in">Write</span>(<span class="hljs-number">0x00</span>);<br></code></pre></td></tr></table></figure><h3 id="8-2、OCW2"><a href="#8-2、OCW2" class="headerlink" title="8.2、OCW2"></a>8.2、OCW2</h3><p>由于ICW4中第1位AEOI我们设定为非自动结束方式，所以在执行中断之后，我们需要手动输入某些内容告诉8259A 中断已经结束。</p><p>这就使用到了OCW2</p><p><img src="/2022/10/06/wyoos006/OCW2.PNG" alt="OCW2"></p><p>这里是具体OCW2各位表示的内容</p><p><img src="/2022/10/06/wyoos006/OCW2Table.PNG" alt="OCW2Table"></p><p>Linux-0.11 内核仅使用该操作命令字在中断处理过程结束之前向 8259A 发送结束中断（EOI）命令。所使用的OCW2 值为 0x20，表示固定优先级、一般EOI（对应上表的第一行）。</p><p>也就是DoHandleInterrupt中的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> picMasterCommand.<span class="hljs-built_in">Write</span>(<span class="hljs-number">0x20</span>);<br><span class="hljs-keyword">if</span>(hardwareInterruptOffset + <span class="hljs-number">8</span> &lt;= InterruptNumber)&#123;<br>      picSlaveCommand.<span class="hljs-built_in">Write</span>(<span class="hljs-number">0x20</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的判断是在判断从片是否在使用，无论从片是否使用，主片都需要写入0x20</p><h3 id="8-3、OCW3"><a href="#8-3、OCW3" class="headerlink" title="8.3、OCW3"></a>8.3、OCW3</h3><p><a href="https://blog.csdn.net/longintchar/article/details/79439466">再次感谢姐姐</a></p><h2 id="9、总结"><a href="#9、总结" class="headerlink" title="9、总结"></a>9、总结</h2><p>本节内容较多，大家应该结合代码和视频参考资料多多学习，本人也是反复研究之后才写出这篇文章！</p>]]></content>
    
    
    
    <tags>
      
      <tag>wyoos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零开始的操作系统生活05-port</title>
    <link href="/2022/09/30/wyoos005/"/>
    <url>/2022/09/30/wyoos005/</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/anhongzhan/wyoos/tree/master/005">github</a></p><h2 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>操作系统想要实现键盘写入或者其他硬件的相关操作时，需要用到端口读写。</p><p>本节内容较为单一，也没有太多前置知识，主要实现向固定的端口中写入数据以及读取数据。</p><h2 id="2、code"><a href="#2、code" class="headerlink" title="2、code"></a>2、code</h2><p>新建文件<code>port.h</code>,<code>port.cpp</code></p><p>我们需要实现8Bit、16Bit以及32Bit数据的读写</p><p>首先是<code>port.h</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __PORT_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __PORT_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;types.h&quot;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Port</span>&#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">uint16_t</span> portnumber;<br>    <span class="hljs-built_in">Port</span>(<span class="hljs-type">uint16_t</span> portnumber);<br>    ~<span class="hljs-built_in">Port</span>();<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Port8Bit</span> : <span class="hljs-keyword">public</span> Port &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Port8Bit</span>(<span class="hljs-type">uint16_t</span> portnumber);<br>    ~<span class="hljs-built_in">Port8Bit</span>();<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> data)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">uint8_t</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Port16Bit</span> : <span class="hljs-keyword">public</span> Port &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Port16Bit</span>(<span class="hljs-type">uint16_t</span> portnumber);<br>    ~<span class="hljs-built_in">Port16Bit</span>();<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> data)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">uint16_t</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Port32Bit</span> : <span class="hljs-keyword">public</span> Port &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Port32Bit</span>(<span class="hljs-type">uint16_t</span> portnumber);<br>    ~<span class="hljs-built_in">Port32Bit</span>();<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> data)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">uint32_t</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>我们首先创建一个port类表示需要写入的端口，端口长度位16Bit，然后使用具体的8Bit，16Bit，32Bit的类继承并实现读写功能。</p><p>接下来是实现<code>port.cpp</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;port.h&quot;</span></span><br><br><br>Port::<span class="hljs-built_in">Port</span>(<span class="hljs-type">uint16_t</span> portnumber)<br>    : <span class="hljs-built_in">portnumber</span>(portnumber)&#123;&#125;<br><br>Port::~<span class="hljs-built_in">Port</span>() &#123;&#125;<br><br><span class="hljs-comment">//8Bit</span><br>Port8Bit::<span class="hljs-built_in">Port8Bit</span>(<span class="hljs-type">uint16_t</span> portnumber)<br>    : <span class="hljs-built_in">Port</span>(portnumber)&#123;&#125;<br><br>Port8Bit::~<span class="hljs-built_in">Port8Bit</span>() &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Port8Bit::Write</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> data)</span></span>&#123;<br>    <span class="hljs-function">__asm__ <span class="hljs-title">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;outb %0, %1&quot;</span> : : <span class="hljs-string">&quot;a&quot;</span> (data), <span class="hljs-string">&quot;Nd&quot;</span> (portnumber))</span></span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">uint8_t</span> <span class="hljs-title">Port8Bit::Read</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">uint8_t</span> data;<br>    <span class="hljs-function">__asm__ <span class="hljs-title">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;inb %1, %0&quot;</span> : <span class="hljs-string">&quot;=a&quot;</span> (data) : <span class="hljs-string">&quot;Nd&quot;</span> (portnumber))</span></span>;<br>    <span class="hljs-keyword">return</span> data;<br>&#125;<br><br><span class="hljs-comment">// 16 Bit</span><br>Port16Bit::<span class="hljs-built_in">Port16Bit</span>(<span class="hljs-type">uint16_t</span> portnumber)<br>    : <span class="hljs-built_in">Port</span>(portnumber)&#123;&#125;<br><br>Port16Bit::~<span class="hljs-built_in">Port16Bit</span>() &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Port16Bit::Write</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> data)</span></span>&#123;<br>    <span class="hljs-function">__asm__ <span class="hljs-title">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;outw %0, %1&quot;</span> : : <span class="hljs-string">&quot;a&quot;</span> (data) , <span class="hljs-string">&quot;Nd&quot;</span> (portnumber))</span></span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">uint16_t</span> <span class="hljs-title">Port16Bit::Read</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">uint16_t</span> data;<br>    <span class="hljs-function">__asm__ <span class="hljs-title">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;inw %1, %0&quot;</span> : <span class="hljs-string">&quot;=a&quot;</span> (data) : <span class="hljs-string">&quot;Nd&quot;</span> (portnumber))</span></span>;<br>    <span class="hljs-keyword">return</span> data;<br>&#125;<br><br><span class="hljs-comment">// 32Bit</span><br>Port32Bit::<span class="hljs-built_in">Port32Bit</span>(<span class="hljs-type">uint16_t</span> portnumber)<br>    : <span class="hljs-built_in">Port</span>(portnumber)&#123;&#125;<br><br>Port32Bit::~<span class="hljs-built_in">Port32Bit</span>() &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Port32Bit::Write</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> data)</span></span>&#123;<br>    <span class="hljs-function">__asm__ <span class="hljs-title">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;outl %0, %1&quot;</span> : : <span class="hljs-string">&quot;a&quot;</span> (data) , <span class="hljs-string">&quot;Nd&quot;</span> (portnumber))</span></span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">Port32Bit::Read</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">uint32_t</span> data;<br>    <span class="hljs-function">__asm__ <span class="hljs-title">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;inl %1, %0&quot;</span> : <span class="hljs-string">&quot;=a&quot;</span> (data) : <span class="hljs-string">&quot;Nd&quot;</span> (portnumber))</span></span>;<br>    <span class="hljs-keyword">return</span> data;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们这里仍然采用内嵌汇编的方法实现功能，其中<code>outb</code>以及<code>inb</code>分别表示向固定的端口写入以及读取端口数据</p><h2 id="3、slow-write"><a href="#3、slow-write" class="headerlink" title="3、slow write"></a>3、slow write</h2><p>最后，我们需要实现一个<strong>慢写入</strong>，这里面由于未查到资料，所以并不清楚实现慢写入的原因，暂时码住。</p><p><code>port.h</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Port8BitSlow</span> : <span class="hljs-keyword">public</span> Port8Bit &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Port8BitSlow</span>(<span class="hljs-type">uint16_t</span> portnumber);<br>    ~<span class="hljs-built_in">Port8BitSlow</span>();<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> data)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>port.cpp</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Port8BitSlow::<span class="hljs-built_in">Port8BitSlow</span>(<span class="hljs-type">uint16_t</span> portnumber)<br>    : <span class="hljs-built_in">Port8Bit</span>(portnumber)&#123;&#125;<br><br>Port8BitSlow::~<span class="hljs-built_in">Port8BitSlow</span>() &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Port8BitSlow::Write</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> data)</span></span>&#123;<br>    <span class="hljs-function">__asm__ <span class="hljs-title">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;outb %0, %1\njmp 1f\n1: jmp 1f\n1:&quot;</span> : : <span class="hljs-string">&quot;a&quot;</span> (data) , <span class="hljs-string">&quot;Nd&quot;</span> (portnumber))</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，慢写入的汇编语句如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">outb</span> data, portnumber<br><span class="hljs-attribute">jmp</span> <span class="hljs-number">1</span>f<br><span class="hljs-attribute">1</span>: jmp <span class="hljs-number">1</span>f<br><span class="hljs-attribute">1</span>:<br></code></pre></td></tr></table></figure><p>上面的data以及portnumber不是真实的汇编语句，这里只是为了说明汇编语句的操作，而且主要目的是介绍下面的内容</p><p><code>jmp 1f</code>，f表示向下跳转，跳转到1这个位置，到达1这个位置之后又出现了一句<code>jmp 1f</code>，再次向下跳转无汇编语句，执行结束。</p><p>我们通过两次跳转指令实现了慢写入，也就是在执行<code>outb</code>汇编指令之后做一些无用功，然后再返回，应该是为了等待一些工作的完成。</p>]]></content>
    
    
    
    <tags>
      
      <tag>wyoos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零开始的操作系统生活04-GDT</title>
    <link href="/2022/09/26/wyoos004/"/>
    <url>/2022/09/26/wyoos004/</url>
    
    <content type="html"><![CDATA[<p>本节代码地址<a href="https://github.com/anhongzhan/wyoos/tree/master/004">github</a></p><h2 id="1、从实模式到保护模式"><a href="#1、从实模式到保护模式" class="headerlink" title="1、从实模式到保护模式"></a>1、从实模式到保护模式</h2><p><a href="https://wiki.osdev.org/Real_Mode">实模式(Real mode)</a>是x86处理器中的一种16位的寻址方式，但是x86处理器的物理地址有20位，为了实现20位的寻址，x86处理器采用了基地址(base)+偏移量(offset)的方法进行寻址，具体的寻址方式 base&lt;&lt; 4 + offset，寻址空间有$$2^{20}$$一共1MB的地址空间，这对于早期的处理器来说足够使用了，但随着技术的发展，逐渐出现了两个问题：</p><ul><li>地址空间逐渐不足</li><li>非法访问内存问题</li></ul><p>地址空间不足问题很好理解，程序主键变得复杂，需要的空间会逐渐增加。对于非法访问内存，实模式下的内存访问方式可以访问任何一块内存，但是实际上很多内容比如内核代码和数据等是不允许访问或者修改的，所以就需要对内存进行规划，于是就出现了<a href="https://wiki.osdev.org/Protected_Mode">保护模式(Protected Mode)</a>。</p><p>保护模式采用32位的寻址方式，理论的寻址空间有4GB，这样就可以解决地址空间不足的问题。对于内存非法访问的问题，保护模式将内存划分为不同的段(Segment)，比如代码段、数据段、栈段等等，不同的段有不同的访问权限。保护模式下的寻址方式依旧采用基地址+偏移的方式，不过基地址的获取改成了通过GDT来获取，通过GDT就可以对内存访问进行限制，完美的解决非法访问内存问题。</p><h2 id="2、访问GDT"><a href="#2、访问GDT" class="headerlink" title="2、访问GDT"></a>2、访问GDT</h2><p><a href="https://wiki.osdev.org/GDT">Global Descriptor Table</a>，简称GDT，中文名为全局描述符表。</p><p>首先，GDT是一项数据结构，从名称table就可以知道GDT是一张表，表中肯定存储很多数据，每条数据就是一个描述符(descriptor)。</p><p>然后，这张表肯定要存储到某块内存，如何寻址到这块内存，就需要访问GDTR，R是register的意思，这个寄存器专门存储GDT表的内存地址以便访问。我们可以使用汇编语句lgdt对GDTR进行加载。</p><p><img src="/2022/09/26/wyoos004/GDTR.PNG" alt="GDTR"></p><p>GDTR是一个48位的数据结构，高32位存储GDT的地址，低16位存储表的尺寸，记录了表的存储项，同时也规定了最大的表的数量</p><p>其次，具体的访问方式。操作系统中指定下一条指令的寄存器为cs+eip，cs存储基地址，eip存储偏移。cs的访问方式转换为段选择子(Segment Selector)的访问方式：</p><p><img src="/2022/09/26/wyoos004/SegmentSelector.PNG" alt="SegmentSelector"></p><p>cs是16位的寄存器，最低的两位RPL，全称是Requested Privilege Level，表示访问权限，用两位数据表示说明最多有4个访问权限。</p><p>接下来的TI位表示需要访问GDT还是LDT，Index表示需要访问GDT的表项，即GDT中的第Index项。这样，通过访问GDT得到基地址即可。</p><h2 id="3、柳暗花明，终于开始访问GDT了"><a href="#3、柳暗花明，终于开始访问GDT了" class="headerlink" title="3、柳暗花明，终于开始访问GDT了"></a>3、柳暗花明，终于开始访问GDT了</h2><p>GDT中的表项叫做段描述符(Segment Descriptor)，我们所访问的内容就是第Index个描述符，下面是描述符的数据结构：</p><p><img src="/2022/09/26/wyoos004/SegmentDescriptor.PNG" alt="SegmentDescriptor"></p><p>段描述符是一个64位的数据结构，从具体的表项可以看出，我们可以拼出一个32位的基地址Base，这样就可以与偏移Offset结合得到访问地址。</p><p>其他的表项内容请大家自行学习，而且是必须学会的，本人也在学习过程中，所以这里不做展开。</p><h2 id="4、串联一下"><a href="#4、串联一下" class="headerlink" title="4、串联一下"></a>4、串联一下</h2><p>首先我们将GDT表填好并放在某块内存，通过lgdt指令设定GDTR，以便访问GDT。</p><p>设定好cs+eip寄存器的内容，cs通过段选择子(Segment Selector)找出需要访问GDT的哪一项。</p><p>然后我们根据GDTR找到相对应的段描述符(Segment Descriptor)，通过描述符的内容可以找出基地址(BASE)</p><p>这里面基地址直接与偏移offset相加即可。</p><p>这样我们就能跳转到下一条指令了。</p><h2 id="5、该写代码了"><a href="#5、该写代码了" class="headerlink" title="5、该写代码了"></a>5、该写代码了</h2><p>新建文件<code>gdt.h</code>、<code>gdt.cpp</code>、<code>types.h</code></p><p>首先是types.h，这里面主要将一些常用的数据结构设定为操作系统中常用的形式，内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __TYPES_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __TYPES_H</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> <span class="hljs-type">int8_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> <span class="hljs-type">uint8_t</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">short</span> <span class="hljs-type">int16_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">uint16_t</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> <span class="hljs-type">int32_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-type">uint32_t</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-type">int64_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-type">uint64_t</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>然后是gdt.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __GDT_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __GDT_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;types.h&quot;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GlobalDescriptorTable</span>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">SegementDescriptor</span>&#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SegementDescriptor</span>(<span class="hljs-type">uint32_t</span> base, <span class="hljs-type">uint32_t</span> limit, <span class="hljs-type">uint8_t</span> type);<br><br>    <span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">Base</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">Limit</span><span class="hljs-params">()</span></span>;<br><br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">uint16_t</span> limit_lo;<br>    <span class="hljs-type">uint16_t</span> base_lo;<br>    <span class="hljs-type">uint8_t</span> base_hi;<br>    <span class="hljs-type">uint8_t</span> type;<br>    <span class="hljs-type">uint8_t</span> flags_limit_hi;<br>    <span class="hljs-type">uint8_t</span> base_vhi;<br>  &#125; __attribute__((packed));<br><br>  SegementDescriptor nullSegmentDescriptor;<br>  SegementDescriptor unusedSegmentDescriptor;<br>  SegementDescriptor codeSegmentDescriptor;<br>  SegementDescriptor dataSegmentDescriptor;<br><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">GlobalDescriptorTable</span>();<br>  ~<span class="hljs-built_in">GlobalDescriptorTable</span>();<br><br>  <span class="hljs-function"><span class="hljs-type">uint16_t</span> <span class="hljs-title">CodeSegmentSelector</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">uint16_t</span> <span class="hljs-title">DataSegmentSelector</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>GDT的基地址、limit以及type数据外部数据可能会访问，所以设定为public</p><p>其他的位的数据则设定位private，<code>__attribute__((packed))</code>作用是告诉编译器取消结构在编译过程中的优化对齐，<a href="https://zhuanlan.zhihu.com/p/30007037">内存对齐参考</a></p><p>其他的还有一些空描述符（GDT的第0项就是空描述符），不可用描述符（暂时未接触到），数据段描述符、代码段描述符（这两部分可以参考S位以及type位的类型，就可以知道不同的段代表不同的内容）。</p><p>接下来使用<code>gdt.cpp</code>进行实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;gdt.h&quot;</span></span><br><br>GlobalDescriptorTable::<span class="hljs-built_in">GlobalDescriptorTable</span>()<br>  : <span class="hljs-built_in">nullSegmentDescriptor</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>),<br>  <span class="hljs-built_in">unusedSegmentDescriptor</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>),<br>  <span class="hljs-built_in">codeSegmentDescriptor</span>(<span class="hljs-number">0</span>, <span class="hljs-number">64</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>, <span class="hljs-number">0x9a</span>),<br>  <span class="hljs-built_in">dataSegmentDescriptor</span>(<span class="hljs-number">0</span>, <span class="hljs-number">64</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>, <span class="hljs-number">0x92</span>)&#123;<br>    <span class="hljs-type">uint32_t</span> i[<span class="hljs-number">2</span>];<br>    i[<span class="hljs-number">1</span>] = (<span class="hljs-type">uint32_t</span>)<span class="hljs-keyword">this</span>;<br>    i[<span class="hljs-number">0</span>] = <span class="hljs-built_in">sizeof</span>(GlobalDescriptorTable) &lt;&lt; <span class="hljs-number">16</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">asm</span> <span class="hljs-title">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;lgdt (%0)&quot;</span>: :<span class="hljs-string">&quot;p&quot;</span> (((<span class="hljs-type">uint8_t</span> *)i) + <span class="hljs-number">2</span>))</span></span>;<br>&#125;<br><br>GlobalDescriptorTable::~<span class="hljs-built_in">GlobalDescriptorTable</span>() &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">uint16_t</span> <span class="hljs-title">GlobalDescriptorTable::DataSegmentDescriptor</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> (<span class="hljs-type">uint8_t</span>*)&amp;dataSegmentDescriptor - (<span class="hljs-type">uint8_t</span>*)<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">uint16_t</span> <span class="hljs-title">GlobalDescriptorTable::CodeSegmentDescriptor</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">return</span> (<span class="hljs-type">uint8_t</span>*)&amp;codeSegmentDescriptor - (<span class="hljs-type">uint8_t</span>*)<span class="hljs-keyword">this</span>;<br>&#125;<br><br>GlobalDescriptorTable::SegementDescriptor::<span class="hljs-built_in">SegementDescriptor</span>(<span class="hljs-type">uint32_t</span> base, <span class="hljs-type">uint32_t</span> limit, <span class="hljs-type">uint8_t</span> type)&#123;<br>  <span class="hljs-type">uint8_t</span>* target = (<span class="hljs-type">uint8_t</span>*)<span class="hljs-keyword">this</span>;<br><br>  <span class="hljs-keyword">if</span>(limit &lt; <span class="hljs-number">65536</span>)&#123;<br>    target[<span class="hljs-number">6</span>] = <span class="hljs-number">0x40</span>;<br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">if</span>((limit &amp; <span class="hljs-number">0xfff</span>) != <span class="hljs-number">0xfff</span>)&#123;<br>      limit = (limit &gt;&gt; <span class="hljs-number">12</span>) - <span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>      limit = limit &gt;&gt; <span class="hljs-number">12</span>;<br>    &#125;<br>    target[<span class="hljs-number">6</span>] = <span class="hljs-number">0xC0</span>;<br>  &#125;<br><br>  <span class="hljs-comment">//limit</span><br>  target[<span class="hljs-number">0</span>] = limit &amp; <span class="hljs-number">0xff</span>;<br>  target[<span class="hljs-number">1</span>] = (limit &gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xff</span>;<br>  target[<span class="hljs-number">6</span>] = (limit &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xf</span>;<br><br>  <span class="hljs-comment">//base</span><br>  target[<span class="hljs-number">2</span>] = base &amp; <span class="hljs-number">0xff</span>;<br>  target[<span class="hljs-number">3</span>] = (base &gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xff</span>;<br>  target[<span class="hljs-number">4</span>] = (base &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xff</span>;<br>  target[<span class="hljs-number">7</span>] = (base &gt;&gt; <span class="hljs-number">24</span>) &amp; <span class="hljs-number">0xff</span>;<br><br>  <span class="hljs-comment">//type</span><br>  target[<span class="hljs-number">5</span>] = type;<br>&#125;<br><br><span class="hljs-type">uint32_t</span> GlobalDescriptorTable::SegementDescriptor::<span class="hljs-built_in">Base</span>()&#123;<br>  <span class="hljs-type">uint8_t</span>* target = (<span class="hljs-type">uint8_t</span>*)<span class="hljs-keyword">this</span>;<br>  <span class="hljs-type">uint32_t</span> result = target[<span class="hljs-number">7</span>];<br>  result = (result &lt;&lt; <span class="hljs-number">8</span>) + target[<span class="hljs-number">4</span>];<br>  result = (result &lt;&lt; <span class="hljs-number">8</span>) + target[<span class="hljs-number">3</span>];<br>  result = (result &lt;&lt; <span class="hljs-number">8</span>) + target[<span class="hljs-number">2</span>];<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-type">uint32_t</span> GlobalDescriptorTable::SegementDescriptor::<span class="hljs-built_in">Limit</span>()&#123;<br>  <span class="hljs-type">uint8_t</span>* target = (<span class="hljs-type">uint8_t</span>*)<span class="hljs-keyword">this</span>;<br>  <span class="hljs-type">uint32_t</span> result = target[<span class="hljs-number">6</span>] &amp; <span class="hljs-number">0xf</span>;<br>  result = (result &lt;&lt; <span class="hljs-number">8</span>) + target[<span class="hljs-number">1</span>];<br>  result = (result &lt;&lt; <span class="hljs-number">8</span>) + target[<span class="hljs-number">0</span>];<br><br>  <span class="hljs-keyword">if</span>((target[<span class="hljs-number">6</span>] &amp; <span class="hljs-number">0xC0</span>) == <span class="hljs-number">0xC0</span>)&#123;<br>    result = (result &lt;&lt; <span class="hljs-number">12</span>) | <span class="hljs-number">0xfff</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，下面的部分是在设定GDTR，GDTR前32位表示GDT的基地址，后16位代表GDT中表项的内容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">uint32_t</span> i[<span class="hljs-number">2</span>];<br>i[<span class="hljs-number">1</span>] = (<span class="hljs-type">uint32_t</span>)<span class="hljs-keyword">this</span>;<br>i[<span class="hljs-number">0</span>] = <span class="hljs-built_in">sizeof</span>(GlobalDescriptorTable) &lt;&lt; <span class="hljs-number">16</span>;<br><span class="hljs-function"><span class="hljs-keyword">asm</span> <span class="hljs-title">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;lgdt (%0)&quot;</span>: :<span class="hljs-string">&quot;p&quot;</span> (((<span class="hljs-type">uint8_t</span> *)i) + <span class="hljs-number">2</span>))</span></span>;<br></code></pre></td></tr></table></figure><p><code>asm</code>是cpp中使用汇编语句，<code>volatile</code>是防止汇编语句被编译器优化掉，内嵌汇编的具体格式为：</p><p>(“指令列表”:”输出列表”:”输入列表”:”破坏描述部分”);注意，括号中的冒号缺一不可，没有输入或者输出可以空着</p><p><code>%0 %1</code>代表出现的第一个第二个寄存器名，<code>p</code>表示下面的操作数是一个合法的地址。</p><p>下面的函数都是通过GDT表的具体表项，将需要的数据拼接出来，比如<code>Base()</code>函数就是将段描述符中的三部分拼接到一起得到的。</p><p>其他的内容也是如此，段描述符函数<code>SegementDescriptor</code>需要参考段描述符每一位代表的内容，所以需要进行判断是否大于65536等内容。</p><h2 id="6、还有Makefile"><a href="#6、还有Makefile" class="headerlink" title="6、还有Makefile"></a>6、还有Makefile</h2><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">objects</span> <span class="hljs-operator">=</span> loader.o kernel.o gdt.o<br></code></pre></td></tr></table></figure><p>在objects后面增加gdt.o即可，然后进行编译即可、</p><h2 id="7、运行结果"><a href="#7、运行结果" class="headerlink" title="7、运行结果"></a>7、运行结果</h2><p>由于我们只是将GDT建立起来而没有使用，所以运行结果不会有任何区别，只要不报错就算成功！</p><h2 id="8、补充"><a href="#8、补充" class="headerlink" title="8、补充"></a>8、补充</h2><p>从实模式到保护模式是操作系统中非常精彩的内容，请大家多查阅一些资料学习一下！</p>]]></content>
    
    
    
    <tags>
      
      <tag>wyoos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零开始的操作系统生活03-镜像制作</title>
    <link href="/2022/09/21/wyoos003/"/>
    <url>/2022/09/21/wyoos003/</url>
    
    <content type="html"><![CDATA[<h2 id="0、环境配置"><a href="#0、环境配置" class="headerlink" title="0、环境配置"></a>0、环境配置</h2><p>安装grub-legacy与xorriso，最后我们会将制作好的镜像放入虚拟机中运行，而不是在虚拟机中再安装一个虚拟机运行</p><p>但是安装grub-legacy时会发现报错了，原因应该是因为版本迭代问题导致的，最新的安装包名称应该是grub-efi-amd64</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> install grub-efi-amd64 xorriso<br></code></pre></td></tr></table></figure><p><a href="https://github.com/anhongzhan/wyoos/tree/master/003">github</a></p><h2 id="1、mykernel-iso"><a href="#1、mykernel-iso" class="headerlink" title="1、mykernel.iso"></a>1、mykernel.iso</h2><p>我们在使用虚拟机安装ubuntu系统的时候，选择的虚拟盘都是.iso后缀格式的，ISO文件是光盘的镜像文件，所有我们要做的事情就是将我们目前所写的内容转换成ISO镜像然后使用虚拟机打开即可</p><p><a href="https://www.gnu.org/software/grub/">GRUB</a>是一款multiboot loader，在链接中我们可以看到，grub-legacy已经不再维护了，所以我们需要安装替代的包，前面我们提过loader使用multiboot规范，multiboot规范对应的就是Multiboot loader</p><p><a href="https://www.gnu.org/software/xorriso/">xorriso</a>是一个用来创建和操作ISO 9660文件系统映像文件的工具，可以用来将影响文件烧录到DVD&#x2F;CD中</p><p>接下来开始制作镜像</p><p>我们在Makefile中添加如下语句：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">mykernel.iso: mykernel.bin<br><span class="hljs-built_in">mkdir</span> iso<br><span class="hljs-built_in">mkdir</span> iso/boot<br><span class="hljs-built_in">mkdir</span> iso/boot/grub<br><span class="hljs-built_in">cp</span> $&lt; iso/boot/<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;set timeout=0&#x27;</span> &gt;&gt; iso/boot/grub/grub.cfg<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;set default=0&#x27;</span> &gt;&gt; iso/boot/grub/grub.cfg<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;&#x27;</span> &gt;&gt; iso/boot/grub/grub.cfg<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;menuentry &quot;My Operating System&quot; &#123;&#x27;</span> &gt;&gt; iso/boot/grub/grub.cfg<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;multiboot /boot/mykernel.bin&#x27;</span> &gt;&gt; iso/boot/grub/grub.cfg<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;boot&#x27;</span> &gt;&gt; iso/boot/grub/grub.cfg<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;&#125;&#x27;</span> &gt;&gt; iso/boot/grub/grub.cfg<br>grub-mkrescue --output=<span class="hljs-variable">$@</span> iso<br><span class="hljs-built_in">rm</span> -rf iso<br></code></pre></td></tr></table></figure><p>前三句命令负责创建对应文件夹，**$&lt;**表示第一个依赖文件，也就是把mykernel.bin复制到&#x2F;iso&#x2F;boot&#x2F;文件夹中去</p><p>grub是引导操作系统的程序，他会根据自己的配置文件去引导内核，这项配置文件就是grub.cfg</p><p><em>set timeout&#x3D;0</em>是设置启动等待的时间，加入我们的电脑存在两个系统，设置timeout&#x3D;10，则进入系统之前会给我们10s的时间去选择进入哪一个系统</p><p><em>set default&#x3D;0</em>表示设置默认进入的系统，计算机都是从0开始的，也就是默认进入第一个系统。当然，我们也只有这一个系统</p><p><em>menuentry</em>指设置启动菜单，<em>My Operating System</em>是菜单名称，<em>multiboot &#x2F;boot&#x2F;mykernel.bin</em>是指其中的一个启动项</p><p><strong>下面的<em>boot</em>不清楚是干什么的，暂时码住，以后有机会回来解释</strong></p><p>运行结束后的grub.cfg内容如下所示：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">set</span> <span class="hljs-attribute">timeout</span>=0<br><span class="hljs-built_in">set</span> <span class="hljs-attribute">default</span>=0<br><br>menuentry <span class="hljs-string">&quot;My Operating System&quot;</span> &#123;<br>multiboot /boot/mykernel.bin<br>boot<br>&#125;<br><br></code></pre></td></tr></table></figure><p>像看到这个文件内容则需要删除makefile的最后一句rm -rf iso，但是记得下一次编译的时候加上这句话并且先把iso文件夹删除掉</p><p>最后<em>grub-mkrescue --output&#x3D;$@ iso</em>则是使用grub-mkrescue命令制作镜像文件，–output是指定输出文件，<strong>但是后面的iso我并不清楚是什么作用，如果是指定文件夹，那么生成的mykernel.iso会在&#x2F;iso中，但实际上是与&#x2F;iso同名文件夹，也不需要修改文件的后缀，甚至稍作修改也不会出现问题，此处码住，有待解决</strong></p><p>最后的<em>rm -rf iso</em>就是删除无用的文件夹</p><h2 id="2、打开mykernel-iso"><a href="#2、打开mykernel-iso" class="headerlink" title="2、打开mykernel.iso"></a>2、打开mykernel.iso</h2><p>激动人心的时刻到了，我们经过了三节的努力，终于可以看到一些成果了</p><p>首先，本人使用的是virtualbox虚拟机安装的ubuntu 20.04系统，生成的iso镜像文件也在ubuntu系统中，想要再次使用虚拟机运行则需要将iso文件拷贝到windows系统中，这部分使用共享文件夹或者直接拖动即可，大家根据自身情况自行解决这个问题</p><p>然后打开VirtualBox，选择新建</p><p><img src="/2022/09/21/wyoos003/newVirtual.PNG" alt="newVirtual"></p><p>操作系统类型和版本要选择Other</p><p>点击下一步之后打开虚拟机，然后选择设备-&gt;分配光驱-&gt;选择虚拟盘</p><p><img src="/2022/09/21/wyoos003/open.png" alt="open"></p><p>然后将我们制作好的iso镜像添加进去，关闭虚拟机后再次开启即可。</p><p>最后的运行效果如下：</p><p><img src="/2022/09/21/wyoos003/result.png" alt="result"></p><h2 id="3、补充"><a href="#3、补充" class="headerlink" title="3、补充"></a>3、补充</h2><h3 id="3-1、timeout"><a href="#3-1、timeout" class="headerlink" title="3.1、timeout"></a>3.1、timeout</h3><p>大家也可以试试修改Makefile中的set timeout&#x3D;10，然后再运行看看结果</p><h3 id="3-2、VirtualBox虚拟机中使用VirtualBox"><a href="#3-2、VirtualBox虚拟机中使用VirtualBox" class="headerlink" title="3.2、VirtualBox虚拟机中使用VirtualBox"></a>3.2、VirtualBox虚拟机中使用VirtualBox</h3><p>为了方便运行我们的结果，而不是来回调换系统运行调试，并且在参考视频的提示下，我们最终选择使用VIrtualBox虚拟机中再安装VirtualBox虚拟机</p><p>首先我的ubuntu虚拟机配置 8192MB 显存 16MB</p><p>在ubuntu中安装VirtualBox之前记得设置windows的VirtualBox中的<strong>启用嵌套VT-x&#x2F;AMD-V</strong></p><p>具体设置方式如下：设置-&gt;系统-&gt;处理器-&gt;启用嵌套VT-x&#x2F;AMD-V</p><p>如果<strong>启用嵌套VT-x&#x2F;AMD-V</strong>是灰色的，请参考<a href="https://www.cnblogs.com/88223100/p/How_to_enable_Nested_VT-x_AMD-V_on_VirtualBox.html">链接</a></p><p>然后虚拟机中安装VirtualBox</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> install VirtualBox<br></code></pre></td></tr></table></figure><p>安装完毕之后打开VIrtualBox，然后和前面的流程相同，创建新的虚拟电脑，不添加镜像，启动虚拟电脑然后添加镜像，最后重启虚拟电脑即可。</p><p>最后的最后，我们在Makefile中添加内容</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-built_in">run</span>: mykernel.iso<br>(killall virtualboxvm &amp;&amp; <span class="hljs-built_in">sleep</span> <span class="hljs-number">1</span>) || <span class="hljs-literal">true</span><br>virtualboxvm --startvm <span class="hljs-string">&quot;wyoos&quot;</span> &amp;<br></code></pre></td></tr></table></figure><p>这样每次我们编译完成后只要执行<strong>make run</strong>即可</p>]]></content>
    
    
    
    <tags>
      
      <tag>wyoos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零开始的操作系统生活02-对Hello World的补充</title>
    <link href="/2022/09/20/wyoos002/"/>
    <url>/2022/09/20/wyoos002/</url>
    
    <content type="html"><![CDATA[<h2 id="1、开始"><a href="#1、开始" class="headerlink" title="1、开始"></a>1、开始</h2><p><a href="https://github.com/anhongzhan/wyoos/tree/master/002">github</a></p><h3 id="1-1、环境配置"><a href="#1-1、环境配置" class="headerlink" title="1.1、环境配置"></a>1.1、环境配置</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">sudo apt-get <span class="hljs-keyword">install </span>g++ <span class="hljs-keyword">binutils </span>libc6-dev-i386<br></code></pre></td></tr></table></figure><h3 id="1-2、对linker-ld的补充"><a href="#1-2、对linker-ld的补充" class="headerlink" title="1.2、对linker.ld的补充"></a>1.2、对linker.ld的补充</h3><p>linker脚本是用来控制link过程的文件，文件中包含内容为linker的处理命令，主要用于描述输入文件到输出文件时各个内容的分步以及内存映射等</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">ENTRY(<span class="hljs-params">loader</span>)</span><br><span class="hljs-constructor">OUTPUT_FORMAT(<span class="hljs-params">elf32</span>-<span class="hljs-params">i386</span>)</span><br><span class="hljs-constructor">OUTPUT_ARCH(<span class="hljs-params">i386</span>:<span class="hljs-params">i386</span>)</span><br><br>SECTIONS<br>&#123;<br>  . = <span class="hljs-number">0x0100000</span>;<br><br>  .text : <br>  &#123;<br>    *(.multiboot)<br>    *(.text*)<br>    *(.rodata)<br>  &#125;<br><br>  .data :<br>  &#123;<br>    start_ctors = .;<br>    <span class="hljs-constructor">KEEP(<span class="hljs-operator">*</span>( .<span class="hljs-params">init_array</span> )</span>);<br>    <span class="hljs-constructor">KEEP(<span class="hljs-operator">*</span>(SORT_BY_INIT_PRIORITY( .<span class="hljs-params">init_array</span>.<span class="hljs-operator">*</span> )</span>));<br>    end_ctors = .;<br><br>    *(.data)<br>  &#125;<br><br>  .bss :<br>  &#123;<br>    *(.bss)<br>  &#125;<br><br>  /DISCARD/ : <br>  &#123;<br>    *(.fini_array*)<br>    *(.comment)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-2-1、首地址设置"><a href="#1-2-1、首地址设置" class="headerlink" title="1.2.1、首地址设置"></a>1.2.1、首地址设置</h4><p>首先是.SECTION{}中第一句*. &#x3D; 0x0100000;*</p><p>这句话的意思是设置我们所要输出的文件的字段的起始地址，比如我们将地址设置为0x100000，则后面的.text段就从该地址开始放置，紧接着是.data段和.bss段，同样我们也可以使用如下方法：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">. </span>= 0x010000;<br><span class="hljs-title">.text : </span><br>&#123;<br>&#125;<br><span class="hljs-bullet">. </span>= 0x080000;<br><span class="hljs-title">.data :</span><br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>将不同的段放置在不同的区域</p><h4 id="1-2-2、data段的设置"><a href="#1-2-2、data段的设置" class="headerlink" title="1.2.2、data段的设置"></a>1.2.2、data段的设置</h4><p>接下来是.data段中的内容，ELF文件中对于.data段的描述是：<em>已初始化的全局和静态C变量</em></p><p>在调用KernelMain方法之前，我们还需要的一个步骤就是保证初始化必要的全局变量，这些全局变量存放在**.init_array**段中。</p><p>为了完成以上操作，我们还需要在Kernel.cpp中添加初始化函数<strong>callConstructors()<strong>，该函数获取</strong>.init_array</strong>段中的指令</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">typedef <span class="hljs-title">void</span> (<span class="hljs-params">*constructor</span>)()</span>;<br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> constructor start_ctors;<br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> constructor end_ctors;<br><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">callConstructors</span>()</span>&#123;<br>    <span class="hljs-keyword">for</span>(constructor* i = &amp;start_ctors; i != &amp;end_ctors; i++)&#123;<br>        (*i)();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>这里面其实我也不是很清楚内部的运行机制，暂时码住，以后遇到答案之后再回来做出解释</strong></p><p><em>补充一：kernel.cpp中两个函数start_ctors与end_stors获取到linker.ld中的两个位置，然后执行linker.ld两个位置之间的命令（代码）</em></p><p>还记得我们前面说过，在<strong>loader.s</strong>中需要暴漏<strong>KernelMain</strong>的地址让链接器知道吗？同理，我们也需要暴漏<strong>callConstructors</strong>的地址，也就是在<strong>loader.s</strong>中添加如下代码：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">.section</span> <span class="hljs-string">.text</span><br><span class="hljs-string">.extern</span> kernelMain<br><span class="hljs-string">.extern</span> callConstructors<br><span class="hljs-string">.global</span> loader<br></code></pre></td></tr></table></figure><p>第三行代码为我们刚刚所添加的内容</p><p>最后我们来看.data段中的内容，第一句与最后一句分别为start_ctors和end_ctors，这两部分是链接器指定的两个具体地址，然后将初始化指令，也就是.data段中的数据放置在这两段地址之间，也就是说链接器指定了一段空间用于存放.data段的数据，也就是**.init_array*<em>，前面提到过，</em>KEEP的作用是即使为引用符号，我们也要保留这部分*，另一种解释方法就是KEEP函数可以保证数据不被系统释放，属于对全局变量的保护，也可能是出于对程序生命周期的考虑。</p><p><strong>SORT_BY_INIT_PRIORITY</strong>函数会对**.init_array**中的数据以升序的方式进行排序，然后再放置到输出文件中</p><h4 id="1-2-3、-x2F-DISCARD-x2F"><a href="#1-2-3、-x2F-DISCARD-x2F" class="headerlink" title="1.2.3、&#x2F;DISCARD&#x2F;"></a>1.2.3、&#x2F;DISCARD&#x2F;</h4><p>放置在**&#x2F;DISCARD&#x2F;**段中的内容不会被链接器输出出去</p><h3 id="1-3、printf函数"><a href="#1-3、printf函数" class="headerlink" title="1.3、printf函数"></a>1.3、printf函数</h3><p>还记得上一节中我们写的<strong>kernel.cpp</strong>文件吗，里面调用了printf函数进行打印，但是我们并没有引入头文件，结果可想而知，肯定无法编译过去，报错内容如下：<em>identifier “printf” is undefined</em></p><p>printf函数本身就是调用操作系统的函数然后进行打印，所以我们不可以直接引入头文件进行编译，必须自己实现，实现的方法如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printf</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str)</span></span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> *VideoMemory = (<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>*)<span class="hljs-number">0xb8000</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;str[i];i++)&#123;<br>        VideoMemory[i] = (VideoMemory[i] &amp; <span class="hljs-number">0xFF00</span>) | str[i];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://wiki.osdev.org/Printing_To_Screen">0xb8000</a>是操作系统向屏幕写入数据的第一个地址，我们只需要将数据一次写入相应的地址，最后就能够打印出来</p><p>根据<a href="https://wiki.osdev.org/Printing_To_Screen">0xb8000</a>中的介绍，操作系统使用两个字节存储一个字符，第一个字节存储字符内容，第二个字节存储字符的颜色，我们这里不关心颜色，所以只需要将每一个低位字节置零之后将要写入的字符“与”进去即可。</p><p>同时我们也需要注意大端和小端的问题！！！</p><p>也就是<strong>VideoMemory[i] &#x3D; (VideoMemory[i] &amp; 0xFF00) | str[i];</strong></p><h3 id="1-4、运行结果"><a href="#1-4、运行结果" class="headerlink" title="1.4、运行结果"></a>1.4、运行结果</h3><p>直接运行<strong>make mykernel.bin</strong>，可以得到如下的文件序列：</p><p><img src="/2022/09/20/wyoos002/%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.PNG" alt="运行结果"></p><p>或者也可以分步运行：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-built_in">make</span> kernel.o<br><span class="hljs-built_in">make</span> loader.o<br><span class="hljs-built_in">make</span> mykernel.bin<br></code></pre></td></tr></table></figure><h2 id="2、后记"><a href="#2、后记" class="headerlink" title="2、后记"></a>2、后记</h2><p>在看<a href="https://www.bilibili.com/video/BV1RX4y157CM?p=1&vd_source=71ff1308c23d0ef0791f945a3cc515e6">视频链接1</a>进行学习以及在网上查阅资料时发现了一处不太一样的地方，我们使用<em>objdump -d kernel.o</em>进行反汇编时可能会发现<strong>KernelMain</strong>等函数编译后的方法名称有可能变成**_KernelMain**，这就需要对loader.s以及linker.ld进行修改，修改的方法就是把反汇编的名称替换原来的名称，具体做法可以参照<a href="https://www.bilibili.com/video/BV1RX4y157CM?p=1&vd_source=71ff1308c23d0ef0791f945a3cc515e6">视频链接1</a>，但是我并没有遇到这个问题</p>]]></content>
    
    
    
    <tags>
      
      <tag>wyoos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零开始的操作系统生活01-Hello World</title>
    <link href="/2022/09/19/wyoos001/"/>
    <url>/2022/09/19/wyoos001/</url>
    
    <content type="html"><![CDATA[<h2 id="0、目标"><a href="#0、目标" class="headerlink" title="0、目标"></a>0、目标</h2><p>使用cpp开发一个操作系统，具体能走到哪一步看毅力，加油！</p><h2 id="1、参考内容"><a href="#1、参考内容" class="headerlink" title="1、参考内容"></a>1、参考内容</h2><p><a href="https://www.bilibili.com/video/BV1RX4y157CM?p=1&vd_source=71ff1308c23d0ef0791f945a3cc515e6">视频链接1</a></p><p><a href="https://www.bilibili.com/video/BV1Ut411o7VG?p=2&share_medium=android&share_plat=android&share_source=COPY&share_tag=s_i&timestamp=1614198935&unique_k=Vu8Mmp&vd_source=71ff1308c23d0ef0791f945a3cc515e6">视频链接2</a></p><p><a href="https://github.com/anhongzhan/wyoos/tree/master/001">github</a></p><h2 id="2、开始"><a href="#2、开始" class="headerlink" title="2、开始"></a>2、开始</h2><p><a href="https://zh.wikipedia.org/zh-hans/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a>是一组主管并控制计算机操作、运用和运行硬件、软件资源和提供公共服务来组织用户交互的相互关联的系统软件程序</p><p>首先观察我们简单的操作系统的目录</p><p><img src="/2022/09/19/wyoos001/index.PNG" alt="index"></p><p>kernel.cpp是我们操作系统的运行程序，loader.s负责把我们的操作系统加载到硬件中运行，linker.ld负责将kernel与loader链接到一起，生成机器能够“读懂”的结构，Makefile负责进行编译。</p><h3 id="2-1、kernel-cpp"><a href="#2-1、kernel-cpp" class="headerlink" title="2.1、kernel.cpp"></a>2.1、kernel.cpp</h3><p>首先我们来编写最简单的操作系统：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">kernelMain</span><span class="hljs-params">(<span class="hljs-type">void</span>* multiboot_structure, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> magicnumber)</span></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world!&quot;</span>);<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们先来看程序的主体部分</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">kernelMain</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world!&quot;</span>);<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>程序主体就是要打印一句hello world，然后无限循环，操作系统本身就是无限循环，这里我们留下两个坑</p><p><em>*extern “C”<strong>以及</strong>void* multiboot_structure, unsigned int magicnumber</em>*稍后会做出解释</p><h3 id="2-2、GRUB-multiboot引导规范"><a href="#2-2、GRUB-multiboot引导规范" class="headerlink" title="2.2、GRUB multiboot引导规范"></a>2.2、GRUB multiboot引导规范</h3><p>操作系统的启动流程如下：</p><p><img src="/2022/09/19/wyoos001/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png" alt="操作系统启动流程"></p><p><a href="https://cloud.tencent.com/developer/article/1414532">参考链接</a></p><p>图中第三步GRUB引导存在各种各样的规范，我们所使用的称为multiboot引导规范，之所以存在各种规范，原因就是方便进行开发，比如我们下面的loader.s</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">.set</span> MAGIC, <span class="hljs-number">0x1badb002</span><br><span class="hljs-meta">.set</span> FLAGS, (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">0</span> | <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">1</span>)<br><span class="hljs-meta">.set</span> CHECKSUM, -(MAGIC + FLAGS)<br><span class="hljs-meta"></span><br><span class="hljs-meta">.section</span> .multiboot<br><span class="hljs-meta">.long</span> MAGIC<br><span class="hljs-meta">.long</span> FLAGS<br><span class="hljs-meta">.long</span> CHECKSUM<br><span class="hljs-meta">.section</span> .text<br><span class="hljs-meta">.extern</span> kernelMain<br><span class="hljs-meta">.global</span> loader<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">loader:</span><br>    <span class="hljs-keyword">mov</span> $kernel_stack, %esp<br>    <span class="hljs-keyword">push</span> %eax<br>    <span class="hljs-keyword">push</span> %ebx<br>    <span class="hljs-keyword">call</span> kernelMain<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">_stop:</span><br>    <span class="hljs-keyword">cli</span><br>    <span class="hljs-keyword">hlt</span><br>    <span class="hljs-keyword">jmp</span> _stop<br><span class="hljs-meta"></span><br><span class="hljs-meta">.section</span> .bss<br><span class="hljs-meta">.space</span> <span class="hljs-number">2</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span> <br><span class="hljs-symbol">kernel_stack:</span> <br><br></code></pre></td></tr></table></figure><p>multiboot的头的前三部分最为重要：</p><ul><li>magic：magic域固定为十六进制的0x1BADB002，这样方便BIOS的识别</li><li>flags：指出操作系统影响需要引导程序提供或支持的特性</li><li>checksum：32位无符号值，保证前三个域的值相加位0，即magic+flags+checksum&#x3D;0</li></ul><p>下面的内容即可得到解释：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">.set</span> MAGIC, 0x1badb002<br><span class="hljs-string">.set</span> FLAGS, <span class="hljs-params">(1&lt;&lt;0 | 1&lt;&lt;1)</span><br><span class="hljs-string">.set</span> CHECKSUM, -<span class="hljs-params">(MAGIC + FLAGS)</span><br><br><span class="hljs-string">.section</span> <span class="hljs-string">.multboot</span><br><span class="hljs-string">.long</span> MAGIC<br><span class="hljs-string">.long</span> FLAGS<br><span class="hljs-string">.long</span> CHECKSUM<br></code></pre></td></tr></table></figure><p>在引导multiboot规范头后，我们需要放出程序的入口点，即我们去哪执行kernel.cpp</p><p>这里插入一个汇编知识，汇编程序中以**.**开头的名称并不是指令的助记符，不会被翻译称机器指令，而是给汇编器一些特殊只是，成为汇编指示或伪操作。</p><p><strong>.section</strong>把代码划分为若干个段，成簇被操作系统加载执行时，每个段被加载到不同的地址，操作系统对不同的段赋予不同的读写执行权限</p><p><a href="https://wiki.osdev.org/ELF">ELF</a>is a format for storing programs or fragments of programs on disk, created as a result of compiling and linking</p><p>我们使用.section设置的各个段最终就存储在ELF文件中，下图介绍了ELF文件各个段所存储的内容极其权限</p><p><img src="/2022/09/19/wyoos001/ELF.jpg" alt="ELF"></p><p>观察我们的loader</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">.section</span> .text<br><span class="hljs-meta">.extern</span> kernelMain<br><span class="hljs-meta">.global</span> loader<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">loader:</span><br>    <span class="hljs-keyword">mov</span> $kernel_stack, %esp<br>    <span class="hljs-keyword">push</span> %eax<br>    <span class="hljs-keyword">push</span> %ebx<br>    <span class="hljs-keyword">call</span> kernelMain<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">kernel_stack:</span> <br></code></pre></td></tr></table></figure><p>首先定义.text段（已编译程序的机器代码），然后再text段中引入KernalMain编译后的内容</p><p>.global伪指令暴漏loader，以便让链接器linker能够找到loader地址</p><p>再接下来，loader中的内容，%esp是栈指针，在我们的<a href="https://www.bilibili.com/video/BV1Ut411o7VG?p=2&share_medium=android&share_plat=android&share_source=COPY&share_tag=s_i&timestamp=1614198935&unique_k=Vu8Mmp&vd_source=71ff1308c23d0ef0791f945a3cc515e6">视频链接2</a>的第一课提到，cpp文件并不会自动设置栈指针，需要我们手动设置，文件第11行有一个<strong>kernel_stack</strong>，我们将该位置设置为栈顶</p><p>接下来就要填我们前面提过的坑了，首先是<em><em>void</em> multiboot_structure, unsigned int magicnumber</em>*。按照规定，我们需要向kernel.cpp中传入两个参数，分别是Bootloader的地址和magic，这两个参数分别存在eax和ebx中，使用push指令将参数进行传递，其中一个坑填完。</p><p>接下来是另一个坑，我们在执行<strong>call kernelMain</strong>时会出现一个找不到函数的error，原因是cpp编译成汇编指令时会对函数名进行改变，所以我们访问不到，解决办法就是在cpp文件中添加<strong>extern “C”</strong></p><p>最后**_stop<strong>中，</strong>cli<strong>指令将IF置0，屏蔽掉“可屏蔽中断”，</strong>hlt<strong>指令是处理器的暂停指令，</strong>jmp**是跳转指令</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-symbol">_stop:</span><br>    <span class="hljs-keyword">cli</span><br>    <span class="hljs-keyword">hlt</span><br>    <span class="hljs-keyword">jmp</span> _stop<br><span class="hljs-meta"></span><br><span class="hljs-meta">.section</span> .bss<br><span class="hljs-meta">.space</span> <span class="hljs-number">2</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span> <br></code></pre></td></tr></table></figure><p>理论上我们的程序无法执行到_stop，因为call指令执行之后应当进入无线循环，如果执行到stop说明程序出现了问题</p><p>程序最后设置BSS段空间为2M，用于防止未初始化的全局和静态C变量</p><h3 id="2-3、linker-ld"><a href="#2-3、linker-ld" class="headerlink" title="2.3、linker.ld"></a>2.3、linker.ld</h3><p>首先放出linker.ld的内容，然后再尽力去分析每个部分的内容</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">ENTRY(<span class="hljs-params">loader</span>)</span><br><span class="hljs-constructor">OUTPUT_FORMAT(<span class="hljs-params">elf32</span>-<span class="hljs-params">i386</span>)</span><br><span class="hljs-constructor">OUTPUT_ARCH(<span class="hljs-params">i386</span>:<span class="hljs-params">i386</span>)</span><br><br>SECTIONS<br>&#123;<br>  . = <span class="hljs-number">0x0100000</span>;<br><br>  .text : <br>  &#123;<br>    *(.multiboot)<br>    *(.text*)<br>    *(.rodata)<br>  &#125;<br><br>  .data :<br>  &#123;<br>    start_ctors = .;<br>    <span class="hljs-constructor">KEEP(<span class="hljs-operator">*</span>( .<span class="hljs-params">init_array</span> )</span>);<br>    <span class="hljs-constructor">KEEP(<span class="hljs-operator">*</span>(SORT_BY_INIT_PRIORITY( .<span class="hljs-params">init_array</span>.<span class="hljs-operator">*</span> )</span>));<br>    end_ctors = .;<br><br>    *(.data)<br>  &#125;<br><br>  .bss :<br>  &#123;<br>    *(.bss)<br>  &#125;<br><br>  /DISCARD/ : <br>  &#123;<br>    *(.fini_array*)<br>    *(.comment)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>关于ld的参考内容，我找到了一下几个网站，后面讲解的内容也大概出自这里：</p><p><a href="https://wiki.osdev.org/LD">OSDEV</a></p><p><a href="https://www.gnu.org/software/binutils/">Binutils</a></p><p><a href="https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_node/ld_toc.html">Using ld</a></p><p>首先来看前面三行</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">ENTRY</span><span class="hljs-params">(loader)</span></span><br><span class="hljs-function"><span class="hljs-title">OUTPUT_FORMAT</span><span class="hljs-params">(elf32-i386)</span></span><br><span class="hljs-function"><span class="hljs-title">OUTPUT_ARCH</span><span class="hljs-params">(i386:i386)</span></span><br></code></pre></td></tr></table></figure><p><em>The linker command language includes a command specifically for defining the first executable instruction in an output file (its entry point). Its argument is a symbol name: ENTRY(symbol)</em></p><p>这句话翻译一下就是链接器的语言包括一句这样的指令：定义输出文件中要执行的第一行代码</p><p>参数的形式就是<strong>ENTRY(symbol)</strong></p><p>所以**ENTRY(loader)**就是告诉程序需要从loader处开始执行，我们在loader.s中有一句.global loader，暴漏了loader的位置，从而ld能够获取这个位置</p><p>OUTPUT_FORMAT(elf32-i386)以及OUTPUT_ARCH(i386:i386)就是指输出文件的格式以及输出文件所支持的平台</p><p>在<a href="https://wiki.osdev.org/LD">OSDEV</a>介绍linker的features中有这样一句</p><p><em>Supports most known output formats (ELF, Win32&#x2F;PE, COFF, a.out etc).</em></p><p>进一步找到<a href="https://wiki.osdev.org/Linker_Scripts">Linker Scripts关键词</a>可以找到OUTPUT_FORMAT可以填的内容</p><table><thead><tr><th>Format</th><th>Description</th></tr></thead><tbody><tr><td>binary</td><td>A flat binary with no formatting at all.</td></tr><tr><td>elf32-i386</td><td>32-bit ELF format for the i386 architecture.</td></tr><tr><td>elf64-x86-64</td><td>64-bit ELF format for the x86-64 architecture.</td></tr><tr><td>pe-i386</td><td>32-bit PE format for the i386 architecture.</td></tr></tbody></table><p>接下来是后面的.SECTIONS部分，<a href="https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_node/ld_18.html#SEC18">Section Defintions</a>中提到</p><p><em>The most frequently used statement in the SECTIONS command is the section definition, which specifies the properties of an output section: its location, alignment, contents, fill pattern, and target memory region</em></p><p>Section的格式一般为：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">SECTIONS &#123; <span class="hljs-string">...</span><br>  secname : &#123;<br>    contents<br>  &#125;<br><span class="hljs-string">...</span> &#125;<br></code></pre></td></tr></table></figure><p><em>secname is the name of the output section</em></p><p><em>contents is a specification of what goes there</em></p><p>secname需要包含在要输出文件各种中，比如(a.out中包括.text段，.data段或者.bss段，ELF文件包含的段前面提到过)</p><p>我们的SECTIONS中就包含.text,.bss以及.data段</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gcode">.text : <br>&#123;<br>  *<span class="hljs-comment">(.multiboot)</span><br>  *<span class="hljs-comment">(.text*)</span><br>  *<span class="hljs-comment">(.rodata)</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码。.text是我们要输出的段(section)，{}里面的内容是输入的内容，.multiboot表示成簇的multiboot段，*(.multiboot)表示所有文件的multiboot段，我们将{}内的内容作为输入，输出为.text段，同理.bss段</p><p>.data段的内容留到下一节一起解释，其中KEEP的作用是即使为引用符号，我们也要保留这部分</p><h3 id="2-4、Makefile"><a href="#2-4、Makefile" class="headerlink" title="2.4、Makefile"></a>2.4、Makefile</h3><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs mel">GPPPARAMS = -m32 -fno-use-cxa-atexit -nostdlib -fno-builtin -fno-rtti -fno-exceptions -fno-leading-underscore<br>ASPARAMS = -<span class="hljs-number">-32</span><br>LDPARAMS = -melf_i386<br><br>objects = loader.o kernel.o<br><br>%.o : %.cpp<br>g++ $&#123;GPPPARAMS&#125; -o $@ -c $&lt;<br><br>%.o : %.s<br>as $&#123;ASPARAMS&#125; -o $@ $&lt;<br><br>mykernel.bin: linker.ld $&#123;objects&#125;<br>ld $&#123;LDPARAMS&#125; -T $&lt; -o $@ $&#123;objects&#125;<br><br>install: mykernel.bin<br>sudo cp $&lt; /boot/mykernel.bin<br><br></code></pre></td></tr></table></figure><p>首先是GPPPARAMS，可以堪称g++ paramters，以下是各个参数代表的意思</p><figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ldif"><span class="hljs-literal">-</span>m32                    <span class="hljs-comment"># 指定编译为32位应用程序</span><br><span class="hljs-literal">-</span>fno-use-cxa-atexit     <span class="hljs-comment"># 禁用C析构函数__cxa_atexit</span><br><span class="hljs-literal">-</span>fleading-underscore    <span class="hljs-comment"># 编译时在C语言符号前加上下划线</span><br><span class="hljs-literal">-</span>fno-exceptions         <span class="hljs-comment"># 禁用异常机制</span><br><span class="hljs-literal">-</span>fno-builtin            <span class="hljs-comment"># 不使用C语言的内建函数</span><br><span class="hljs-literal">-</span>nostdlib               <span class="hljs-comment"># 不链接系统标准启动文件和标准库文件</span><br><span class="hljs-literal">-</span>fno-rtti               <span class="hljs-comment"># 禁用运行时类型信息</span><br><span class="hljs-literal">-</span>fno-pie                <span class="hljs-comment"># 禁用PIE模式</span><br></code></pre></td></tr></table></figure><p>ASPARAMS &#x3D; –32表示使用32位模式编译</p><p>LDPARAMS &#x3D; -melf_i386表示  -m -elf_i386保证调用时将需要的参数加上，然后调用真正的参数</p><p>后面的属于Makefile的常用内容，这里不做详细解释</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$@</span>:表示目标文件<br><span class="hljs-variable">$^</span>:表示所有的依赖文件<br><span class="hljs-variable">$&lt;</span>:表示第一个依赖文件<br><span class="hljs-variable">$?</span>:表示比目标还要鑫的以来文件列表<br></code></pre></td></tr></table></figure><h2 id="3、后记"><a href="#3、后记" class="headerlink" title="3、后记"></a>3、后记</h2><p>视频链接后面还有编写grub.cfg等操作，由于我们不使用这种方式打开自己的OS，所以这里暂时不展示该流程</p><p>本节留下了一个linker.ld的坑，下一节应该会填补完整</p><h3 id="3-1、乱七八糟的知识"><a href="#3-1、乱七八糟的知识" class="headerlink" title="3.1、乱七八糟的知识"></a>3.1、乱七八糟的知识</h3><p>在<a href="https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_node/ld_24.html#SEC24">The entry Point</a>中提到，<em>Entry is only one of several ways of choosing the entry point.</em></p><p>其他的方法包括：</p><ul><li>the &#96;-e’ entry command-line option;</li><li>the <code>ENTRY(symbol)</code> command in a linker control script;</li><li>the value of the symbol <code>start</code>, if present;</li><li>the address of the first byte of the <code>.text</code> section, if present;</li><li>The address <code>0</code>.</li></ul><p>其中第三条。<em>the value of the symbol start, if present</em>，在《Linux内核完全剖析》中有这样一段，</p><p><img src="/2022/09/19/wyoos001/entry_start.jpg" alt="entry_start"></p><p>此处用到了<strong>entry start</strong>。</p><p>这也算小小的学以致用了把。</p>]]></content>
    
    
    
    <tags>
      
      <tag>wyoos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/09/19/hello-world/"/>
    <url>/2022/09/19/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
