<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>从零开始的操作系统生活03-镜像制作</title>
    <link href="/2022/09/21/wyoos003/"/>
    <url>/2022/09/21/wyoos003/</url>
    
    <content type="html"><![CDATA[<h2 id="0、环境配置"><a href="#0、环境配置" class="headerlink" title="0、环境配置"></a>0、环境配置</h2><p>安装grub-legacy与xorriso，最后我们会将制作好的镜像放入虚拟机中运行，而不是在虚拟机中再安装一个虚拟机运行</p><p>但是安装grub-legacy时会发现报错了，原因应该是因为版本迭代问题导致的，最新的安装包名称应该是grub-efi-amd64</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> install grub-efi-amd64 xorriso<br></code></pre></td></tr></table></figure><p><a href="https://github.com/anhongzhan/wyoos/tree/master/003">github</a></p><h2 id="1、mykernel-iso"><a href="#1、mykernel-iso" class="headerlink" title="1、mykernel.iso"></a>1、mykernel.iso</h2><p>我们在使用虚拟机安装ubuntu系统的时候，选择的虚拟盘都是.iso后缀格式的，ISO文件是光盘的镜像文件，所有我们要做的事情就是将我们目前所写的内容转换成ISO镜像然后使用虚拟机打开即可</p><p><a href="https://www.gnu.org/software/grub/">GRUB</a>是一款multiboot loader，在链接中我们可以看到，grub-legacy已经不再维护了，所以我们需要安装替代的包，前面我们提过loader使用multiboot规范，multiboot规范对应的就是Multiboot loader</p><p><a href="https://www.gnu.org/software/xorriso/">xorriso</a>是一个用来创建和操作ISO 9660文件系统映像文件的工具，可以用来将影响文件烧录到DVD&#x2F;CD中</p><p>接下来开始制作镜像</p><p>我们在Makefile中添加如下语句：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">mykernel.iso: mykernel.bin<br><span class="hljs-built_in">mkdir</span> iso<br><span class="hljs-built_in">mkdir</span> iso/boot<br><span class="hljs-built_in">mkdir</span> iso/boot/grub<br><span class="hljs-built_in">cp</span> $&lt; iso/boot/<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;set timeout=0&#x27;</span> &gt;&gt; iso/boot/grub/grub.cfg<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;set default=0&#x27;</span> &gt;&gt; iso/boot/grub/grub.cfg<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;&#x27;</span> &gt;&gt; iso/boot/grub/grub.cfg<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;menuentry &quot;My Operating System&quot; &#123;&#x27;</span> &gt;&gt; iso/boot/grub/grub.cfg<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;multiboot /boot/mykernel.bin&#x27;</span> &gt;&gt; iso/boot/grub/grub.cfg<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;boot&#x27;</span> &gt;&gt; iso/boot/grub/grub.cfg<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;&#125;&#x27;</span> &gt;&gt; iso/boot/grub/grub.cfg<br>grub-mkrescue --output=<span class="hljs-variable">$@</span> iso<br><span class="hljs-built_in">rm</span> -rf iso<br></code></pre></td></tr></table></figure><p>前三句命令负责创建对应文件夹，**$&lt;**表示第一个依赖文件，也就是把mykernel.bin复制到&#x2F;iso&#x2F;boot&#x2F;文件夹中去</p><p>grub是引导操作系统的程序，他会根据自己的配置文件去引导内核，这项配置文件就是grub.cfg</p><p><em>set timeout&#x3D;0</em>是设置启动等待的时间，加入我们的电脑存在两个系统，设置timeout&#x3D;10，则进入系统之前会给我们10s的时间去选择进入哪一个系统</p><p><em>set default&#x3D;0</em>表示设置默认进入的系统，计算机都是从0开始的，也就是默认进入第一个系统。当然，我们也只有这一个系统</p><p><em>menuentry</em>指设置启动菜单，<em>My Operating System</em>是菜单名称，<em>multiboot &#x2F;boot&#x2F;mykernel.bin</em>是指其中的一个启动项</p><p><strong>下面的<em>boot</em>不清楚是干什么的，暂时码住，以后有机会回来解释</strong></p><p>运行结束后的grub.cfg内容如下所示：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">set</span> <span class="hljs-attribute">timeout</span>=0<br><span class="hljs-built_in">set</span> <span class="hljs-attribute">default</span>=0<br><br>menuentry <span class="hljs-string">&quot;My Operating System&quot;</span> &#123;<br>multiboot /boot/mykernel.bin<br>boot<br>&#125;<br><br></code></pre></td></tr></table></figure><p>像看到这个文件内容则需要删除makefile的最后一句rm -rf iso，但是记得下一次编译的时候加上这句话并且先把iso文件夹删除掉</p><p>最后<em>grub-mkrescue --output&#x3D;$@ iso</em>则是使用grub-mkrescue命令制作镜像文件，–output是指定输出文件，<strong>但是后面的iso我并不清楚是什么作用，如果是指定文件夹，那么生成的mykernel.iso会在&#x2F;iso中，但实际上是与&#x2F;iso同名文件夹，也不需要修改文件的后缀，甚至稍作修改也不会出现问题，此处码住，有待解决</strong></p><p>最后的<em>rm -rf iso</em>就是删除无用的文件夹</p><h2 id="2、打开mykernel-iso"><a href="#2、打开mykernel-iso" class="headerlink" title="2、打开mykernel.iso"></a>2、打开mykernel.iso</h2><p>激动人心的时刻到了，我们经过了三节的努力，终于可以看到一些成果了</p><p>首先，本人使用的是virtualbox虚拟机安装的ubuntu 20.04系统，生成的iso镜像文件也在ubuntu系统中，想要再次使用虚拟机运行则需要将iso文件拷贝到windows系统中，这部分使用共享文件夹或者直接拖动即可，大家根据自身情况自行解决这个问题</p><p>然后打开VirtualBox，选择新建</p><p><img src="/2022/09/21/wyoos003/newVirtual.PNG" alt="newVirtual"></p><p>操作系统类型和版本要选择Other</p><p>点击下一步之后打开虚拟机，然后选择设备-&gt;分配光驱-&gt;选择虚拟盘</p><p><img src="/2022/09/21/wyoos003/open.png" alt="open"></p><p>然后将我们制作好的iso镜像添加进去，关闭虚拟机后再次开启即可。</p><p>最后的运行效果如下：</p><p><img src="/2022/09/21/wyoos003/result.png" alt="result"></p><h2 id="3、补充"><a href="#3、补充" class="headerlink" title="3、补充"></a>3、补充</h2><h3 id="3-1、timeout"><a href="#3-1、timeout" class="headerlink" title="3.1、timeout"></a>3.1、timeout</h3><p>大家也可以试试修改Makefile中的set timeout&#x3D;10，然后再运行看看结果</p><h3 id="3-2、VirtualBox虚拟机中使用VirtualBox"><a href="#3-2、VirtualBox虚拟机中使用VirtualBox" class="headerlink" title="3.2、VirtualBox虚拟机中使用VirtualBox"></a>3.2、VirtualBox虚拟机中使用VirtualBox</h3><p>为了方便运行我们的结果，而不是来回调换系统运行调试，并且在参考视频的提示下，我们最终选择使用VIrtualBox虚拟机中再安装VirtualBox虚拟机</p><p>首先我的ubuntu虚拟机配置 8192MB 显存 16MB</p><p>在ubuntu中安装VirtualBox之前记得设置windows的VirtualBox中的<strong>启用嵌套VT-x&#x2F;AMD-V</strong></p><p>具体设置方式如下：设置-&gt;系统-&gt;处理器-&gt;启用嵌套VT-x&#x2F;AMD-V</p><p>如果<strong>启用嵌套VT-x&#x2F;AMD-V</strong>是灰色的，请参考<a href="https://www.cnblogs.com/88223100/p/How_to_enable_Nested_VT-x_AMD-V_on_VirtualBox.html">链接</a></p><p>然后虚拟机中安装VirtualBox</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> install VirtualBox<br></code></pre></td></tr></table></figure><p>安装完毕之后打开VIrtualBox，然后和前面的流程相同，创建新的虚拟电脑，不添加镜像，启动虚拟电脑然后添加镜像，最后重启虚拟电脑即可。</p><p>最后的最后，我们在Makefile中添加内容</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-built_in">run</span>: mykernel.iso<br>(killall virtualboxvm &amp;&amp; <span class="hljs-built_in">sleep</span> <span class="hljs-number">1</span>) || <span class="hljs-literal">true</span><br>virtualboxvm --startvm <span class="hljs-string">&quot;wyoos&quot;</span> &amp;<br></code></pre></td></tr></table></figure><p>这样每次我们编译完成后只要执行<strong>make run</strong>即可</p>]]></content>
    
    
    
    <tags>
      
      <tag>wyoos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零开始的操作系统生活02-对Hello World的补充</title>
    <link href="/2022/09/20/wyoos002/"/>
    <url>/2022/09/20/wyoos002/</url>
    
    <content type="html"><![CDATA[<h2 id="1、开始"><a href="#1、开始" class="headerlink" title="1、开始"></a>1、开始</h2><p><a href="https://github.com/anhongzhan/wyoos/tree/master/002">github</a></p><h3 id="1-1、环境配置"><a href="#1-1、环境配置" class="headerlink" title="1.1、环境配置"></a>1.1、环境配置</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">sudo apt-get <span class="hljs-keyword">install </span>g++ <span class="hljs-keyword">binutils </span>libc6-dev-i386<br></code></pre></td></tr></table></figure><h3 id="1-2、对linker-ld的补充"><a href="#1-2、对linker-ld的补充" class="headerlink" title="1.2、对linker.ld的补充"></a>1.2、对linker.ld的补充</h3><p>linker脚本是用来控制link过程的文件，文件中包含内容为linker的处理命令，主要用于描述输入文件到输出文件时各个内容的分步以及内存映射等</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">ENTRY(<span class="hljs-params">loader</span>)</span><br><span class="hljs-constructor">OUTPUT_FORMAT(<span class="hljs-params">elf32</span>-<span class="hljs-params">i386</span>)</span><br><span class="hljs-constructor">OUTPUT_ARCH(<span class="hljs-params">i386</span>:<span class="hljs-params">i386</span>)</span><br><br>SECTIONS<br>&#123;<br>  . = <span class="hljs-number">0x0100000</span>;<br><br>  .text : <br>  &#123;<br>    *(.multiboot)<br>    *(.text*)<br>    *(.rodata)<br>  &#125;<br><br>  .data :<br>  &#123;<br>    start_ctors = .;<br>    <span class="hljs-constructor">KEEP(<span class="hljs-operator">*</span>( .<span class="hljs-params">init_array</span> )</span>);<br>    <span class="hljs-constructor">KEEP(<span class="hljs-operator">*</span>(SORT_BY_INIT_PRIORITY( .<span class="hljs-params">init_array</span>.<span class="hljs-operator">*</span> )</span>));<br>    end_ctors = .;<br><br>    *(.data)<br>  &#125;<br><br>  .bss :<br>  &#123;<br>    *(.bss)<br>  &#125;<br><br>  /DISCARD/ : <br>  &#123;<br>    *(.fini_array*)<br>    *(.comment)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-2-1、首地址设置"><a href="#1-2-1、首地址设置" class="headerlink" title="1.2.1、首地址设置"></a>1.2.1、首地址设置</h4><p>首先是.SECTION{}中第一句*. &#x3D; 0x0100000;*</p><p>这句话的意思是设置我们所要输出的文件的字段的起始地址，比如我们将地址设置为0x100000，则后面的.text段就从该地址开始放置，紧接着是.data段和.bss段，同样我们也可以使用如下方法：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">. </span>= 0x010000;<br><span class="hljs-title">.text : </span><br>&#123;<br>&#125;<br><span class="hljs-bullet">. </span>= 0x080000;<br><span class="hljs-title">.data :</span><br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>将不同的段放置在不同的区域</p><h4 id="1-2-2、data段的设置"><a href="#1-2-2、data段的设置" class="headerlink" title="1.2.2、data段的设置"></a>1.2.2、data段的设置</h4><p>接下来是.data段中的内容，ELF文件中对于.data段的描述是：<em>已初始化的全局和静态C变量</em></p><p>在调用KernelMain方法之前，我们还需要的一个步骤就是保证初始化必要的全局变量，这些全局变量存放在**.init_array**段中。</p><p>为了完成以上操作，我们还需要在Kernel.cpp中添加初始化函数<strong>callConstructors()<strong>，该函数获取</strong>.init_array</strong>段中的指令</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">typedef <span class="hljs-title">void</span> (<span class="hljs-params">*constructor</span>)()</span>;<br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> constructor start_ctors;<br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> constructor end_ctors;<br><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">callConstructors</span>()</span>&#123;<br>    <span class="hljs-keyword">for</span>(constructor* i = &amp;start_ctors; i != &amp;end_ctors; i++)&#123;<br>        (*i)();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>这里面其实我也不是很清楚内部的运行机制，暂时码住，以后遇到答案之后再回来做出解释</strong></p><p><em>补充一：kernel.cpp中两个函数start_ctors与end_stors获取到linker.ld中的两个位置，然后执行linker.ld两个位置之间的命令（代码）</em></p><p>还记得我们前面说过，在<strong>loader.s</strong>中需要暴漏<strong>KernelMain</strong>的地址让链接器知道吗？同理，我们也需要暴漏<strong>callConstructors</strong>的地址，也就是在<strong>loader.s</strong>中添加如下代码：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">.section</span> <span class="hljs-string">.text</span><br><span class="hljs-string">.extern</span> kernelMain<br><span class="hljs-string">.extern</span> callConstructors<br><span class="hljs-string">.global</span> loader<br></code></pre></td></tr></table></figure><p>第三行代码为我们刚刚所添加的内容</p><p>最后我们来看.data段中的内容，第一句与最后一句分别为start_ctors和end_ctors，这两部分是链接器指定的两个具体地址，然后将初始化指令，也就是.data段中的数据放置在这两段地址之间，也就是说链接器指定了一段空间用于存放.data段的数据，也就是**.init_array*<em>，前面提到过，</em>KEEP的作用是即使为引用符号，我们也要保留这部分*，另一种解释方法就是KEEP函数可以保证数据不被系统释放，属于对全局变量的保护，也可能是出于对程序生命周期的考虑。</p><p><strong>SORT_BY_INIT_PRIORITY</strong>函数会对**.init_array**中的数据以升序的方式进行排序，然后再放置到输出文件中</p><h4 id="1-2-3、-x2F-DISCARD-x2F"><a href="#1-2-3、-x2F-DISCARD-x2F" class="headerlink" title="1.2.3、&#x2F;DISCARD&#x2F;"></a>1.2.3、&#x2F;DISCARD&#x2F;</h4><p>放置在**&#x2F;DISCARD&#x2F;**段中的内容不会被链接器输出出去</p><h3 id="1-3、printf函数"><a href="#1-3、printf函数" class="headerlink" title="1.3、printf函数"></a>1.3、printf函数</h3><p>还记得上一节中我们写的<strong>kernel.cpp</strong>文件吗，里面调用了printf函数进行打印，但是我们并没有引入头文件，结果可想而知，肯定无法编译过去，报错内容如下：<em>identifier “printf” is undefined</em></p><p>printf函数本身就是调用操作系统的函数然后进行打印，所以我们不可以直接引入头文件进行编译，必须自己实现，实现的方法如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printf</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str)</span></span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> *VideoMemory = (<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>*)<span class="hljs-number">0xb8000</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;str[i];i++)&#123;<br>        VideoMemory[i] = (VideoMemory[i] &amp; <span class="hljs-number">0xFF00</span>) | str[i];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://wiki.osdev.org/Printing_To_Screen">0xb8000</a>是操作系统向屏幕写入数据的第一个地址，我们只需要将数据一次写入相应的地址，最后就能够打印出来</p><p>根据<a href="https://wiki.osdev.org/Printing_To_Screen">0xb8000</a>中的介绍，操作系统使用两个字节存储一个字符，第一个字节存储字符内容，第二个字节存储字符的颜色，我们这里不关心颜色，所以只需要将每一个低位字节置零之后将要写入的字符“与”进去即可。</p><p>同时我们也需要注意大端和小端的问题！！！</p><p>也就是<strong>VideoMemory[i] &#x3D; (VideoMemory[i] &amp; 0xFF00) | str[i];</strong></p><h3 id="1-4、运行结果"><a href="#1-4、运行结果" class="headerlink" title="1.4、运行结果"></a>1.4、运行结果</h3><p>直接运行<strong>make mykernel.bin</strong>，可以得到如下的文件序列：</p><p><img src="/2022/09/20/wyoos002/%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.PNG" alt="运行结果"></p><p>或者也可以分步运行：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-built_in">make</span> kernel.o<br><span class="hljs-built_in">make</span> loader.o<br><span class="hljs-built_in">make</span> mykernel.bin<br></code></pre></td></tr></table></figure><h2 id="2、后记"><a href="#2、后记" class="headerlink" title="2、后记"></a>2、后记</h2><p>在看<a href="https://www.bilibili.com/video/BV1RX4y157CM?p=1&vd_source=71ff1308c23d0ef0791f945a3cc515e6">视频链接1</a>进行学习以及在网上查阅资料时发现了一处不太一样的地方，我们使用<em>objdump -d kernel.o</em>进行反汇编时可能会发现<strong>KernelMain</strong>等函数编译后的方法名称有可能变成**_KernelMain**，这就需要对loader.s以及linker.ld进行修改，修改的方法就是把反汇编的名称替换原来的名称，具体做法可以参照<a href="https://www.bilibili.com/video/BV1RX4y157CM?p=1&vd_source=71ff1308c23d0ef0791f945a3cc515e6">视频链接1</a>，但是我并没有遇到这个问题</p>]]></content>
    
    
    
    <tags>
      
      <tag>wyoos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零开始的操作系统生活01-Hello World</title>
    <link href="/2022/09/19/wyoos001/"/>
    <url>/2022/09/19/wyoos001/</url>
    
    <content type="html"><![CDATA[<h2 id="0、目标"><a href="#0、目标" class="headerlink" title="0、目标"></a>0、目标</h2><p>使用cpp开发一个操作系统，具体能走到哪一步看毅力，加油！</p><h2 id="1、参考内容"><a href="#1、参考内容" class="headerlink" title="1、参考内容"></a>1、参考内容</h2><p><a href="https://www.bilibili.com/video/BV1RX4y157CM?p=1&vd_source=71ff1308c23d0ef0791f945a3cc515e6">视频链接1</a></p><p><a href="https://www.bilibili.com/video/BV1Ut411o7VG?p=2&share_medium=android&share_plat=android&share_source=COPY&share_tag=s_i&timestamp=1614198935&unique_k=Vu8Mmp&vd_source=71ff1308c23d0ef0791f945a3cc515e6">视频链接2</a></p><p><a href="https://github.com/anhongzhan/wyoos/tree/master/001">github</a></p><h2 id="2、开始"><a href="#2、开始" class="headerlink" title="2、开始"></a>2、开始</h2><p><a href="https://zh.wikipedia.org/zh-hans/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a>是一组主管并控制计算机操作、运用和运行硬件、软件资源和提供公共服务来组织用户交互的相互关联的系统软件程序</p><p>首先观察我们简单的操作系统的目录</p><p><img src="/2022/09/19/wyoos001/index.PNG" alt="index"></p><p>kernel.cpp是我们操作系统的运行程序，loader.s负责把我们的操作系统加载到硬件中运行，linker.ld负责将kernel与loader链接到一起，生成机器能够“读懂”的结构，Makefile负责进行编译。</p><h3 id="2-1、kernel-cpp"><a href="#2-1、kernel-cpp" class="headerlink" title="2.1、kernel.cpp"></a>2.1、kernel.cpp</h3><p>首先我们来编写最简单的操作系统：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">kernelMain</span><span class="hljs-params">(<span class="hljs-type">void</span>* multiboot_structure, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> magicnumber)</span></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world!&quot;</span>);<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们先来看程序的主体部分</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">kernelMain</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world!&quot;</span>);<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>程序主体就是要打印一句hello world，然后无限循环，操作系统本身就是无限循环，这里我们留下两个坑</p><p><em>*extern “C”<strong>以及</strong>void* multiboot_structure, unsigned int magicnumber</em>*稍后会做出解释</p><h3 id="2-2、GRUB-multiboot引导规范"><a href="#2-2、GRUB-multiboot引导规范" class="headerlink" title="2.2、GRUB multiboot引导规范"></a>2.2、GRUB multiboot引导规范</h3><p>操作系统的启动流程如下：</p><p><img src="/2022/09/19/wyoos001/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png" alt="操作系统启动流程"></p><p><a href="https://cloud.tencent.com/developer/article/1414532">参考链接</a></p><p>图中第三步GRUB引导存在各种各样的规范，我们所使用的称为multiboot引导规范，之所以存在各种规范，原因就是方便进行开发，比如我们下面的loader.s</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">.set</span> MAGIC, <span class="hljs-number">0x1badb002</span><br><span class="hljs-meta">.set</span> FLAGS, (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">0</span> | <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">1</span>)<br><span class="hljs-meta">.set</span> CHECKSUM, -(MAGIC + FLAGS)<br><span class="hljs-meta"></span><br><span class="hljs-meta">.section</span> .multiboot<br><span class="hljs-meta">.long</span> MAGIC<br><span class="hljs-meta">.long</span> FLAGS<br><span class="hljs-meta">.long</span> CHECKSUM<br><span class="hljs-meta">.section</span> .text<br><span class="hljs-meta">.extern</span> kernelMain<br><span class="hljs-meta">.global</span> loader<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">loader:</span><br>    <span class="hljs-keyword">mov</span> $kernel_stack, %esp<br>    <span class="hljs-keyword">push</span> %eax<br>    <span class="hljs-keyword">push</span> %ebx<br>    <span class="hljs-keyword">call</span> kernelMain<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">_stop:</span><br>    <span class="hljs-keyword">cli</span><br>    <span class="hljs-keyword">hlt</span><br>    <span class="hljs-keyword">jmp</span> _stop<br><span class="hljs-meta"></span><br><span class="hljs-meta">.section</span> .bss<br><span class="hljs-meta">.space</span> <span class="hljs-number">2</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span> <br><span class="hljs-symbol">kernel_stack:</span> <br><br></code></pre></td></tr></table></figure><p>multiboot的头的前三部分最为重要：</p><ul><li>magic：magic域固定为十六进制的0x1BADB002，这样方便BIOS的识别</li><li>flags：指出操作系统影响需要引导程序提供或支持的特性</li><li>checksum：32位无符号值，保证前三个域的值相加位0，即magic+flags+checksum&#x3D;0</li></ul><p>下面的内容即可得到解释：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">.set</span> MAGIC, 0x1badb002<br><span class="hljs-string">.set</span> FLAGS, <span class="hljs-params">(1&lt;&lt;0 | 1&lt;&lt;1)</span><br><span class="hljs-string">.set</span> CHECKSUM, -<span class="hljs-params">(MAGIC + FLAGS)</span><br><br><span class="hljs-string">.section</span> <span class="hljs-string">.multboot</span><br><span class="hljs-string">.long</span> MAGIC<br><span class="hljs-string">.long</span> FLAGS<br><span class="hljs-string">.long</span> CHECKSUM<br></code></pre></td></tr></table></figure><p>在引导multiboot规范头后，我们需要放出程序的入口点，即我们去哪执行kernel.cpp</p><p>这里插入一个汇编知识，汇编程序中以**.**开头的名称并不是指令的助记符，不会被翻译称机器指令，而是给汇编器一些特殊只是，成为汇编指示或伪操作。</p><p><strong>.section</strong>把代码划分为若干个段，成簇被操作系统加载执行时，每个段被加载到不同的地址，操作系统对不同的段赋予不同的读写执行权限</p><p><a href="https://wiki.osdev.org/ELF">ELF</a>is a format for storing programs or fragments of programs on disk, created as a result of compiling and linking</p><p>我们使用.section设置的各个段最终就存储在ELF文件中，下图介绍了ELF文件各个段所存储的内容极其权限</p><p><img src="/2022/09/19/wyoos001/ELF.jpg" alt="ELF"></p><p>观察我们的loader</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">.section</span> .text<br><span class="hljs-meta">.extern</span> kernelMain<br><span class="hljs-meta">.global</span> loader<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">loader:</span><br>    <span class="hljs-keyword">mov</span> $kernel_stack, %esp<br>    <span class="hljs-keyword">push</span> %eax<br>    <span class="hljs-keyword">push</span> %ebx<br>    <span class="hljs-keyword">call</span> kernelMain<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">kernel_stack:</span> <br></code></pre></td></tr></table></figure><p>首先定义.text段（已编译程序的机器代码），然后再text段中引入KernalMain编译后的内容</p><p>.global伪指令暴漏loader，以便让链接器linker能够找到loader地址</p><p>再接下来，loader中的内容，%esp是栈指针，在我们的<a href="https://www.bilibili.com/video/BV1Ut411o7VG?p=2&share_medium=android&share_plat=android&share_source=COPY&share_tag=s_i&timestamp=1614198935&unique_k=Vu8Mmp&vd_source=71ff1308c23d0ef0791f945a3cc515e6">视频链接2</a>的第一课提到，cpp文件并不会自动设置栈指针，需要我们手动设置，文件第11行有一个<strong>kernel_stack</strong>，我们将该位置设置为栈顶</p><p>接下来就要填我们前面提过的坑了，首先是<em><em>void</em> multiboot_structure, unsigned int magicnumber</em>*。按照规定，我们需要向kernel.cpp中传入两个参数，分别是Bootloader的地址和magic，这两个参数分别存在eax和ebx中，使用push指令将参数进行传递，其中一个坑填完。</p><p>接下来是另一个坑，我们在执行<strong>call kernelMain</strong>时会出现一个找不到函数的error，原因是cpp编译成汇编指令时会对函数名进行改变，所以我们访问不到，解决办法就是在cpp文件中添加<strong>extern “C”</strong></p><p>最后**_stop<strong>中，</strong>cli<strong>指令将IF置0，屏蔽掉“可屏蔽中断”，</strong>hlt<strong>指令是处理器的暂停指令，</strong>jmp**是跳转指令</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-symbol">_stop:</span><br>    <span class="hljs-keyword">cli</span><br>    <span class="hljs-keyword">hlt</span><br>    <span class="hljs-keyword">jmp</span> _stop<br><span class="hljs-meta"></span><br><span class="hljs-meta">.section</span> .bss<br><span class="hljs-meta">.space</span> <span class="hljs-number">2</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span> <br></code></pre></td></tr></table></figure><p>理论上我们的程序无法执行到_stop，因为call指令执行之后应当进入无线循环，如果执行到stop说明程序出现了问题</p><p>程序最后设置BSS段空间为2M，用于防止未初始化的全局和静态C变量</p><h3 id="2-3、linker-ld"><a href="#2-3、linker-ld" class="headerlink" title="2.3、linker.ld"></a>2.3、linker.ld</h3><p>首先放出linker.ld的内容，然后再尽力去分析每个部分的内容</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">ENTRY(<span class="hljs-params">loader</span>)</span><br><span class="hljs-constructor">OUTPUT_FORMAT(<span class="hljs-params">elf32</span>-<span class="hljs-params">i386</span>)</span><br><span class="hljs-constructor">OUTPUT_ARCH(<span class="hljs-params">i386</span>:<span class="hljs-params">i386</span>)</span><br><br>SECTIONS<br>&#123;<br>  . = <span class="hljs-number">0x0100000</span>;<br><br>  .text : <br>  &#123;<br>    *(.multiboot)<br>    *(.text*)<br>    *(.rodata)<br>  &#125;<br><br>  .data :<br>  &#123;<br>    start_ctors = .;<br>    <span class="hljs-constructor">KEEP(<span class="hljs-operator">*</span>( .<span class="hljs-params">init_array</span> )</span>);<br>    <span class="hljs-constructor">KEEP(<span class="hljs-operator">*</span>(SORT_BY_INIT_PRIORITY( .<span class="hljs-params">init_array</span>.<span class="hljs-operator">*</span> )</span>));<br>    end_ctors = .;<br><br>    *(.data)<br>  &#125;<br><br>  .bss :<br>  &#123;<br>    *(.bss)<br>  &#125;<br><br>  /DISCARD/ : <br>  &#123;<br>    *(.fini_array*)<br>    *(.comment)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>关于ld的参考内容，我找到了一下几个网站，后面讲解的内容也大概出自这里：</p><p><a href="https://wiki.osdev.org/LD">OSDEV</a></p><p><a href="https://www.gnu.org/software/binutils/">Binutils</a></p><p><a href="https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_node/ld_toc.html">Using ld</a></p><p>首先来看前面三行</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">ENTRY</span><span class="hljs-params">(loader)</span></span><br><span class="hljs-function"><span class="hljs-title">OUTPUT_FORMAT</span><span class="hljs-params">(elf32-i386)</span></span><br><span class="hljs-function"><span class="hljs-title">OUTPUT_ARCH</span><span class="hljs-params">(i386:i386)</span></span><br></code></pre></td></tr></table></figure><p><em>The linker command language includes a command specifically for defining the first executable instruction in an output file (its entry point). Its argument is a symbol name: ENTRY(symbol)</em></p><p>这句话翻译一下就是链接器的语言包括一句这样的指令：定义输出文件中要执行的第一行代码</p><p>参数的形式就是<strong>ENTRY(symbol)</strong></p><p>所以**ENTRY(loader)**就是告诉程序需要从loader处开始执行，我们在loader.s中有一句.global loader，暴漏了loader的位置，从而ld能够获取这个位置</p><p>OUTPUT_FORMAT(elf32-i386)以及OUTPUT_ARCH(i386:i386)就是指输出文件的格式以及输出文件所支持的平台</p><p>在<a href="https://wiki.osdev.org/LD">OSDEV</a>介绍linker的features中有这样一句</p><p><em>Supports most known output formats (ELF, Win32&#x2F;PE, COFF, a.out etc).</em></p><p>进一步找到<a href="https://wiki.osdev.org/Linker_Scripts">Linker Scripts关键词</a>可以找到OUTPUT_FORMAT可以填的内容</p><table><thead><tr><th>Format</th><th>Description</th></tr></thead><tbody><tr><td>binary</td><td>A flat binary with no formatting at all.</td></tr><tr><td>elf32-i386</td><td>32-bit ELF format for the i386 architecture.</td></tr><tr><td>elf64-x86-64</td><td>64-bit ELF format for the x86-64 architecture.</td></tr><tr><td>pe-i386</td><td>32-bit PE format for the i386 architecture.</td></tr></tbody></table><p>接下来是后面的.SECTIONS部分，<a href="https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_node/ld_18.html#SEC18">Section Defintions</a>中提到</p><p><em>The most frequently used statement in the SECTIONS command is the section definition, which specifies the properties of an output section: its location, alignment, contents, fill pattern, and target memory region</em></p><p>Section的格式一般为：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">SECTIONS &#123; <span class="hljs-string">...</span><br>  secname : &#123;<br>    contents<br>  &#125;<br><span class="hljs-string">...</span> &#125;<br></code></pre></td></tr></table></figure><p><em>secname is the name of the output section</em></p><p><em>contents is a specification of what goes there</em></p><p>secname需要包含在要输出文件各种中，比如(a.out中包括.text段，.data段或者.bss段，ELF文件包含的段前面提到过)</p><p>我们的SECTIONS中就包含.text,.bss以及.data段</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gcode">.text : <br>&#123;<br>  *<span class="hljs-comment">(.multiboot)</span><br>  *<span class="hljs-comment">(.text*)</span><br>  *<span class="hljs-comment">(.rodata)</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码。.text是我们要输出的段(section)，{}里面的内容是输入的内容，.multiboot表示成簇的multiboot段，*(.multiboot)表示所有文件的multiboot段，我们将{}内的内容作为输入，输出为.text段，同理.bss段</p><p>.data段的内容留到下一节一起解释，其中KEEP的作用是即使为引用符号，我们也要保留这部分</p><h3 id="2-4、Makefile"><a href="#2-4、Makefile" class="headerlink" title="2.4、Makefile"></a>2.4、Makefile</h3><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs mel">GPPPARAMS = -m32 -fno-use-cxa-atexit -nostdlib -fno-builtin -fno-rtti -fno-exceptions -fno-leading-underscore<br>ASPARAMS = -<span class="hljs-number">-32</span><br>LDPARAMS = -melf_i386<br><br>objects = loader.o kernel.o<br><br>%.o : %.cpp<br>g++ $&#123;GPPPARAMS&#125; -o $@ -c $&lt;<br><br>%.o : %.s<br>as $&#123;ASPARAMS&#125; -o $@ $&lt;<br><br>mykernel.bin: linker.ld $&#123;objects&#125;<br>ld $&#123;LDPARAMS&#125; -T $&lt; -o $@ $&#123;objects&#125;<br><br>install: mykernel.bin<br>sudo cp $&lt; /boot/mykernel.bin<br><br></code></pre></td></tr></table></figure><p>首先是GPPPARAMS，可以堪称g++ paramters，以下是各个参数代表的意思</p><figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ldif"><span class="hljs-literal">-</span>m32                    <span class="hljs-comment"># 指定编译为32位应用程序</span><br><span class="hljs-literal">-</span>fno-use-cxa-atexit     <span class="hljs-comment"># 禁用C析构函数__cxa_atexit</span><br><span class="hljs-literal">-</span>fleading-underscore    <span class="hljs-comment"># 编译时在C语言符号前加上下划线</span><br><span class="hljs-literal">-</span>fno-exceptions         <span class="hljs-comment"># 禁用异常机制</span><br><span class="hljs-literal">-</span>fno-builtin            <span class="hljs-comment"># 不使用C语言的内建函数</span><br><span class="hljs-literal">-</span>nostdlib               <span class="hljs-comment"># 不链接系统标准启动文件和标准库文件</span><br><span class="hljs-literal">-</span>fno-rtti               <span class="hljs-comment"># 禁用运行时类型信息</span><br><span class="hljs-literal">-</span>fno-pie                <span class="hljs-comment"># 禁用PIE模式</span><br></code></pre></td></tr></table></figure><p>ASPARAMS &#x3D; –32表示使用32位模式编译</p><p>LDPARAMS &#x3D; -melf_i386表示  -m -elf_i386保证调用时将需要的参数加上，然后调用真正的参数</p><p>后面的属于Makefile的常用内容，这里不做详细解释</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$@</span>:表示目标文件<br><span class="hljs-variable">$^</span>:表示所有的依赖文件<br><span class="hljs-variable">$&lt;</span>:表示第一个依赖文件<br><span class="hljs-variable">$?</span>:表示比目标还要鑫的以来文件列表<br></code></pre></td></tr></table></figure><h2 id="3、后记"><a href="#3、后记" class="headerlink" title="3、后记"></a>3、后记</h2><p>视频链接后面还有编写grub.cfg等操作，由于我们不使用这种方式打开自己的OS，所以这里暂时不展示该流程</p><p>本节留下了一个linker.ld的坑，下一节应该会填补完整</p><h3 id="3-1、乱七八糟的知识"><a href="#3-1、乱七八糟的知识" class="headerlink" title="3.1、乱七八糟的知识"></a>3.1、乱七八糟的知识</h3><p>在<a href="https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_node/ld_24.html#SEC24">The entry Point</a>中提到，<em>Entry is only one of several ways of choosing the entry point.</em></p><p>其他的方法包括：</p><ul><li>the &#96;-e’ entry command-line option;</li><li>the <code>ENTRY(symbol)</code> command in a linker control script;</li><li>the value of the symbol <code>start</code>, if present;</li><li>the address of the first byte of the <code>.text</code> section, if present;</li><li>The address <code>0</code>.</li></ul><p>其中第三条。<em>the value of the symbol start, if present</em>，在《Linux内核完全剖析》中有这样一段，</p><p><img src="/2022/09/19/wyoos001/entry_start.jpg" alt="entry_start"></p><p>此处用到了<strong>entry start</strong>。</p><p>这也算小小的学以致用了把。</p>]]></content>
    
    
    
    <tags>
      
      <tag>wyoos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/09/19/hello-world/"/>
    <url>/2022/09/19/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
